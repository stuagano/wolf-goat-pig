     1	from fastapi import FastAPI, Depends, Body, HTTPException, Request, Path, Query, UploadFile, File, Header
     2	from sqlalchemy.orm import Session
     3	from sqlalchemy import text
     4	from fastapi.middleware.cors import CORSMiddleware
     5	from fastapi.middleware.trustedhost import TrustedHostMiddleware
     6	from fastapi.responses import JSONResponse, FileResponse, HTMLResponse
     7	from fastapi.staticfiles import StaticFiles
     8	from . import models, schemas, crud, database
     9	
    10	from .game_state import game_state
    11	from .wolf_goat_pig_simulation import WolfGoatPigSimulation, WGPPlayer, BallPosition, TeamFormation
    12	from .post_hole_analytics import PostHoleAnalyzer
    13	from .simulation_timeline_enhancements import (
    14	    enhance_simulation_with_timeline, 
    15	    format_poker_betting_state, 
    16	    create_betting_options
    17	)
    18	from .course_import import CourseImporter, import_course_by_name, import_course_from_json, save_course_to_database
    19	from .domain.shot_result import ShotResult
    20	from .domain.player import Player
    21	from .domain.shot_range_analysis import analyze_shot_decision
    22	from pydantic import BaseModel, Field
    23	from typing import List, Optional, Any, Dict, Tuple
    24	import os
    25	import httpx
    26	import logging
    27	import traceback
    28	import json
    29	import tempfile
    30	import random
    31	from datetime import datetime
    32	
    33	from .services.player_service import PlayerService # Import PlayerService
    34	from .services.email_service import EmailService, get_email_service
    35	from .services.oauth2_email_service import OAuth2EmailService, get_oauth2_email_service
    36	from .services.team_formation_service import TeamFormationService
    37	from .services.sunday_game_service import generate_sunday_pairings
    38	from .services.legacy_signup_service import get_legacy_signup_service
    39	# Email scheduler will be initialized on-demand to prevent startup blocking
    40	# from .services.email_scheduler import email_scheduler
    41	from .services.auth_service import get_current_user
    42	
    43	# Global variable for email scheduler (initialized on demand)
    44	email_scheduler = None
    45	
    46	# Configure logging
    47	logger = logging.getLogger(__name__)
    48	
    49	# Initialize Wolf Goat Pig Simulation (will be replaced when game starts)
    50	wgp_simulation = WolfGoatPigSimulation(player_count=4)
    51	# Initialize Post-Hole Analyzer
    52	post_hole_analyzer = PostHoleAnalyzer()
    53	
    54	# Response model classes for Action API
    55	class ActionRequest(BaseModel):
    56	    """Unified action request for all game interactions"""
    57	    action_type: str  # INITIALIZE_GAME, PLAY_SHOT, REQUEST_PARTNERSHIP, etc.
    58	    payload: Optional[Dict[str, Any]] = None
    59	
    60	class ActionResponse(BaseModel):
    61	    """Standard response structure for all actions"""
    62	    game_state: Dict[str, Any]
    63	    log_message: str
    64	    available_actions: List[Dict[str, Any]]
    65	    timeline_event: Optional[Dict[str, Any]] = None
    66	
    67	# Course management models
    68	class CourseCreate(BaseModel):
    69	    name: str
    70	    holes: List[Dict[str, Any]]
    71	
    72	class CourseUpdate(BaseModel):
    73	    holes: List[Dict[str, Any]]
    74	
    75	class CourseImportRequest(BaseModel):
    76	    course_name: str
    77	    state: Optional[str] = None
    78	    city: Optional[str] = None
    79	
    80	
    81	class BallSeed(BaseModel):
    82	    """Testing helper payload for manually positioning a ball."""
    83	
    84	    player_id: str = Field(..., description="Unique player identifier")
    85	    distance_to_pin: float = Field(..., ge=0, description="Distance remaining in yards")
    86	    lie_type: str = Field("fairway", description="Current lie type for the ball")
    87	    shot_count: int = Field(1, ge=0, description="Number of strokes taken on the hole")
    88	    holed: bool = Field(False, description="Whether the ball is in the hole")
    89	    conceded: bool = Field(False, description="If the putt has been conceded")
    90	    penalty_strokes: int = Field(0, ge=0, description="Penalty strokes assessed on the shot")
    91	
    92	
    93	class BettingSeed(BaseModel):
    94	    """Testing helper payload for adjusting betting metadata."""
    95	
    96	    base_wager: Optional[int] = Field(None, ge=0)
    97	    current_wager: Optional[int] = Field(None, ge=0)
    98	    doubled: Optional[bool] = None
    99	    redoubled: Optional[bool] = None
   100	    carry_over: Optional[bool] = None
   101	    float_invoked: Optional[bool] = None
   102	    option_invoked: Optional[bool] = None
   103	    duncan_invoked: Optional[bool] = None
   104	    tunkarri_invoked: Optional[bool] = None
   105	    big_dick_invoked: Optional[bool] = None
   106	    joes_special_value: Optional[int] = None
   107	    line_of_scrimmage: Optional[str] = None
   108	    ping_pong_count: Optional[int] = Field(None, ge=0)
   109	
   110	
   111	class SimulationSeedRequest(BaseModel):
   112	    """Parameters accepted by the test seeding endpoint."""
   113	
   114	    current_hole: Optional[int] = Field(
   115	        None, description="Hole number to switch the active simulation to"
   116	    )
   117	    shot_order: Optional[List[str]] = Field(
   118	        None, description="Explicit hitting order for the active hole"
   119	    )
   120	    ball_positions: List[BallSeed] = Field(default_factory=list)
   121	    ball_positions_replace: bool = Field(False, description="Replace all ball positions when True")
   122	    line_of_scrimmage: Optional[str] = None
   123	    next_player_to_hit: Optional[str] = None
   124	    current_order_of_play: Optional[List[str]] = None
   125	    wagering_closed: Optional[bool] = None
   126	    betting: Optional[BettingSeed] = None
   127	    team_formation: Optional[Dict[str, Any]] = Field(
   128	        None, description="Override the current TeamFormation dataclass"
   129	    )
   130	    clear_balls_in_hole: bool = Field(False, description="Clear recorded holed balls before applying seed")
   131	    reset_doubles_history: bool = Field(True, description="Clear double-offer history to avoid stale offers")
   132	
   133	app = FastAPI(
   134	    title="Wolf Goat Pig Golf Simulation API",
   135	    description="A comprehensive golf betting simulation API with unified Action API",
   136	    version="1.0.0",
   137	    docs_url="/docs" if os.getenv("ENVIRONMENT") != "production" else None,
   138	    redoc_url="/redoc" if os.getenv("ENVIRONMENT") != "production" else None
   139	)
   140	
   141	ENABLE_TEST_ENDPOINTS = os.getenv("ENABLE_TEST_ENDPOINTS", "false").lower() in {"1", "true", "yes"}
   142	ADMIN_EMAILS = {"stuagano@gmail.com", "admin@wgp.com"}
   143	
   144	
   145	def require_admin(x_admin_email: Optional[str] = Header(None)) -> None:
   146	    if not x_admin_email or x_admin_email not in ADMIN_EMAILS:
   147	        raise HTTPException(status_code=403, detail="Admin access required")
   148	
   149	# Database initialization moved to main startup handler
   150	
   151	# Trusted host middleware for security
   152	# Temporarily disable TrustedHostMiddleware during development/testing for easier debugging
   153	# if os.getenv("ENVIRONMENT") != "development":
   154	#     app.add_middleware(
   155	#         TrustedHostMiddleware, 
   156	#         allowed_hosts=[
   157	#             "localhost",
   158	#             "127.0.0.1",
   159	#             "wolf-goat-pig-api.onrender.com",
   160	#             "wolf-goat-pig.onrender.com",
   161	#             "wolf-goat-pig-frontend.onrender.com"
   162	#         ]
   163	#     )
   164	
   165	# CORS middleware
   166	# Configure origins based on environment
   167	allowed_origins = [
   168	    "https://wolf-goat-pig.vercel.app",  # Production frontend
   169	    "https://wolf-goat-pig-frontend.onrender.com",  # Alternative frontend URL
   170	]
   171	
   172	# Add localhost for development only
   173	if os.getenv("ENVIRONMENT") != "production":
   174	    allowed_origins.extend([
   175	        "http://localhost:3000",             # Local development
   176	        "http://localhost:3001",             # Alternative local port
   177	        "http://127.0.0.1:3000",            # Alternative localhost
   178	        "http://127.0.0.1:3001",            # Alternative localhost
   179	    ])
   180	
   181	app.add_middleware(
   182	    CORSMiddleware,
   183	    allow_origins=allowed_origins,
   184	    allow_credentials=True,
   185	    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD", "PATCH"],
   186	    allow_headers=[
   187	        "Accept",
   188	        "Accept-Language", 
   189	        "Content-Language",
   190	        "Content-Type",
   191	        "Authorization",
   192	        "X-Admin-Email",
   193	        "X-Requested-With",
   194	        "Origin",
   195	        "Access-Control-Request-Method",
   196	        "Access-Control-Request-Headers"
   197	    ],
   198	    expose_headers=["*"]
   199	)
   200	
   201	
   202	# Global exception handler
   203	@app.exception_handler(HTTPException)
   204	async def http_exception_handler(request: Request, exc: HTTPException):
   205	    """Handle HTTP exceptions and preserve their status codes"""
   206	    logger.error(f"HTTP exception: {exc.status_code} - {exc.detail}")
   207	    # Add logging for host header during exceptions
   208	    logger.error(f"Request Host header: {request.headers.get('host')}")
   209	    logger.error(f"Request Client host: {request.client.host}")
   210	    return JSONResponse(
   211	        status_code=exc.status_code,
   212	        content={"error": "HTTP error", "detail": exc.detail}
   213	    )
   214	
   215	@app.exception_handler(Exception)
   216	async def global_exception_handler(request: Request, exc: Exception):
   217	    logger.error(f"Unhandled exception: {exc}")
   218	    logger.error(traceback.format_exc())
   219	    return JSONResponse(
   220	        status_code=500,
   221	        content={"error": "Internal server error", "detail": str(exc)}
   222	    )
   223	
   224	@app.on_event("startup")
   225	async def startup():
   226	    """Enhanced startup event handler with comprehensive bootstrapping."""
   227	    logger.info("ðŸº Wolf Goat Pig API starting up...")
   228	    logger.info(f"ENVIRONMENT: {os.getenv('ENVIRONMENT')}")
   229	    
   230	    # Initialize database first
   231	    try:
   232	        # Ensure all models are imported before creating tables
   233	        from . import models
   234	        database.init_db()
   235	        logger.info("Database initialized successfully")
   236	        
   237	        # Verify game_state table exists
   238	        db = database.SessionLocal()
   239	        try:
   240	            db.execute(text("SELECT COUNT(*) FROM game_state"))
   241	            logger.info("game_state table verified")
   242	        except Exception as table_error:
   243	            logger.error(f"game_state table verification failed: {table_error}")
   244	            # Try to create tables again
   245	            database.Base.metadata.create_all(bind=database.engine)
   246	            logger.info("Tables recreated")
   247	        finally:
   248	            db.close()
   249	            
   250	    except Exception as e:
   251	        logger.error(f"Failed to initialize database: {e}")
   252	        logger.error(f"Traceback: {traceback.format_exc()}")
   253	        # Don't continue if database fails in production
   254	        if os.getenv("ENVIRONMENT") == "production":
   255	            raise
   256	    
   257	    # Email scheduler initialization moved to on-demand/UI configuration
   258	    # This prevents email issues from blocking app startup
   259	    logger.info("ðŸ“§ Email scheduler will be initialized on-demand")
   260	    
   261	    try:
   262	        # Import seeding functionality
   263	        from .seed_data import seed_all_data, get_seeding_status
   264	        
   265	        # Check if we should skip seeding (for testing or when explicitly disabled)
   266	        skip_seeding = os.getenv("SKIP_SEEDING", "false").lower() == "true"
   267	        
   268	        if skip_seeding:
   269	            logger.info("â­ï¸ Seeding skipped due to SKIP_SEEDING environment variable")
   270	        else:
   271	            # Check current seeding status first
   272	            logger.info("ðŸ” Checking existing data status...")
   273	            status = get_seeding_status()
   274	            
   275	            if status["status"] == "success":
   276	                # Verify all critical components are present
   277	                verification = status.get("verification", {})
   278	                overall_status = verification.get("overall", {}).get("status", "unknown")
   279	                
   280	                if overall_status == "success":
   281	                    logger.info("âœ… All required data already present, skipping seeding")
   282	                else:
   283	                    logger.info("âš ï¸ Some data missing, running seeding process...")
   284	                    await run_seeding_process()
   285	            else:
   286	                logger.info("ðŸŒ± No existing data found, running initial seeding...")
   287	                await run_seeding_process()
   288	        
   289	        # Initialize game state and course manager
   290	        logger.info("ðŸŽ¯ Initializing game state...")
   291	        try:
   292	            # Ensure game_state is properly initialized with courses
   293	            courses = game_state.get_courses()
   294	            if not courses:
   295	                logger.warning("âš ï¸ No courses found in game state, attempting to reload...")
   296	                game_state.course_manager.__init__()  # Reinitialize course manager
   297	                courses = game_state.get_courses()
   298	            
   299	            logger.info(f"ðŸ“š Game state initialized with {len(courses)} courses")
   300	        except Exception as e:
   301	            logger.error(f"âŒ Failed to initialize game state: {e}")
   302	            # Continue startup - game state will use fallback data
   303	        
   304	        # Verify simulation can be created
   305	        logger.info("ðŸ”§ Verifying simulation initialization...")
   306	        try:
   307	            # Test creating a basic simulation
   308	            test_players = [
   309	                {"id": "p1", "name": "Test1", "handicap": 10},
   310	                {"id": "p2", "name": "Test2", "handicap": 15},
   311	                {"id": "p3", "name": "Test3", "handicap": 8},
   312	                {"id": "p4", "name": "Test4", "handicap": 20}
   313	            ]
   314	            test_simulation = WolfGoatPigSimulation(player_count=4)
   315	            logger.info("âœ… Simulation initialization verified")
   316	        except Exception as e:
   317	            logger.warning(f"âš ï¸ Simulation test failed (non-critical): {e}")
   318	        
   319	        # Initialize email scheduler if email notifications enabled
   320	        if os.getenv("ENABLE_EMAIL_NOTIFICATIONS", "true").lower() == "true":
   321	            try:
   322	                logger.info("ðŸ“§ Initializing email scheduler...")
   323	                result = await initialize_email_scheduler()
   324	                if result["status"] == "success":
   325	                    logger.info("âœ… Email scheduler initialized")
   326	                else:
   327	                    logger.warning(f"âš ï¸ Email scheduler: {result['message']}")
   328	            except Exception as e:
   329	                logger.error(f"âŒ Email scheduler initialization failed: {e}")
   330	        else:
   331	            logger.info("ðŸ“§ Email notifications disabled")
   332	        
   333	        logger.info("ðŸš€ Wolf Goat Pig API startup completed successfully!")
   334	        
   335	    except Exception as e:
   336	        logger.error(f"âŒ Critical startup error: {e}")
   337	        logger.error("âš ï¸ Application may not function properly")
   338	        # Don't raise - allow app to start with limited functionality
   339	
   340	@app.on_event("shutdown")
   341	async def shutdown():
   342	    """Cleanup on shutdown"""
   343	    logger.info("ðŸ›‘ Wolf Goat Pig API shutting down...")
   344	    
   345	    # Stop email scheduler if it was started
   346	    try:
   347	        if email_scheduler is not None and hasattr(email_scheduler, 'stop'):
   348	            email_scheduler.stop()
   349	            logger.info("ðŸ“§ Email scheduler stopped successfully")
   350	    except Exception as e:
   351	        logger.error(f"Failed to stop email scheduler: {str(e)}")
   352	
   353	async def run_seeding_process():
   354	    """Run the data seeding process during startup."""
   355	    try:
   356	        from .seed_data import seed_all_data
   357	        
   358	        logger.info("ðŸŒ± Starting data seeding process...")
   359	        
   360	        # Run seeding in a try-catch to prevent startup failure
   361	        seeding_results = seed_all_data(force_reseed=False)
   362	        
   363	        if seeding_results["status"] == "success":
   364	            logger.info("âœ… Data seeding completed successfully")
   365	            
   366	            # Log seeding summary
   367	            if "results" in seeding_results:
   368	                for component, result in seeding_results["results"].items():
   369	                    added_count = result.get("added", 0)
   370	                    if added_count > 0:
   371	                        logger.info(f"  ðŸ“Š {component}: {added_count} items added")
   372	                    
   373	        elif seeding_results["status"] == "warning":
   374	            logger.warning(f"âš ï¸ Data seeding completed with warnings: {seeding_results.get('message')}")
   375	            
   376	        else:
   377	            logger.error(f"âŒ Data seeding failed: {seeding_results.get('message')}")
   378	            logger.warning("ðŸ”„ Application will continue with fallback data")
   379	            
   380	    except Exception as e:
   381	        logger.error(f"âŒ Critical error during seeding: {e}")
   382	        logger.warning("ðŸ”„ Application will continue with fallback data")
   383	
   384	@app.get("/health")
   385	def health_check():
   386	    """Comprehensive health check endpoint verifying all critical systems"""
   387	    health_status = {
   388	        "status": "healthy",
   389	        "timestamp": datetime.now().isoformat(),
   390	        "environment": os.getenv("ENVIRONMENT", "unknown"),
   391	        "version": "1.0.0",
   392	        "components": {}
   393	    }
   394	    
   395	    # During initial deployment, be more lenient with health checks
   396	    is_initial_deployment = os.getenv("ENVIRONMENT") == "production"
   397	    overall_healthy = True
   398	    
   399	    try:
   400	        # 1. Database connectivity test
   401	        db = database.SessionLocal()
   402	        try:
   403	            db.execute(text("SELECT 1"))
   404	            health_status["components"]["database"] = {
   405	                "status": "healthy",
   406	                "message": "Database connection successful"
   407	            }
   408	        except Exception as e:
   409	            logger.error(f"Database health check failed: {e}")
   410	            health_status["components"]["database"] = {
   411	                "status": "unhealthy",
   412	                "message": f"Database connection failed: {str(e)}"
   413	            }
   414	            overall_healthy = False
   415	        finally:
   416	            db.close()
   417	        
   418	        # 2. Course data availability check
   419	        try:
   420	            courses = game_state.get_courses()
   421	            course_count = len(courses) if courses else 0
   422	            
   423	            if course_count >= 1:
   424	                health_status["components"]["courses"] = {
   425	                    "status": "healthy",
   426	                    "message": f"{course_count} courses available",
   427	                    "courses": list(courses.keys()) if courses else []
   428	                }
   429	            else:
   430	                health_status["components"]["courses"] = {
   431	                    "status": "warning" if is_initial_deployment else "unhealthy",
   432	                    "message": "No courses available (may be initializing)"
   433	                }
   434	                if not is_initial_deployment:
   435	                    overall_healthy = False
   436	                
   437	        except Exception as e:
   438	            logger.error(f"Course availability check failed: {e}")
   439	            health_status["components"]["courses"] = {
   440	                "status": "warning" if is_initial_deployment else "unhealthy",
   441	                "message": f"Course check failed: {str(e)}"
   442	            }
   443	            if not is_initial_deployment:
   444	                overall_healthy = False
   445	        
   446	        # 3. Rules availability check
   447	        try:
   448	            db = database.SessionLocal()
   449	            try:
   450	                from . import models
   451	                rule_count = db.query(models.Rule).count()
   452	                
   453	                if rule_count >= 5:  # Minimum reasonable number of rules
   454	                    health_status["components"]["rules"] = {
   455	                        "status": "healthy",
   456	                        "message": f"{rule_count} rules loaded"
   457	                    }
   458	                else:
   459	                    health_status["components"]["rules"] = {
   460	                        "status": "warning",
   461	                        "message": f"Only {rule_count} rules found, may be incomplete"
   462	                    }
   463	            except Exception as e:
   464	                health_status["components"]["rules"] = {
   465	                    "status": "warning",
   466	                    "message": f"Rules check failed: {str(e)}"
   467	                }
   468	            finally:
   469	                db.close()
   470	                
   471	        except Exception as e:
   472	            logger.error(f"Rules availability check failed: {e}")
   473	            health_status["components"]["rules"] = {
   474	                "status": "warning",
   475	                "message": f"Rules check error: {str(e)}"
   476	            }
   477	        
   478	        # 4. AI Players availability check
   479	        try:
   480	            db = database.SessionLocal()
   481	            try:
   482	                from . import models
   483	                ai_player_count = (
   484	                    db.query(models.PlayerProfile)
   485	                    .filter(models.PlayerProfile.is_ai == 1)
   486	                    .filter(models.PlayerProfile.is_active == 1)
   487	                    .count()
   488	                )
   489	
   490	                if ai_player_count >= 4:  # Need at least 4 for a game
   491	                    health_status["components"]["ai_players"] = {
   492	                        "status": "healthy",
   493	                        "message": f"{ai_player_count} AI players available"
   494	                    }
   495	                elif ai_player_count >= 1:
   496	                    health_status["components"]["ai_players"] = {
   497	                        "status": "warning",
   498	                        "message": f"Only {ai_player_count} AI players available, need at least 4 for full game"
   499	                    }
   500	                else:
   501	                    health_status["components"]["ai_players"] = {
   502	                        "status": "warning",
   503	                        "message": "No AI players available (may be initializing)"
   504	                    }
   505	                    # Don't fail health check for missing AI players during initial deployment
   506	                    if not is_initial_deployment:
   507	                        overall_healthy = False
   508	            finally:
   509	                db.close()
   510	
   511	        except Exception as e:
   512	            logger.error(f"AI players availability check failed: {e}")
   513	            health_status["components"]["ai_players"] = {
   514	                "status": "warning",
   515	                "message": f"AI players check failed: {str(e)}"
   516	            }
   517	        
   518	        # 5. Simulation initialization test
   519	        try:
   520	            # Test basic simulation creation
   521	            test_simulation = WolfGoatPigSimulation(player_count=4)
   522	            health_status["components"]["simulation"] = {
   523	                "status": "healthy",
   524	                "message": "Simulation engine operational"
   525	            }
   526	        except Exception as e:
   527	            logger.error(f"Simulation initialization test failed: {e}")
   528	            health_status["components"]["simulation"] = {
   529	                "status": "warning" if is_initial_deployment else "unhealthy",
   530	                "message": f"Simulation test failed: {str(e)}"
   531	            }
   532	            if not is_initial_deployment:
   533	                overall_healthy = False
   534	        
   535	        # 6. Game state check
   536	        try:
   537	            state = game_state.get_state()
   538	            if state:
   539	                health_status["components"]["game_state"] = {
   540	                    "status": "healthy",
   541	                    "message": "Game state manager operational"
   542	                }
   543	            else:
   544	                health_status["components"]["game_state"] = {
   545	                    "status": "warning",
   546	                    "message": "Game state appears empty but functional"
   547	                }
   548	        except Exception as e:
   549	            logger.error(f"Game state check failed: {e}")
   550	            health_status["components"]["game_state"] = {
   551	                "status": "warning" if is_initial_deployment else "unhealthy",
   552	                "message": f"Game state check failed: {str(e)}"
   553	            }
   554	            if not is_initial_deployment:
   555	                overall_healthy = False
   556	        
   557	        # 7. Import seeding status check
   558	        try:
   559	            from .seed_data import get_seeding_status
   560	            seeding_status = get_seeding_status()
   561	            
   562	            if seeding_status["status"] == "success":
   563	                overall_verification = seeding_status.get("verification", {}).get("overall", {})
   564	                if overall_verification.get("status") == "success":
   565	                    health_status["components"]["data_seeding"] = {
   566	                        "status": "healthy",
   567	                        "message": "All required data properly seeded"
   568	                    }
   569	                else:
   570	                    health_status["components"]["data_seeding"] = {
   571	                        "status": "warning",
   572	                        "message": "Some seeded data may be incomplete"
   573	                    }
   574	            else:
   575	                health_status["components"]["data_seeding"] = {
   576	                    "status": "warning",
   577	                    "message": f"Data seeding status: {seeding_status.get('message', 'Unknown')}"
   578	                }
   579	                
   580	        except Exception as e:
   581	            logger.error(f"Data seeding status check failed: {e}")
   582	            health_status["components"]["data_seeding"] = {
   583	                "status": "warning",
   584	                "message": f"Seeding status check failed: {str(e)}"
   585	            }
   586	        
   587	        # Set overall status
   588	        if not overall_healthy:
   589	            health_status["status"] = "unhealthy"
   590	            raise HTTPException(status_code=503, detail="Critical system components are unhealthy")
   591	        
   592	        # Check for warnings
   593	        warning_count = sum(1 for comp in health_status["components"].values() 
   594	                          if comp["status"] == "warning")
   595	        
   596	        if warning_count > 0:
   597	            health_status["status"] = "degraded"
   598	            health_status["warnings"] = f"{warning_count} component(s) with warnings"
   599	        
   600	        return health_status
   601	        
   602	    except HTTPException:
   603	        raise
   604	    except Exception as e:
   605	        logger.error(f"Health check failed: {e}")
   606	        health_status["status"] = "unhealthy"
   607	        health_status["error"] = str(e)
   608	        raise HTTPException(status_code=503, detail=f"Health check failed: {str(e)}")
   609	
   610	
   611	@app.get("/healthz")
   612	def health_check_render_alias():
   613	    """Simplified health endpoint for Render monitoring."""
   614	    try:
   615	        # Reuse the comprehensive health check; Render only needs 200/503.
   616	        health_check()
   617	        return {"status": "ok"}
   618	    except HTTPException as exc:
   619	        # Mirror original status code to keep behaviour consistent.
   620	        raise exc
   621	
   622	@app.get("/rules", response_model=list[schemas.Rule])
   623	def get_rules():
   624	    """Get Wolf Goat Pig rules"""
   625	    try:
   626	        db = database.SessionLocal()
   627	        rules = crud.get_rules(db)
   628	        return rules
   629	    except Exception as e:
   630	        logger.error(f"Error getting rules: {e}")
   631	        raise HTTPException(status_code=500, detail="Failed to get rules")
   632	    finally:
   633	        db.close()
   634	
   635	# Course Management Endpoints
   636	@app.get("/players/all", response_model=List[schemas.PlayerProfileResponse])
   637	def get_all_players(
   638	    active_only: bool = Query(True, description="Only return active players"),
   639	    db: Session = Depends(database.get_db)
   640	):
   641	    """Get all player profiles."""
   642	    player_service = PlayerService(db)
   643	    return player_service.get_all_player_profiles(active_only=active_only)
   644	
   645	@app.get("/courses")
   646	def get_courses():
   647	    """Get all available courses with robust fallback handling"""
   648	    try:
   649	        courses = game_state.get_courses()
   650	        
   651	        # Ensure we always return at least one default course
   652	        if not courses:
   653	            logger.warning("No courses found in game state, attempting to reload from database")
   654	            
   655	            # Try to reload from database
   656	            try:
   657	                from .seed_data import get_seeding_status
   658	                seeding_status = get_seeding_status()
   659	                
   660	                if seeding_status["status"] == "success":
   661	                    # Reinitialize course manager
   662	                    game_state.course_manager.__init__()
   663	                    courses = game_state.get_courses()
   664	                    
   665	                    if courses:
   666	                        logger.info(f"Successfully reloaded {len(courses)} courses from database")
   667	                    else:
   668	                        logger.warning("Course manager reinitialization failed, using fallback")
   669	                        courses = get_fallback_courses()
   670	                else:
   671	                    logger.warning("Database seeding incomplete, using fallback courses")
   672	                    courses = get_fallback_courses()
   673	                    
   674	            except Exception as reload_error:
   675	                logger.error(f"Failed to reload courses from database: {reload_error}")
   676	                courses = get_fallback_courses()
   677	        
   678	        logger.info(f"Retrieved {len(courses)} courses: {list(courses.keys())}")
   679	        return courses
   680	        
   681	    except Exception as e:
   682	        logger.error(f"Critical error getting courses: {e}")
   683	        logger.error(traceback.format_exc())
   684	        
   685	        # Always return fallback course to prevent frontend failure
   686	        courses = get_fallback_courses()
   687	        logger.warning("Returning fallback courses due to critical error")
   688	        return courses
   689	
   690	def get_fallback_courses():
   691	    """Provide fallback course data when database/seeding fails"""
   692	    return {
   693	        "Emergency Course": {
   694	            "name": "Emergency Course",
   695	            "description": "Fallback course for system resilience",
   696	            "holes": [
   697	                {
   698	                    "hole_number": i,
   699	                    "par": 4 if i not in [4, 8, 12, 17] else 3 if i in [4, 8, 17] else 5,
   700	                    "yards": 400 if i not in [4, 8, 12, 17] else 160 if i in [4, 8, 17] else 520,
   701	                    "stroke_index": ((i - 1) % 18) + 1,
   702	                    "description": f"Emergency hole {i} - Par {4 if i not in [4, 8, 12, 17] else 3 if i in [4, 8, 17] else 5}"
   703	                }
   704	                for i in range(1, 19)
   705	            ],
   706	            "total_par": 72,
   707	            "total_yards": 6800,
   708	            "hole_count": 18
   709	        },
   710	        "Wing Point Golf & Country Club": {
   711	            "name": "Wing Point Golf & Country Club",
   712	            "description": "Classic parkland course (fallback data)",
   713	            "holes": [
   714	                {"hole_number": 1, "par": 4, "yards": 420, "stroke_index": 5, "description": "Opening hole with water hazard"},
   715	                {"hole_number": 2, "par": 4, "yards": 385, "stroke_index": 13, "description": "Straightaway par 4"},
   716	                {"hole_number": 3, "par": 5, "yards": 580, "stroke_index": 1, "description": "Long par 5 with fairway bunkers"},
   717	                {"hole_number": 4, "par": 3, "yards": 165, "stroke_index": 17, "description": "Short par 3 over water"},
   718	                {"hole_number": 5, "par": 4, "yards": 445, "stroke_index": 7, "description": "Long par 4 with OB left"},
   719	                {"hole_number": 6, "par": 4, "yards": 395, "stroke_index": 11, "description": "Slight dogleg left"},
   720	                {"hole_number": 7, "par": 5, "yards": 520, "stroke_index": 15, "description": "Reachable par 5"},
   721	                {"hole_number": 8, "par": 3, "yards": 185, "stroke_index": 3, "description": "Long par 3"},
   722	                {"hole_number": 9, "par": 4, "yards": 410, "stroke_index": 9, "description": "Finishing hole front nine"},
   723	                {"hole_number": 10, "par": 4, "yards": 455, "stroke_index": 2, "description": "Championship hole"},
   724	                {"hole_number": 11, "par": 5, "yards": 545, "stroke_index": 16, "description": "Three-shot par 5"},
   725	                {"hole_number": 12, "par": 3, "yards": 175, "stroke_index": 8, "description": "Elevated tee"},
   726	                {"hole_number": 13, "par": 4, "yards": 375, "stroke_index": 14, "description": "Short par 4"},
   727	                {"hole_number": 14, "par": 4, "yards": 435, "stroke_index": 4, "description": "Narrow fairway"},
   728	                {"hole_number": 15, "par": 5, "yards": 565, "stroke_index": 18, "description": "Longest hole"},
   729	                {"hole_number": 16, "par": 4, "yards": 425, "stroke_index": 10, "description": "Risk/reward hole"},
   730	                {"hole_number": 17, "par": 3, "yards": 155, "stroke_index": 12, "description": "Island green"},
   731	                {"hole_number": 18, "par": 4, "yards": 415, "stroke_index": 6, "description": "Dramatic finishing hole"}
   732	            ],
   733	            "total_par": 72,
   734	            "total_yards": 7050,
   735	            "hole_count": 18
   736	        }
   737	    }
   738	
   739	@app.get("/courses/{course_id}")
   740	def get_course_by_id(course_id: int):
   741	    """Get a specific course by ID (index in courses list)"""
   742	    try:
   743	        courses = game_state.get_courses()
   744	        if not courses:
   745	            raise HTTPException(status_code=404, detail="No courses available")
   746	        
   747	        # Convert courses dict to list and get by index
   748	        course_list = list(courses.values())
   749	        if course_id >= len(course_list) or course_id < 0:
   750	            raise HTTPException(status_code=404, detail="Course not found")
   751	        
   752	        # Return the course at the specified index
   753	        course = course_list[course_id]
   754	        return course
   755	        
   756	    except HTTPException:
   757	        raise
   758	    except Exception as e:
   759	        logger.error(f"Error getting course by ID {course_id}: {e}")
   760	        raise HTTPException(status_code=500, detail=f"Failed to get course: {str(e)}")
   761	
   762	@app.post("/courses", response_model=dict)
   763	def add_course(course: CourseCreate):
   764	    """Add a new course"""
   765	    try:
   766	        result = game_state.add_course(course.dict())
   767	        return {"status": "success", "message": f"Course '{course.name}' added successfully", "data": result}
   768	    except Exception as e:
   769	        logger.error(f"Error adding course: {e}")
   770	        raise HTTPException(status_code=500, detail=f"Failed to add course: {str(e)}")
   771	
   772	@app.put("/courses/{course_name}")
   773	def update_course(course_name: str, course_update: CourseUpdate):
   774	    """Update an existing course"""
   775	    try:
   776	        result = game_state.update_course(course_name, course_update.dict())
   777	        return {"status": "success", "message": f"Course '{course_name}' updated successfully", "data": result}
   778	    except Exception as e:
   779	        logger.error(f"Error updating course: {e}")
   780	        raise HTTPException(status_code=500, detail=f"Failed to update course: {str(e)}")
   781	
   782	@app.delete("/courses/{course_name}")
   783	def delete_course(course_name: str = Path(...)):
   784	    """Delete a course"""
   785	    try:
   786	        result = game_state.delete_course(course_name)
   787	        return {"status": "success", "message": f"Course '{course_name}' deleted successfully"}
   788	    except Exception as e:
   789	        logger.error(f"Error deleting course: {e}")
   790	        raise HTTPException(status_code=500, detail=f"Failed to delete course: {str(e)}")
   791	
   792	# Course Import Endpoints
   793	@app.post("/courses/import/search")
   794	async def import_course_by_search(request: CourseImportRequest):
   795	    """Search and import a course by name"""
   796	    try:
   797	        result = await import_course_by_name(request.course_name, request.state, request.city)
   798	        return result
   799	    except Exception as e:
   800	        logger.error(f"Error importing course by search: {e}")
   801	        raise HTTPException(status_code=500, detail=f"Failed to import course: {str(e)}")
   802	
   803	@app.post("/courses/import/file")
   804	async def import_course_from_file(file: UploadFile = File(...)):
   805	    """Import a course from uploaded JSON file"""
   806	    try:
   807	        if not file.filename.endswith('.json'):
   808	            raise HTTPException(status_code=400, detail="File must be a JSON file")
   809	        
   810	        content = await file.read()
   811	        course_data = json.loads(content.decode('utf-8'))
   812	        
   813	        result = await import_course_from_json(course_data)
   814	        return result
   815	    except Exception as e:
   816	        logger.error(f"Error importing course from file: {e}")
   817	        raise HTTPException(status_code=500, detail=f"Failed to import course: {str(e)}")
   818	
   819	@app.get("/courses/import/sources")
   820	def get_import_sources():
   821	    """Get available course import sources"""
   822	    try:
   823	        return {
   824	            "sources": [
   825	                {
   826	                    "name": "USGA Course Database",
   827	                    "description": "Official USGA course database with ratings and slopes",
   828	                    "endpoint": "/courses/import/search"
   829	                },
   830	                {
   831	                    "name": "JSON File Upload",
   832	                    "description": "Upload custom course data in JSON format",
   833	                    "endpoint": "/courses/import/file"
   834	                }
   835	            ]
   836	        }
   837	    except Exception as e:
   838	        logger.error(f"Error getting import sources: {e}")
   839	        raise HTTPException(status_code=500, detail="Failed to get import sources")
   840	
   841	@app.post("/courses/import/preview")
   842	async def preview_course_import(request: CourseImportRequest):
   843	    """Preview course data before importing"""
   844	    try:
   845	        # This would typically search the external database and return preview data
   846	        # For now, return a mock preview
   847	        return {
   848	            "course_name": request.course_name,
   849	            "preview_data": {
   850	                "holes": 18,
   851	                "par": 72,
   852	                "rating": 72.5,
   853	                "slope": 135,
   854	                "sample_holes": [
   855	                    {"hole": 1, "par": 4, "yards": 400, "stroke_index": 7},
   856	                    {"hole": 2, "par": 3, "yards": 175, "stroke_index": 15}
   857	                ]
   858	            }
   859	        }
   860	    except Exception as e:
   861	        logger.error(f"Error previewing course import: {e}")
   862	        raise HTTPException(status_code=500, detail=f"Failed to preview course: {str(e)}")
   863	
   864	# GHIN Integration Endpoints
   865	@app.get("/ghin/lookup")
   866	async def ghin_lookup(
   867	    last_name: str = Query(..., description="Golfer's last name"),
   868	    first_name: str = Query(None, description="Golfer's first name (optional)"),
   869	    page: int = Query(1),
   870	    per_page: int = Query(10),
   871	    db: Session = Depends(database.get_db)
   872	):
   873	    """Look up golfers by name using GHIN API"""
   874	    try:
   875	        from .services.ghin_service import GHINService
   876	        
   877	        # Get GHIN credentials from environment
   878	        email = os.getenv("GHIN_API_USER")
   879	        password = os.getenv("GHIN_API_PASS")
   880	        static_token = os.getenv("GHIN_API_STATIC_TOKEN", "ghincom")
   881	        
   882	        if not email or not password:
   883	            raise HTTPException(status_code=500, detail="GHIN credentials not configured in environment variables.")
   884	        
   885	        ghin_service = GHINService(db)
   886	        if not await ghin_service.initialize():
   887	            raise HTTPException(status_code=500, detail="GHIN service not available. Check credentials and logs.")
   888	
   889	        search_results = await ghin_service.search_golfers(last_name, first_name, page, per_page)
   890	        return search_results
   891	            
   892	    except httpx.HTTPStatusError as e:
   893	        logger.error(f"GHIN API error: {e.response.status_code} - {e.response.text}")
   894	        raise HTTPException(status_code=e.response.status_code, detail=f"GHIN API error: {e.response.status_code} - {e.response.text}")
   895	    except Exception as e:
   896	        logger.error(f"Error in GHIN lookup: {e}")
   897	        raise HTTPException(status_code=500, detail=f"Failed to lookup golfer: {str(e)}")
   898	    
   899	@app.post("/ghin/sync-player-handicap/{player_id}", response_model=Dict[str, Any])
   900	async def sync_player_ghin_handicap(
   901	    player_id: int = Path(..., description="The ID of the player to sync"),
   902	    db: Session = Depends(database.get_db)
   903	):
   904	    """Sync a specific player's handicap from GHIN."""
   905	    from .services.ghin_service import GHINService
   906	    
   907	    logger.info(f"Attempting to sync GHIN handicap for player ID: {player_id}")
   908	    ghin_service = GHINService(db)
   909	    if not await ghin_service.initialize():
   910	        raise HTTPException(status_code=500, detail="GHIN service not available. Check credentials and logs.")
   911	
   912	    synced_data = await ghin_service.sync_player_handicap(player_id)
   913	    
   914	    if synced_data:
   915	        logger.info(f"Successfully synced handicap for player {player_id}")
   916	        return {"status": "success", "message": "Handicap synced successfully", "data": synced_data}
   917	    else:
   918	        logger.error(f"Failed to sync handicap for player {player_id}")
   919	        raise HTTPException(status_code=500, detail=f"Failed to sync handicap for player {player_id}. Check if player has a GHIN ID and logs for details.")
   920	@app.get("/ghin/diagnostic")
   921	def ghin_diagnostic():
   922	    """Diagnostic endpoint for GHIN API configuration"""
   923	    email = os.getenv("GHIN_API_USER")
   924	    password = os.getenv("GHIN_API_PASS")
   925	    static_token = os.getenv("GHIN_API_STATIC_TOKEN")
   926	    
   927	    return {
   928	        "email_configured": bool(email),
   929	        "password_configured": bool(password),
   930	        "static_token_configured": bool(static_token),
   931	        "all_configured": bool(email and password),
   932	        "environment": os.getenv("ENVIRONMENT", "development")
   933	    }
   934	
   935	# Legacy Game Endpoints (for backward compatibility)
   936	@app.get("/game/state")
   937	def get_game_state():
   938	    """Get current game state (legacy endpoint)"""
   939	    try:
   940	        return game_state.get_state()
   941	    except Exception as e:
   942	        logger.error(f"Error getting game state: {e}")
   943	        raise HTTPException(status_code=500, detail="Failed to get game state")
   944	
   945	@app.get("/game/tips")
   946	def get_betting_tips():
   947	    """Get betting tips (legacy endpoint)"""
   948	    try:
   949	        return {"tips": [
   950	            "Consider your handicap advantage on this hole",
   951	            "Watch for partnership opportunities",
   952	            "Doubling can be risky but rewarding"
   953	        ]}
   954	    except Exception as e:
   955	        logger.error(f"Error getting betting tips: {e}")
   956	        raise HTTPException(status_code=500, detail="Failed to get betting tips")
   957	
   958	@app.get("/game/player_strokes")
   959	def get_player_strokes():
   960	    """Get player stroke information (legacy endpoint)"""
   961	    try:
   962	        state = game_state.get_state()
   963	        players = state.get("players", [])
   964	        return {
   965	            "players": [
   966	                {
   967	                    "name": player.get("name", "Unknown"),
   968	                    "strokes": player.get("strokes", 0),
   969	                    "handicap": player.get("handicap", 0)
   970	                }
   971	                for player in players
   972	            ]
   973	        }
   974	    except Exception as e:
   975	        logger.error(f"Error getting player strokes: {e}")
   976	        raise HTTPException(status_code=500, detail="Failed to get player strokes")
   977	
   978	def _get_current_captain_id() -> Optional[str]:
   979	    """Best-effort lookup for the active captain id across legacy and unified state."""
   980	    try:
   981	        simulation_state = wgp_simulation.get_game_state()
   982	        if isinstance(simulation_state, dict):
   983	            captain = simulation_state.get("captain_id") or simulation_state.get("captain")
   984	            if captain:
   985	                return captain
   986	    except Exception:
   987	        # If the simulation hasn't been initialized yet, fall back to legacy state
   988	        pass
   989	
   990	    try:
   991	        legacy_state = game_state.get_state()
   992	        if isinstance(legacy_state, dict):
   993	            return legacy_state.get("captain_id")
   994	    except Exception:
   995	        pass
   996	
   997	    return None
   998	
   999	
  1000	LEGACY_TO_UNIFIED_ACTIONS = {
  1001	    "next_hole": ("ADVANCE_HOLE", lambda payload: {}),
  1002	    "request_partner": ("REQUEST_PARTNERSHIP", lambda payload: payload or {}),
  1003	    "accept_partner": ("RESPOND_PARTNERSHIP", lambda payload: {"accepted": True}),
  1004	    "decline_partner": ("RESPOND_PARTNERSHIP", lambda payload: {"accepted": False}),
  1005	    "go_solo": ("DECLARE_SOLO", lambda payload: {}),
  1006	    "offer_double": (
  1007	        "OFFER_DOUBLE",
  1008	        lambda payload: {
  1009	            "player_id": payload.get("player_id")
  1010	            or payload.get("captain_id")
  1011	            or payload.get("offering_player_id")
  1012	            or payload.get("offering_team_id")
  1013	            or _get_current_captain_id(),
  1014	        },
  1015	    ),
  1016	    "accept_double": ("ACCEPT_DOUBLE", lambda payload: {"accepted": True}),
  1017	    "decline_double": ("ACCEPT_DOUBLE", lambda payload: {"accepted": False}),
  1018	    "concede_putt": ("CONCEDE_PUTT", lambda payload: payload or {}),
  1019	    "INITIALIZE_GAME": ("INITIALIZE_GAME", lambda payload: payload or {}),
  1020	}
  1021	
  1022	UNIFIED_ACTION_TYPES = {
  1023	    "INITIALIZE_GAME",
  1024	    "PLAY_SHOT",
  1025	    "REQUEST_PARTNERSHIP",
  1026	    "RESPOND_PARTNERSHIP",
  1027	    "DECLARE_SOLO",
  1028	    "OFFER_DOUBLE",
  1029	    "ACCEPT_DOUBLE",
  1030	    "CONCEDE_PUTT",
  1031	    "ADVANCE_HOLE",
  1032	    "OFFER_BIG_DICK",
  1033	    "ACCEPT_BIG_DICK",
  1034	    "AARDVARK_JOIN_REQUEST",
  1035	    "AARDVARK_TOSS",
  1036	    "AARDVARK_GO_SOLO",
  1037	    "PING_PONG_AARDVARK",
  1038	    "INVOKE_JOES_SPECIAL",
  1039	    "GET_POST_HOLE_ANALYSIS",
  1040	    "ENTER_HOLE_SCORES",
  1041	    "GET_ADVANCED_ANALYTICS",
  1042	}
  1043	
  1044	
  1045	@app.post("/game/action")
  1046	async def legacy_game_action(action: Dict[str, Any]):
  1047	    """Legacy game action endpoint that delegates to unified handlers when available."""
  1048	    try:
  1049	        # Handle both "action" and "action_type" field names for compatibility
  1050	        action_type = action.get("action") or action.get("action_type")
  1051	        if not action_type:
  1052	            raise HTTPException(status_code=400, detail="Action type required (use 'action' or 'action_type' field)")
  1053	
  1054	        payload = action.get("payload") or action.get("data") or {}
  1055	
  1056	        # Determine if this action should be routed through the unified handler stack
  1057	        normalized_action_type = None
  1058	        payload_transform = None
  1059	
  1060	        if action_type in LEGACY_TO_UNIFIED_ACTIONS:
  1061	            normalized_action_type, payload_transform = LEGACY_TO_UNIFIED_ACTIONS[action_type]
  1062	        else:
  1063	            upper_action = action_type.upper()
  1064	            if upper_action in UNIFIED_ACTION_TYPES:
  1065	                normalized_action_type = upper_action
  1066	                payload_transform = lambda incoming_payload: incoming_payload or {}
  1067	
  1068	        if normalized_action_type:
  1069	            normalized_payload = payload_transform(payload) if payload_transform else (payload or {})
  1070	
  1071	            # Route through the unified action endpoint to ensure consistent behaviour
  1072	            action_request = ActionRequest(action_type=normalized_action_type, payload=normalized_payload)
  1073	            response = await unified_action("legacy", action_request)
  1074	            return response
  1075	
  1076	        # Fallback to legacy game_state dispatch for actions not yet migrated
  1077	        result = game_state.dispatch_action(action_type, payload)
  1078	        updated_state = game_state.get_state()
  1079	
  1080	        return {
  1081	            "status": "success",
  1082	            "message": result,
  1083	            "game_state": updated_state,
  1084	        }
  1085	    except HTTPException:
  1086	        raise
  1087	    except Exception as e:
  1088	        logger.error(f"Error in legacy game action: {e}")
  1089	        raise HTTPException(status_code=500, detail=f"Failed to execute action: {str(e)}")
  1090	
  1091	@app.post("/game/start")
  1092	def start_game():
  1093	    """Start a new game (legacy endpoint)"""
  1094	    try:
  1095	        return {"status": "success", "message": "Game started"}
  1096	    except Exception as e:
  1097	        logger.error(f"Error starting game: {e}")
  1098	        raise HTTPException(status_code=500, detail="Failed to start game")
  1099	
  1100	@app.post("/game/setup")
  1101	def setup_game(setup_data: Dict[str, Any]):
  1102	    """Setup game with players (legacy endpoint)"""
  1103	    try:
  1104	        players = setup_data.get("players", [])
  1105	        course_name = setup_data.get("course_name", "Wing Point Golf & Country Club")
  1106	        
  1107	        # Use the unified action API internally
  1108	        action_request = ActionRequest(
  1109	            action_type="INITIALIZE_GAME",
  1110	            payload={"players": players, "course_name": course_name}
  1111	        )
  1112	        
  1113	        # This would need to be called in an async context
  1114	        # For now, just return success
  1115	        return {"status": "success", "message": "Game setup completed"}
  1116	    except Exception as e:
  1117	        logger.error(f"Error setting up game: {e}")
  1118	        raise HTTPException(status_code=500, detail="Failed to setup game")
  1119	
  1120	# Unified Action API - Main Game Logic Endpoint
  1121	@app.post("/wgp/{game_id}/action", response_model=ActionResponse)
  1122	async def unified_action(game_id: str, action: ActionRequest):
  1123	    """Unified action endpoint for all Wolf Goat Pig game interactions"""
  1124	    try:
  1125	        action_type = action.action_type
  1126	        payload = action.payload or {}
  1127	        
  1128	        # Route to appropriate handler based on action type
  1129	        if action_type == "INITIALIZE_GAME":
  1130	            return await handle_initialize_game(payload)
  1131	        elif action_type == "PLAY_SHOT":
  1132	            return await handle_play_shot(payload)
  1133	        elif action_type == "REQUEST_PARTNERSHIP":
  1134	            return await handle_request_partnership(payload)
  1135	        elif action_type == "RESPOND_PARTNERSHIP":
  1136	            return await handle_respond_partnership(payload)
  1137	        elif action_type == "DECLARE_SOLO":
  1138	            return await handle_declare_solo()
  1139	        elif action_type == "OFFER_DOUBLE":
  1140	            return await handle_offer_double(payload)
  1141	        elif action_type == "ACCEPT_DOUBLE":
  1142	            return await handle_accept_double(payload)
  1143	        elif action_type == "CONCEDE_PUTT":
  1144	            return await handle_concede_putt(payload)
  1145	        elif action_type == "ADVANCE_HOLE":
  1146	            return await handle_advance_hole()
  1147	        elif action_type == "OFFER_BIG_DICK":
  1148	            return await handle_offer_big_dick(payload)
  1149	        elif action_type == "ACCEPT_BIG_DICK":
  1150	            return await handle_accept_big_dick(payload)
  1151	        elif action_type == "AARDVARK_JOIN_REQUEST":
  1152	            return await handle_aardvark_join_request(payload)
  1153	        elif action_type == "AARDVARK_TOSS":
  1154	            return await handle_aardvark_toss(payload)
  1155	        elif action_type == "AARDVARK_GO_SOLO":
  1156	            return await handle_aardvark_go_solo(payload)
  1157	        elif action_type == "PING_PONG_AARDVARK":
  1158	            return await handle_ping_pong_aardvark(payload)
  1159	        elif action_type == "INVOKE_JOES_SPECIAL":
  1160	            return await handle_joes_special(payload)
  1161	        elif action_type == "GET_POST_HOLE_ANALYSIS":
  1162	            return await handle_get_post_hole_analysis(payload)
  1163	        elif action_type == "ENTER_HOLE_SCORES":
  1164	            return await handle_enter_hole_scores(payload)
  1165	        elif action_type == "GET_ADVANCED_ANALYTICS":
  1166	            return await handle_get_advanced_analytics(payload)
  1167	        else:
  1168	            raise HTTPException(status_code=400, detail=f"Unknown action type: {action_type}")
  1169	            
  1170	    except HTTPException:
  1171	        # Re-raise HTTPExceptions to preserve their status codes
  1172	        raise
  1173	    except Exception as e:
  1174	        logger.error(f"Error in unified action: {e}")
  1175	        logger.error(traceback.format_exc())
  1176	        raise HTTPException(status_code=500, detail=f"Action failed: {str(e)}")
  1177	
  1178	# Action Handlers
  1179	async def handle_initialize_game(payload: Dict[str, Any]) -> ActionResponse:
  1180	    """Handle game initialization with robust error handling and fallbacks"""
  1181	    try:
  1182	        players = payload.get("players", [])
  1183	        course_name = payload.get("course_name", "Wing Point Golf & Country Club")
  1184	        
  1185	        # Validate player count (support 4, 5, 6 players)
  1186	        if len(players) not in [4, 5, 6]:
  1187	            raise HTTPException(status_code=400, detail="4, 5, or 6 players required.")
  1188	        
  1189	        # Ensure all players have required fields with smart defaults
  1190	        for i, player in enumerate(players):
  1191	            if "name" not in player:
  1192	                player["name"] = f"Player {i+1}"
  1193	                logger.warning(f"Player {i+1} missing name, using default")
  1194	            
  1195	            if "handicap" not in player:
  1196	                player["handicap"] = 18.0  # Default handicap
  1197	                logger.warning(f"Player {player['name']} missing handicap, using default 18.0")
  1198	            
  1199	            # Ensure handicap is numeric
  1200	            try:
  1201	                player["handicap"] = float(player["handicap"])
  1202	            except (ValueError, TypeError):
  1203	                logger.warning(f"Invalid handicap for {player['name']}, using 18.0")
  1204	                player["handicap"] = 18.0
  1205	            
  1206	            # Add missing fields if not present
  1207	            if "id" not in player:
  1208	                player["id"] = f"p{i+1}"
  1209	            if "strength" not in player:
  1210	                # Default strength based on handicap (lower handicap = higher strength)
  1211	                player["strength"] = max(1, 10 - int(player["handicap"]))
  1212	        
  1213	        # Verify course exists, use fallback if needed
  1214	        try:
  1215	            available_courses = game_state.get_courses()
  1216	            if course_name not in available_courses:
  1217	                logger.warning(f"Requested course '{course_name}' not available, using fallback")
  1218	                # Use first available course or fallback
  1219	                if available_courses:
  1220	                    course_name = list(available_courses.keys())[0]
  1221	                    logger.info(f"Using available course: {course_name}")
  1222	                else:
  1223	                    logger.error("No courses available, using emergency fallback")
  1224	                    course_name = "Emergency Course"
  1225	                    # Ensure fallback courses are available
  1226	                    fallback_courses = get_fallback_courses()
  1227	                    game_state.course_manager.course_data = fallback_courses
  1228	        except Exception as course_error:
  1229	            logger.error(f"Course verification failed: {course_error}")
  1230	            course_name = "Emergency Course"
  1231	            fallback_courses = get_fallback_courses()
  1232	            game_state.course_manager.course_data = fallback_courses
  1233	        
  1234	        # Initialize game state with players (with error handling)
  1235	        try:
  1236	            game_state.setup_players(players, course_name)
  1237	            logger.info(f"Game state initialized successfully with {len(players)} players")
  1238	        except Exception as game_state_error:
  1239	            logger.error(f"Game state setup failed: {game_state_error}")
  1240	            # Try with minimal setup
  1241	            try:
  1242	                game_state.reset()
  1243	                logger.warning("Fell back to basic game state reset")
  1244	            except Exception as reset_error:
  1245	                logger.error(f"Even game state reset failed: {reset_error}")
  1246	                # Continue with current state
  1247	        
  1248	        # Initialize WGP simulation with robust error handling
  1249	        try:
  1250	            # Create WGPPlayer objects
  1251	            wgp_players = []
  1252	            for player in players:
  1253	                try:
  1254	                    wgp_players.append(WGPPlayer(
  1255	                        id=player["id"],
  1256	                        name=player["name"],
  1257	                        handicap=player["handicap"]
  1258	                    ))
  1259	                except Exception as player_creation_error:
  1260	                    logger.error(f"Failed to create WGPPlayer for {player['name']}: {player_creation_error}")
  1261	                    # Create with minimal data
  1262	                    wgp_players.append(WGPPlayer(
  1263	                        id=player.get("id", f"p{len(wgp_players)+1}"),
  1264	                        name=player.get("name", f"Player {len(wgp_players)+1}"),
  1265	                        handicap=18.0
  1266	                    ))
  1267	            
  1268	            if len(wgp_players) != len(players):
  1269	                logger.warning(f"Only created {len(wgp_players)} WGP players from {len(players)} input players")
  1270	            
  1271	            # Initialize the simulation with these players and course manager
  1272	            try:
  1273	                wgp_simulation.__init__(player_count=len(wgp_players), players=wgp_players, course_manager=game_state.course_manager)
  1274	                logger.info("WGP simulation initialized successfully with course data")
  1275	            except Exception as sim_init_error:
  1276	                logger.error(f"WGP simulation initialization failed: {sim_init_error}")
  1277	                # Try without course manager
  1278	                try:
  1279	                    wgp_simulation.__init__(player_count=len(wgp_players), players=wgp_players)
  1280	                    logger.warning("Initialized without course manager")
  1281	                except:
  1282	                    # Try with basic initialization
  1283	                    wgp_simulation.__init__(player_count=len(wgp_players))
  1284	                    logger.warning("Fell back to basic simulation initialization")
  1285	            
  1286	            # Set computer players (all except first) with error handling
  1287	            try:
  1288	                computer_player_ids = [p["id"] for p in players[1:]]
  1289	                wgp_simulation.set_computer_players(computer_player_ids)
  1290	                logger.info(f"Set {len(computer_player_ids)} computer players")
  1291	            except Exception as computer_setup_error:
  1292	                logger.error(f"Failed to set computer players: {computer_setup_error}")
  1293	                # Continue without computer player setup
  1294	            
  1295	            # Initialize the first hole with error handling
  1296	            try:
  1297	                wgp_simulation._initialize_hole(1)
  1298	                logger.info("First hole initialized")
  1299	            except Exception as hole_init_error:
  1300	                logger.error(f"Failed to initialize first hole: {hole_init_error}")
  1301	                # Continue - hole might be initialized differently
  1302	            
  1303	            # Enable shot progression and timeline tracking
  1304	            try:
  1305	                wgp_simulation.enable_shot_progression()
  1306	                logger.info("Shot progression enabled")
  1307	            except Exception as progression_error:
  1308	                logger.warning(f"Failed to enable shot progression: {progression_error}")
  1309	                # Non-critical, continue
  1310	            
  1311	            # Add initial timeline event
  1312	            try:
  1313	                if hasattr(wgp_simulation, 'hole_progression') and wgp_simulation.hole_progression:
  1314	                    wgp_simulation.hole_progression.add_timeline_event(
  1315	                        event_type="game_start",
  1316	                        description=f"Game started with {len(players)} players on {course_name}",
  1317	                        details={"players": players, "course": course_name}
  1318	                    )
  1319	                    logger.info("Initial timeline event added")
  1320	            except Exception as timeline_error:
  1321	                logger.warning(f"Failed to add timeline event: {timeline_error}")
  1322	                # Non-critical, continue
  1323	            
  1324	        except Exception as simulation_error:
  1325	            logger.error(f"Critical simulation setup error: {simulation_error}")
  1326	            # Create minimal fallback simulation
  1327	            try:
  1328	                wgp_simulation.__init__(player_count=len(players))
  1329	                logger.warning("Created minimal fallback simulation")
  1330	            except Exception as fallback_error:
  1331	                logger.error(f"Even fallback simulation failed: {fallback_error}")
  1332	                # This is critical - raise error
  1333	                raise HTTPException(status_code=500, detail="Failed to initialize simulation engine")
  1334	        
  1335	        # Get initial game state (with error handling)
  1336	        try:
  1337	            current_state = wgp_simulation.get_game_state()
  1338	            if not current_state:
  1339	                logger.warning("Empty game state returned, creating minimal state")
  1340	                current_state = {
  1341	                    "active": True,
  1342	                    "current_hole": 1,
  1343	                    "players": players,
  1344	                    "course": course_name
  1345	                }
  1346	        except Exception as state_error:
  1347	            logger.error(f"Failed to get game state: {state_error}")
  1348	            # Create minimal state
  1349	            current_state = {
  1350	                "active": True,
  1351	                "current_hole": 1,
  1352	                "players": players,
  1353	                "course": course_name,
  1354	                "error": "Partial initialization - some features may be limited"
  1355	            }
  1356	        
  1357	        success_message = f"Game initialized with {len(players)} players on {course_name}"
  1358	        if any("error" in str(current_state).lower() for _ in [1]):  # Check if there were issues
  1359	            success_message += " (some advanced features may be limited)"
  1360	        
  1361	        return ActionResponse(
  1362	            game_state=current_state,
  1363	            log_message=success_message,
  1364	            available_actions=[
  1365	                {"action_type": "PLAY_SHOT", "prompt": "Start first hole", "player_turn": players[0]["name"]}
  1366	            ],
  1367	            timeline_event={
  1368	                "id": "init_1",
  1369	                "timestamp": datetime.now().isoformat(),
  1370	                "type": "game_start",
  1371	                "description": f"Game started with {len(players)} players",
  1372	                "details": {"players": players, "course": course_name}
  1373	            }
  1374	        )
  1375	        
  1376	    except HTTPException:
  1377	        # Re-raise HTTP exceptions (validation errors)
  1378	        raise
  1379	    except Exception as e:
  1380	        logger.error(f"Critical error initializing game: {e}")
  1381	        logger.error(traceback.format_exc())
  1382	        
  1383	        # Create minimal emergency response
  1384	        emergency_state = {
  1385	            "active": False,
  1386	            "error": "Game initialization failed",
  1387	            "fallback": True,
  1388	            "message": "Please try again or contact support"
  1389	        }
  1390	        
  1391	        return ActionResponse(
  1392	            game_state=emergency_state,
  1393	            log_message=f"Game initialization failed: {str(e)}",
  1394	            available_actions=[
  1395	                {"action_type": "RETRY_INITIALIZATION", "prompt": "Try Again"}
  1396	            ],
  1397	            timeline_event={
  1398	                "id": "init_error",
  1399	                "timestamp": datetime.now().isoformat(),
  1400	                "type": "initialization_error",
  1401	                "description": "Game initialization failed",
  1402	                "details": {"error": str(e)}
  1403	            }
  1404	        )
  1405	
  1406	async def handle_play_shot(payload: Dict[str, Any] = None) -> ActionResponse:
  1407	    """Handle playing a shot"""
  1408	    try:
  1409	        # Get current game state
  1410	        current_state = wgp_simulation.get_game_state()
  1411	        
  1412	        # Determine next player to hit
  1413	        next_player = wgp_simulation._get_next_shot_player()
  1414	        if not next_player:
  1415	            return ActionResponse(
  1416	                game_state=current_state,
  1417	                log_message="No players available to hit",
  1418	                available_actions=[],
  1419	                timeline_event={
  1420	                    "id": f"shot_{datetime.now().timestamp()}",
  1421	                    "timestamp": datetime.now().isoformat(),
  1422	                    "type": "shot",
  1423	                    "description": "No players available to hit",
  1424	                    "player_name": None
  1425	                }
  1426	            )
  1427	        
  1428	        # Simulate the shot
  1429	        shot_response = wgp_simulation.simulate_shot(next_player)
  1430	        shot_result = shot_response.get("shot_result", {})
  1431	        
  1432	        # Update game state  
  1433	        updated_state = wgp_simulation.get_game_state()
  1434	        hole_state = wgp_simulation.hole_states[wgp_simulation.current_hole]
  1435	        
  1436	        # Check if this was a tee shot and update invitation windows
  1437	        is_tee_shot = next_player not in hole_state.ball_positions or hole_state.ball_positions[next_player].shot_count == 1
  1438	        if is_tee_shot:
  1439	            # Create a WGPShotResult object from the shot_result dictionary
  1440	            from app.wolf_goat_pig_simulation import WGPShotResult
  1441	            shot_obj = WGPShotResult(
  1442	                player_id=shot_result.get("player_id", next_player),
  1443	                shot_number=shot_result.get("shot_number", 1),
  1444	                lie_type=shot_result.get("lie_type", "fairway"),
  1445	                distance_to_pin=shot_result.get("distance_to_pin", 0.0),
  1446	                shot_quality=shot_result.get("shot_quality", "average"),
  1447	                made_shot=shot_result.get("made_shot", False),
  1448	                penalty_strokes=shot_result.get("penalty_strokes", 0)
  1449	            )
  1450	            hole_state.process_tee_shot(next_player, shot_obj)
  1451	        
  1452	        # Determine next available actions based on shot progression and partnership timing
  1453	        available_actions = []
  1454	        
  1455	        if shot_response.get("hole_complete"):
  1456	            # Hole is complete - offer scoring options
  1457	            available_actions.append({"action_type": "ENTER_HOLE_SCORES", "prompt": "Enter hole scores"})
  1458	        elif hole_state.teams.type == "pending":
  1459	            # Teams not formed yet - check if we should offer partnership decisions
  1460	            captain_id = hole_state.teams.captain
  1461	            captain_name = wgp_simulation._get_player_name(captain_id)
  1462	            
  1463	            # Real Wolf-Goat-Pig timing: Partnership decision comes AFTER shots are hit
  1464	            # Count how many tee shots have been completed
  1465	            tee_shots_completed = sum(1 for player_id, ball in hole_state.ball_positions.items() 
  1466	                                    if ball and ball.shot_count >= 1)
  1467	            
  1468	            # Partnership decision point: After captain and at least one other player have hit
  1469	            if tee_shots_completed >= 2:
  1470	                # Get available partners based on timing rules  
  1471	                available_partners = []
  1472	                for player in wgp_simulation.players:
  1473	                    if player.id != captain_id and hole_state.can_request_partnership(captain_id, player.id):
  1474	                        # Only show players who have already hit their tee shot
  1475	                        if player.id in hole_state.ball_positions and hole_state.ball_positions[player.id]:
  1476	                            partner_ball = hole_state.ball_positions[player.id]
  1477	                            available_partners.append({
  1478	                                "id": player.id,
  1479	                                "name": player.name,
  1480	                                "handicap": player.handicap,
  1481	                                "tee_shot_distance": partner_ball.distance_to_pin,
  1482	                                "tee_shot_quality": getattr(partner_ball, 'last_shot_quality', 'unknown')
  1483	                            })
  1484	                
  1485	                if available_partners:
  1486	                    # Add partnership actions for captain with context about their shots
  1487	                    for partner in available_partners:
  1488	                        tee_context = f"{partner['name']} hit to {partner['tee_shot_distance']:.0f} yards"
  1489	                        available_actions.append({
  1490	                            "action_type": "REQUEST_PARTNERSHIP",
  1491	                            "prompt": f"Partner with {partner['name']}?",
  1492	                            "payload": {"target_player_name": partner['name']},
  1493	                            "player_turn": captain_name,
  1494	                            "context": f"ðŸŒï¸ {tee_context}. Form partnership with {partner['name']} (handicap {partner['handicap']})?"
  1495	                        })
  1496	                    
  1497	                    # Add solo option with context
  1498	                available_actions.append({
  1499	                    "action_type": "DECLARE_SOLO", 
  1500	                    "prompt": "Go solo (1v3)",
  1501	                    "player_turn": captain_name,
  1502	                    "context": "Play alone against all three opponents. High risk, high reward!"
  1503	                })
  1504	            else:
  1505	                # Need more tee shots or partnership deadline passed
  1506	                if tee_shots_completed < 2:
  1507	                    remaining_players = [p.name for p in wgp_simulation.players 
  1508	                                       if p.id not in hole_state.ball_positions or not hole_state.ball_positions[p.id]]
  1509	                    available_actions.append({
  1510	                        "action_type": "TAKE_SHOT",
  1511	                        "prompt": f"Continue tee shots",
  1512	                        "context": f"Need more tee shots for partnership decisions. Waiting on: {', '.join(remaining_players) if remaining_players else 'all set'}"
  1513	                    })
  1514	                else:
  1515	                    # Partnership deadline has passed - captain must go solo
  1516	                    available_actions.append({
  1517	                        "action_type": "DECLARE_SOLO", 
  1518	                        "prompt": "Go solo (deadline passed)",
  1519	                        "player_turn": captain_name,
  1520	                        "context": "Partnership deadline has passed. Must play solo."
  1521	                    })
  1522	        else:
  1523	            # Continue with shot progression
  1524	            next_shot_player = wgp_simulation._get_next_shot_player()
  1525	            if next_shot_player:
  1526	                next_shot_player_name = wgp_simulation._get_player_name(next_shot_player)
  1527	                
  1528	                # Determine shot type for better UX
  1529	                current_ball = hole_state.get_player_ball_position(next_shot_player)
  1530	                shot_type = "tee shot" if not current_ball else f"shot #{current_ball.shot_count + 1}"
  1531	                
  1532	                available_actions.append({
  1533	                    "action_type": "PLAY_SHOT", 
  1534	                    "prompt": f"{next_shot_player_name} hits {shot_type}", 
  1535	                    "player_turn": next_shot_player_name,
  1536	                    "context": f"Continue hole progression with {next_shot_player_name}'s {shot_type}"
  1537	                })
  1538	            elif not hole_state.hole_complete:
  1539	                # All players have played but hole not complete - might need scoring
  1540	                available_actions.append({
  1541	                    "action_type": "ENTER_HOLE_SCORES", 
  1542	                    "prompt": "Enter final scores for hole"
  1543	                })
  1544	            
  1545	            # Check for betting opportunities during hole play (doubles/flushes)
  1546	            if not hole_state.wagering_closed and hole_state.teams.type in ["partners", "solo"]:
  1547	                # Get the recent shot context for betting decisions
  1548	                recent_shots = []
  1549	                for player_id, ball in hole_state.ball_positions.items():
  1550	                    if ball and ball.shot_count > 0:
  1551	                        player_name = wgp_simulation._get_player_name(player_id)
  1552	                        recent_shots.append(f"{player_name}: {ball.distance_to_pin:.0f}yd ({ball.shot_count} shots)")
  1553	                
  1554	                # Check if there's a compelling reason to double (great shot, bad position, etc.)
  1555	                should_offer_betting = False
  1556	                betting_context = []
  1557	                
  1558	                # Look for recent excellent or terrible shots that create betting opportunities
  1559	                if shot_response and "shot_result" in shot_response:
  1560	                    last_shot = shot_response["shot_result"]
  1561	                    player_name = wgp_simulation._get_player_name(last_shot["player_id"])
  1562	                    
  1563	                    if last_shot["shot_quality"] == "excellent" and last_shot["distance_to_pin"] < 50:
  1564	                        should_offer_betting = True
  1565	                        betting_context.append(f"ðŸŽ¯ {player_name} hit an excellent shot to {last_shot['distance_to_pin']:.0f} yards!")
  1566	                    elif last_shot["shot_quality"] == "terrible" and last_shot["shot_number"] <= 3:
  1567	                        should_offer_betting = True  
  1568	                        betting_context.append(f"ðŸ˜¬ {player_name} struggling after terrible shot")
  1569	                
  1570	                # Only offer doubles if there are strategic opportunities and not already doubled
  1571	                if should_offer_betting and not hole_state.betting.doubled:
  1572	                    # Find players who can offer doubles (not past line of scrimmage)
  1573	                    for player in wgp_simulation.players:
  1574	                        if hole_state.can_offer_double(player.id):
  1575	                            # Create compelling betting context based on recent action
  1576	                            current_positions = ", ".join(recent_shots[:3])  # Show top 3 positions
  1577	                            full_context = " ".join(betting_context)
  1578	                            
  1579	                            context = (f"ðŸŽ² Double from {hole_state.betting.current_wager} to {hole_state.betting.current_wager * 2} quarters? "
  1580	                                     f"{full_context} Current positions: {current_positions}")
  1581	                            
  1582	                            available_actions.append({
  1583	                                "action_type": "OFFER_DOUBLE",
  1584	                                "prompt": f"{player.name}: Offer double?",
  1585	                                "payload": {"player_id": player.id},
  1586	                                "player_turn": player.name,
  1587	                                "context": context
  1588	                            })
  1589	                
  1590	                # Also offer flush opportunities if wager has been doubled
  1591	                elif hole_state.betting.doubled and not hole_state.betting.redoubled and should_offer_betting:
  1592	                    # Flush = double it back
  1593	                    for player in wgp_simulation.players:
  1594	                        if hole_state.can_offer_double(player.id):
  1595	                            current_positions = ", ".join(recent_shots[:3])
  1596	                            full_context = " ".join(betting_context)
  1597	                            
  1598	                            context = (f"ðŸ’¥ Flush! Double back from {hole_state.betting.current_wager} to {hole_state.betting.current_wager * 2} quarters? "
  1599	                                     f"{full_context} Positions: {current_positions}")
  1600	                            
  1601	                            available_actions.append({
  1602	                                "action_type": "OFFER_FLUSH", 
  1603	                                "prompt": f"{player.name}: Offer flush?",
  1604	                                "payload": {"player_id": player.id},
  1605	                                "player_turn": player.name,
  1606	                                "context": context
  1607	                            })
  1608	        
  1609	        # Create timeline event from shot response
  1610	        player_name = wgp_simulation._get_player_name(next_player)
  1611	        shot_description = f"{player_name} hits a {shot_result.get('shot_quality', 'average')} shot"
  1612	        if shot_result.get('made_shot'):
  1613	            shot_description += " and holes out!"
  1614	        else:
  1615	            shot_description += f" - {shot_result.get('distance_to_pin', 0):.0f} yards to pin"
  1616	        
  1617	        timeline_event = {
  1618	            "id": f"shot_{datetime.now().timestamp()}",
  1619	            "timestamp": datetime.now().isoformat(),
  1620	            "type": "shot",
  1621	            "description": shot_description,
  1622	            "player_name": player_name,
  1623	            "details": shot_result
  1624	        }
  1625	        
  1626	        return ActionResponse(
  1627	            game_state=updated_state,
  1628	            log_message=shot_description,
  1629	            available_actions=available_actions,
  1630	            timeline_event=timeline_event
  1631	        )
  1632	    except Exception as e:
  1633	        logger.error(f"Error playing shot: {e}")
  1634	        raise HTTPException(status_code=500, detail=f"Failed to play shot: {str(e)}")
  1635	
  1636	async def handle_request_partnership(payload: Dict[str, Any]) -> ActionResponse:
  1637	    """Handle partnership request"""
  1638	    try:
  1639	        target_player = payload.get("target_player_name")
  1640	        if not target_player:
  1641	            raise HTTPException(status_code=400, detail="target_player_name is required")
  1642	        
  1643	        # Get current game state
  1644	        current_state = wgp_simulation.get_game_state()
  1645	        
  1646	        # Get the actual captain ID from the current hole state
  1647	        hole_state = wgp_simulation.hole_states[wgp_simulation.current_hole]
  1648	        captain_id = hole_state.teams.captain
  1649	        
  1650	        # Convert player name to player ID
  1651	        partner_id = None
  1652	        for player in wgp_simulation.players:
  1653	            if player.name == target_player:
  1654	                partner_id = player.id
  1655	                break
  1656	        
  1657	        if not partner_id:
  1658	            raise HTTPException(status_code=400, detail=f"Player '{target_player}' not found")
  1659	        
  1660	        # Request the partnership
  1661	        result = wgp_simulation.request_partner(captain_id, partner_id)
  1662	        
  1663	        # Get updated game state
  1664	        updated_state = wgp_simulation.get_game_state()
  1665	        
  1666	        # Determine next available actions
  1667	        available_actions = []
  1668	        
  1669	        # If partnership was requested, the target player needs to respond
  1670	        if result.get("partnership_requested"):
  1671	            captain_name = wgp_simulation._get_player_name(captain_id)
  1672	            partner_name = target_player
  1673	            
  1674	            available_actions.append({
  1675	                "action_type": "RESPOND_PARTNERSHIP",
  1676	                "prompt": f"Accept partnership with {captain_name}",
  1677	                "payload": {"accepted": True},
  1678	                "player_turn": partner_name,
  1679	                "context": f"{captain_name} has requested you as a partner"
  1680	            })
  1681	            
  1682	            available_actions.append({
  1683	                "action_type": "RESPOND_PARTNERSHIP", 
  1684	                "prompt": f"Decline partnership with {captain_name}",
  1685	                "payload": {"accepted": False},
  1686	                "player_turn": partner_name,
  1687	                "context": f"{captain_name} has requested you as a partner"
  1688	            })
  1689	        
  1690	        return ActionResponse(
  1691	            game_state=updated_state,
  1692	            log_message=result.get("message", f"Partnership requested with {target_player}"),
  1693	            available_actions=available_actions,
  1694	            timeline_event={
  1695	                "id": f"partnership_request_{datetime.now().timestamp()}",
  1696	                "timestamp": datetime.now().isoformat(),
  1697	                "type": "partnership_request",
  1698	                "description": f"Partnership requested with {target_player}",
  1699	                "player_name": wgp_simulation._get_player_name(captain_id),
  1700	                "details": {
  1701	                    "captain": wgp_simulation._get_player_name(captain_id),
  1702	                    "requested_partner": target_player,
  1703	                    "status": "pending_response"
  1704	                }
  1705	            }
  1706	        )
  1707	    except Exception as e:
  1708	        logger.error(f"Error requesting partnership: {e}")
  1709	        raise HTTPException(status_code=500, detail=f"Failed to request partnership: {str(e)}")
  1710	
  1711	async def handle_respond_partnership(payload: Dict[str, Any]) -> ActionResponse:
  1712	    """Handle partnership response"""
  1713	    try:
  1714	        accepted = payload.get("accepted", False)
  1715	        
  1716	        # Get current game state
  1717	        current_state = wgp_simulation.get_game_state()
  1718	        
  1719	        # Get the partner ID from the pending request
  1720	        hole_state = wgp_simulation.hole_states[wgp_simulation.current_hole]
  1721	        partner_id = hole_state.teams.pending_request.get("requested") if hole_state.teams.pending_request else None
  1722	        
  1723	        if not partner_id:
  1724	            raise HTTPException(status_code=400, detail="No pending partnership request")
  1725	        
  1726	        # Respond to partnership
  1727	        if accepted:
  1728	            result = wgp_simulation.respond_to_partnership(partner_id, True)
  1729	            message = "Partnership accepted! Teams are formed."
  1730	        else:
  1731	            result = wgp_simulation.respond_to_partnership(partner_id, False)
  1732	            message = "Partnership declined. Captain goes solo."
  1733	        
  1734	        # Add timeline event to hole progression if available
  1735	        if hasattr(wgp_simulation, 'hole_progression') and wgp_simulation.hole_progression:
  1736	            wgp_simulation.hole_progression.add_timeline_event(
  1737	                event_type="partnership_response",
  1738	                description=f"Partnership {'accepted' if accepted else 'declined'}",
  1739	                player_name="Partner",
  1740	                details={"accepted": accepted}
  1741	            )
  1742	        
  1743	        # Update game state
  1744	        updated_state = wgp_simulation.get_game_state()
  1745	        
  1746	        return ActionResponse(
  1747	            game_state=updated_state,
  1748	            log_message=message,
  1749	            available_actions=[
  1750	                {"action_type": "PLAY_SHOT", "prompt": "Continue with hole"}
  1751	            ],
  1752	            timeline_event={
  1753	                "id": f"partnership_response_{datetime.now().timestamp()}",
  1754	                "timestamp": datetime.now().isoformat(),
  1755	                "type": "partnership_response",
  1756	                "description": f"Partnership {'accepted' if accepted else 'declined'}",
  1757	                "player_name": "Partner",
  1758	                "details": {"accepted": accepted}
  1759	            }
  1760	        )
  1761	    except Exception as e:
  1762	        logger.error(f"Error responding to partnership: {e}")
  1763	        raise HTTPException(status_code=500, detail=f"Failed to respond to partnership: {str(e)}")
  1764	
  1765	async def handle_declare_solo() -> ActionResponse:
  1766	    """Handle captain going solo"""
  1767	    try:
  1768	        # Get current game state
  1769	        current_state = wgp_simulation.get_game_state()
  1770	        
  1771	        # Get the actual captain ID from the current hole state
  1772	        hole_state = wgp_simulation.hole_states.get(wgp_simulation.current_hole)
  1773	        if not hole_state or not hole_state.teams.captain:
  1774	            raise HTTPException(status_code=400, detail="No captain found for current hole")
  1775	        
  1776	        captain_id = hole_state.teams.captain
  1777	        
  1778	        # Captain goes solo
  1779	        result = wgp_simulation.captain_go_solo(captain_id)
  1780	        
  1781	        # Add timeline event to hole progression if available
  1782	        if hasattr(wgp_simulation, 'hole_progression') and wgp_simulation.hole_progression:
  1783	            wgp_simulation.hole_progression.add_timeline_event(
  1784	                event_type="partnership_decision",
  1785	                description="Captain goes solo - 1 vs 3",
  1786	                player_name="Captain",
  1787	                details={"solo": True}
  1788	            )
  1789	        
  1790	        # Update game state
  1791	        updated_state = wgp_simulation.get_game_state()
  1792	        
  1793	        return ActionResponse(
  1794	            game_state=updated_state,
  1795	            log_message="Captain declares solo! It's 1 vs 3.",
  1796	            available_actions=[
  1797	                {"action_type": "PLAY_SHOT", "prompt": "Continue with hole"}
  1798	            ],
  1799	            timeline_event={
  1800	                "id": f"solo_declaration_{datetime.now().timestamp()}",
  1801	                "timestamp": datetime.now().isoformat(),
  1802	                "type": "partnership_decision",
  1803	                "description": "Captain goes solo - 1 vs 3",
  1804	                "player_name": "Captain",
  1805	                "details": {"solo": True}
  1806	            }
  1807	        )
  1808	    except Exception as e:
  1809	        logger.error(f"Error declaring solo: {e}")
  1810	        raise HTTPException(status_code=500, detail=f"Failed to declare solo: {str(e)}")
  1811	
  1812	async def handle_offer_double(payload: Dict[str, Any]) -> ActionResponse:
  1813	    """Handle double offer"""
  1814	    try:
  1815	        player_id = payload.get("player_id")
  1816	        if not player_id:
  1817	            raise ValueError("Player ID required for double offer")
  1818	        
  1819	        # Get current game state
  1820	        current_state = wgp_simulation.get_game_state()
  1821	        
  1822	        # Offer double
  1823	        result = wgp_simulation.offer_double(player_id)
  1824	        
  1825	        player_name = wgp_simulation._get_player_name(player_id)
  1826	        
  1827	        # Add timeline event to hole progression if available
  1828	        if hasattr(wgp_simulation, 'hole_progression') and wgp_simulation.hole_progression:
  1829	            wgp_simulation.hole_progression.add_timeline_event(
  1830	                event_type="double_offer",
  1831	                description=f"{player_name} offered to double the wager",
  1832	                player_name=player_name,
  1833	                details={"double_offered": True, "player_id": player_id}
  1834	            )
  1835	        
  1836	        # Update game state
  1837	        updated_state = wgp_simulation.get_game_state()
  1838	        
  1839	        return ActionResponse(
  1840	            game_state=updated_state,
  1841	            log_message="Double offered! Wager increases.",
  1842	            available_actions=[
  1843	                {"action_type": "ACCEPT_DOUBLE", "prompt": "Accept/Decline double"}
  1844	            ],
  1845	            timeline_event={
  1846	                "id": f"double_offer_{datetime.now().timestamp()}",
  1847	                "timestamp": datetime.now().isoformat(),
  1848	                "type": "double_offer",
  1849	                "description": f"{player_name} offered to double the wager",
  1850	                "player_name": player_name,
  1851	                "details": {"double_offered": True, "player_id": player_id}
  1852	            }
  1853	        )
  1854	    except Exception as e:
  1855	        logger.error(f"Error offering double: {e}")
  1856	        raise HTTPException(status_code=500, detail=f"Failed to offer double: {str(e)}")
  1857	
  1858	async def handle_accept_double(payload: Dict[str, Any]) -> ActionResponse:
  1859	    """Handle double acceptance/decline"""
  1860	    try:
  1861	        accepted = payload.get("accepted", False)
  1862	        
  1863	        # Get current game state
  1864	        current_state = wgp_simulation.get_game_state()
  1865	        
  1866	        # Respond to double
  1867	        if accepted:
  1868	            result = wgp_simulation.respond_to_double("responding_team", True)
  1869	            message = "Double accepted! Wager doubled."
  1870	        else:
  1871	            result = wgp_simulation.respond_to_double("responding_team", False)
  1872	            message = "Double declined. Original wager maintained."
  1873	        
  1874	        # Add timeline event to hole progression if available
  1875	        if hasattr(wgp_simulation, 'hole_progression') and wgp_simulation.hole_progression:
  1876	            wgp_simulation.hole_progression.add_timeline_event(
  1877	                event_type="double_response",
  1878	                description=f"Double {'accepted' if accepted else 'declined'}",
  1879	                player_name="Responding Team",
  1880	                details={"accepted": accepted}
  1881	            )
  1882	        
  1883	        # Update game state
  1884	        updated_state = wgp_simulation.get_game_state()
  1885	        
  1886	        return ActionResponse(
  1887	            game_state=updated_state,
  1888	            log_message=message,
  1889	            available_actions=[
  1890	                {"action_type": "PLAY_SHOT", "prompt": "Continue with hole"}
  1891	            ],
  1892	            timeline_event={
  1893	                "id": f"double_response_{datetime.now().timestamp()}",
  1894	                "timestamp": datetime.now().isoformat(),
  1895	                "type": "double_response",
  1896	                "description": f"Double {'accepted' if accepted else 'declined'}",
  1897	                "player_name": "Responding Team",
  1898	                "details": {"accepted": accepted}
  1899	            }
  1900	        )
  1901	    except Exception as e:
  1902	        logger.error(f"Error responding to double: {e}")
  1903	        raise HTTPException(status_code=500, detail=f"Failed to respond to double: {str(e)}")
  1904	
  1905	async def handle_concede_putt(payload: Dict[str, Any]) -> ActionResponse:
  1906	    """Handle putt concession"""
  1907	    try:
  1908	        conceding_player = payload.get("conceding_player")
  1909	        conceded_player = payload.get("conceded_player")
  1910	        
  1911	        if not conceding_player or not conceded_player:
  1912	            raise HTTPException(status_code=400, detail="conceding_player and conceded_player are required")
  1913	        
  1914	        # Get current game state
  1915	        current_state = wgp_simulation.get_game_state()
  1916	        
  1917	        # Update game state to reflect concession
  1918	        # This would typically update the hole state to mark the putt as conceded
  1919	        
  1920	        return ActionResponse(
  1921	            game_state=current_state,
  1922	            log_message=f"{conceding_player} concedes putt to {conceded_player}",
  1923	            available_actions=[
  1924	                {"action_type": "PLAY_SHOT", "prompt": "Continue with hole"}
  1925	            ],
  1926	            timeline_event={
  1927	                "id": f"concession_{datetime.now().timestamp()}",
  1928	                "timestamp": datetime.now().isoformat(),
  1929	                "type": "concession",
  1930	                "description": f"Putt conceded to {conceded_player}",
  1931	                "player_name": conceding_player,
  1932	                "details": {"conceded_to": conceded_player}
  1933	            }
  1934	        )
  1935	    except Exception as e:
  1936	        logger.error(f"Error conceding putt: {e}")
  1937	        raise HTTPException(status_code=500, detail=f"Failed to concede putt: {str(e)}")
  1938	
  1939	async def handle_advance_hole() -> ActionResponse:
  1940	    """Handle advancing to the next hole"""
  1941	    try:
  1942	        # Advance to next hole
  1943	        result = wgp_simulation.advance_to_next_hole()
  1944	        
  1945	        # Get updated game state
  1946	        current_state = wgp_simulation.get_game_state()
  1947	        
  1948	        # Add timeline event for hole advancement
  1949	        if hasattr(wgp_simulation, 'hole_progression') and wgp_simulation.hole_progression:
  1950	            wgp_simulation.hole_progression.add_timeline_event(
  1951	                event_type="hole_start",
  1952	                description=f"Started hole {wgp_simulation.current_hole}",
  1953	                details={"hole_number": wgp_simulation.current_hole}
  1954	            )
  1955	        
  1956	        # Enable shot progression for the new hole
  1957	        wgp_simulation.enable_shot_progression()
  1958	        
  1959	        # Get the next player to hit
  1960	        next_player = wgp_simulation._get_next_shot_player()
  1961	        next_player_name = wgp_simulation._get_player_name(next_player) if next_player else "Unknown"
  1962	        
  1963	        return ActionResponse(
  1964	            game_state=current_state,
  1965	            log_message=f"Advanced to hole {wgp_simulation.current_hole}",
  1966	            available_actions=[
  1967	                {"action_type": "PLAY_SHOT", "prompt": f"Start hole {wgp_simulation.current_hole}", "player_turn": next_player_name}
  1968	            ],
  1969	            timeline_event={
  1970	                "id": f"hole_start_{wgp_simulation.current_hole}",
  1971	                "timestamp": datetime.now().isoformat(),
  1972	                "type": "hole_start",
  1973	                "description": f"Started hole {wgp_simulation.current_hole}",
  1974	                "details": {"hole_number": wgp_simulation.current_hole}
  1975	            }
  1976	        )
  1977	    except Exception as e:
  1978	        logger.error(f"Error advancing hole: {e}")
  1979	        raise HTTPException(status_code=500, detail=f"Failed to advance hole: {str(e)}")
  1980	
  1981	async def handle_offer_big_dick(payload: Dict[str, Any]) -> ActionResponse:
  1982	    """Handle Big Dick challenge on hole 18"""
  1983	    try:
  1984	        player_id = payload.get("player_id", "default_player")
  1985	        
  1986	        result = wgp_simulation.offer_big_dick(player_id)
  1987	        updated_state = wgp_simulation.get_game_state()
  1988	        
  1989	        return ActionResponse(
  1990	            game_state=updated_state,
  1991	            log_message=result["message"],
  1992	            available_actions=[
  1993	                {"action_type": "ACCEPT_BIG_DICK", "prompt": "Accept/Decline Big Dick challenge"}
  1994	            ],
  1995	            timeline_event={
  1996	                "id": f"big_dick_offer_{datetime.now().timestamp()}",
  1997	                "timestamp": datetime.now().isoformat(),
  1998	                "type": "big_dick_offer",
  1999	                "description": result["message"],
  2000	                "player_name": result["challenger_name"],
  2001	                "details": {"wager_amount": result["wager_amount"]}
  2002	            }
  2003	        )
  2004	    except Exception as e:
  2005	        logger.error(f"Error offering Big Dick: {e}")
  2006	        raise HTTPException(status_code=500, detail=f"Failed to offer Big Dick: {str(e)}")
  2007	
  2008	async def handle_accept_big_dick(payload: Dict[str, Any]) -> ActionResponse:
  2009	    """Handle Big Dick challenge response"""
  2010	    try:
  2011	        accepting_players = payload.get("accepting_players", [])
  2012	        
  2013	        result = wgp_simulation.accept_big_dick(accepting_players)
  2014	        updated_state = wgp_simulation.get_game_state()
  2015	        
  2016	        return ActionResponse(
  2017	            game_state=updated_state,
  2018	            log_message=result["message"],
  2019	            available_actions=[
  2020	                {"action_type": "PLAY_SHOT", "prompt": "Continue with hole"}
  2021	            ],
  2022	            timeline_event={
  2023	                "id": f"big_dick_response_{datetime.now().timestamp()}",
  2024	                "timestamp": datetime.now().isoformat(),
  2025	                "type": "big_dick_response",
  2026	                "description": result["message"],
  2027	                "details": result
  2028	            }
  2029	        )
  2030	    except Exception as e:
  2031	        logger.error(f"Error accepting Big Dick: {e}")
  2032	        raise HTTPException(status_code=500, detail=f"Failed to accept Big Dick: {str(e)}")
  2033	
  2034	async def handle_ping_pong_aardvark(payload: Dict[str, Any]) -> ActionResponse:
  2035	    """Handle Ping Pong Aardvark"""
  2036	    try:
  2037	        team_id = payload.get("team_id", "team1")
  2038	        aardvark_id = payload.get("aardvark_id", "default_aardvark")
  2039	        
  2040	        result = wgp_simulation.ping_pong_aardvark(team_id, aardvark_id)
  2041	        updated_state = wgp_simulation.get_game_state()
  2042	        
  2043	        return ActionResponse(
  2044	            game_state=updated_state,
  2045	            log_message=result["message"],
  2046	            available_actions=[
  2047	                {"action_type": "PLAY_SHOT", "prompt": "Continue with hole"}
  2048	            ],
  2049	            timeline_event={
  2050	                "id": f"ping_pong_{datetime.now().timestamp()}",
  2051	                "timestamp": datetime.now().isoformat(),
  2052	                "type": "ping_pong_aardvark",
  2053	                "description": result["message"],
  2054	                "details": {
  2055	                    "new_wager": result["new_wager"],
  2056	                    "ping_pong_count": result.get("ping_pong_count", 0)
  2057	                }
  2058	            }
  2059	        )
  2060	    except Exception as e:
  2061	        logger.error(f"Error ping ponging Aardvark: {e}")
  2062	        raise HTTPException(status_code=500, detail=f"Failed to ping pong Aardvark: {str(e)}")
  2063	
  2064	async def handle_aardvark_join_request(payload: Dict[str, Any]) -> ActionResponse:
  2065	    """Handle Aardvark requesting to join a team"""
  2066	    try:
  2067	        aardvark_id = payload.get("aardvark_id")
  2068	        target_team = payload.get("target_team", "team1")
  2069	        
  2070	        if not aardvark_id:
  2071	            raise HTTPException(status_code=400, detail="aardvark_id is required")
  2072	        
  2073	        result = wgp_simulation.aardvark_request_team(aardvark_id, target_team)
  2074	        updated_state = wgp_simulation.get_game_state()
  2075	        
  2076	        return ActionResponse(
  2077	            game_state=updated_state,
  2078	            log_message=result["message"],
  2079	            available_actions=[
  2080	                {"action_type": "AARDVARK_TOSS", "prompt": f"Accept or toss {result['aardvark_name']}"}
  2081	            ],
  2082	            timeline_event={
  2083	                "id": f"aardvark_request_{datetime.now().timestamp()}",
  2084	                "timestamp": datetime.now().isoformat(),
  2085	                "type": "aardvark_request",
  2086	                "description": result["message"],
  2087	                "details": {
  2088	                    "aardvark_id": aardvark_id,
  2089	                    "target_team": target_team
  2090	                }
  2091	            }
  2092	        )
  2093	    except Exception as e:
  2094	        logger.error(f"Error handling Aardvark join request: {e}")
  2095	        raise HTTPException(status_code=500, detail=f"Failed to handle Aardvark join request: {str(e)}")
  2096	
  2097	async def handle_aardvark_toss(payload: Dict[str, Any]) -> ActionResponse:
  2098	    """Handle team response to Aardvark request (accept or toss)"""
  2099	    try:
  2100	        team_id = payload.get("team_id", "team1")
  2101	        accept = payload.get("accept", False)
  2102	        
  2103	        result = wgp_simulation.respond_to_aardvark(team_id, accept)
  2104	        updated_state = wgp_simulation.get_game_state()
  2105	        
  2106	        return ActionResponse(
  2107	            game_state=updated_state,
  2108	            log_message=result["message"],
  2109	            available_actions=[
  2110	                {"action_type": "PLAY_SHOT", "prompt": "Continue with hole"}
  2111	            ],
  2112	            timeline_event={
  2113	                "id": f"aardvark_toss_{datetime.now().timestamp()}",
  2114	                "timestamp": datetime.now().isoformat(),
  2115	                "type": "aardvark_toss",
  2116	                "description": result["message"],
  2117	                "details": {
  2118	                    "team_id": team_id,
  2119	                    "accepted": accept,
  2120	                    "status": result["status"]
  2121	                }
  2122	            }
  2123	        )
  2124	    except Exception as e:
  2125	        logger.error(f"Error handling Aardvark toss: {e}")
  2126	        raise HTTPException(status_code=500, detail=f"Failed to handle Aardvark toss: {str(e)}")
  2127	
  2128	async def handle_aardvark_go_solo(payload: Dict[str, Any]) -> ActionResponse:
  2129	    """Handle Aardvark deciding to go solo"""
  2130	    try:
  2131	        aardvark_id = payload.get("aardvark_id")
  2132	        use_tunkarri = payload.get("use_tunkarri", False)
  2133	        
  2134	        if not aardvark_id:
  2135	            raise HTTPException(status_code=400, detail="aardvark_id is required")
  2136	        
  2137	        result = wgp_simulation.aardvark_go_solo(aardvark_id, use_tunkarri)
  2138	        updated_state = wgp_simulation.get_game_state()
  2139	        
  2140	        return ActionResponse(
  2141	            game_state=updated_state,
  2142	            log_message=result["message"],
  2143	            available_actions=[
  2144	                {"action_type": "PLAY_SHOT", "prompt": "Continue with hole"}
  2145	            ],
  2146	            timeline_event={
  2147	                "id": f"aardvark_solo_{datetime.now().timestamp()}",
  2148	                "timestamp": datetime.now().isoformat(),
  2149	                "type": "aardvark_solo",
  2150	                "description": result["message"],
  2151	                "details": {
  2152	                    "aardvark_id": aardvark_id,
  2153	                    "use_tunkarri": use_tunkarri,
  2154	                    "status": result["status"]
  2155	                }
  2156	            }
  2157	        )
  2158	    except Exception as e:
  2159	        logger.error(f"Error handling Aardvark go solo: {e}")
  2160	        raise HTTPException(status_code=500, detail=f"Failed to handle Aardvark go solo: {str(e)}")
  2161	
  2162	async def handle_joes_special(payload: Dict[str, Any]) -> ActionResponse:
  2163	    """Handle Joe's Special wager selection in Hoepfinger"""
  2164	    try:
  2165	        selected_value = payload.get("selected_value", 2)
  2166	        
  2167	        # Apply Joe's Special value to current hole betting
  2168	        hole_state = wgp_simulation.hole_states[wgp_simulation.current_hole]
  2169	        hole_state.betting.joes_special_value = selected_value
  2170	        hole_state.betting.base_wager = selected_value
  2171	        hole_state.betting.current_wager = selected_value
  2172	        
  2173	        updated_state = wgp_simulation.get_game_state()
  2174	        
  2175	        return ActionResponse(
  2176	            game_state=updated_state,
  2177	            log_message=f"Joe's Special invoked! Hole starts at {selected_value} quarters.",
  2178	            available_actions=[
  2179	                {"action_type": "PLAY_SHOT", "prompt": "Continue with hole"}
  2180	            ],
  2181	            timeline_event={
  2182	                "id": f"joes_special_{datetime.now().timestamp()}",
  2183	                "timestamp": datetime.now().isoformat(),
  2184	                "type": "joes_special",
  2185	                "description": f"Joe's Special: Hole value set to {selected_value} quarters",
  2186	                "details": {"selected_value": selected_value}
  2187	            }
  2188	        )
  2189	    except Exception as e:
  2190	        logger.error(f"Error invoking Joe's Special: {e}")
  2191	        raise HTTPException(status_code=500, detail=f"Failed to invoke Joe's Special: {str(e)}")
  2192	
  2193	async def handle_get_post_hole_analysis(payload: Dict[str, Any]) -> ActionResponse:
  2194	    """Handle post-hole analysis request"""
  2195	    try:
  2196	        hole_number = payload.get("hole_number", wgp_simulation.current_hole)
  2197	        
  2198	        analysis = wgp_simulation.get_post_hole_analysis(hole_number)
  2199	        updated_state = wgp_simulation.get_game_state()
  2200	        
  2201	        return ActionResponse(
  2202	            game_state=updated_state,
  2203	            log_message=f"Post-hole analysis generated for hole {hole_number}",
  2204	            available_actions=[
  2205	                {"action_type": "ADVANCE_HOLE", "prompt": "Continue to next hole"}
  2206	            ],
  2207	            timeline_event={
  2208	                "id": f"post_hole_analysis_{hole_number}_{datetime.now().timestamp()}",
  2209	                "timestamp": datetime.now().isoformat(),
  2210	                "type": "post_hole_analysis",
  2211	                "description": f"Comprehensive analysis of hole {hole_number}",
  2212	                "details": analysis
  2213	            }
  2214	        )
  2215	    except Exception as e:
  2216	        logger.error(f"Error getting post-hole analysis: {e}")
  2217	        raise HTTPException(status_code=500, detail=f"Failed to get post-hole analysis: {str(e)}")
  2218	
  2219	async def handle_enter_hole_scores(payload: Dict[str, Any]) -> ActionResponse:
  2220	    """Handle entering hole scores"""
  2221	    try:
  2222	        scores = payload.get("scores", {})
  2223	        
  2224	        result = wgp_simulation.enter_hole_scores(scores)
  2225	        updated_state = wgp_simulation.get_game_state()
  2226	        
  2227	        return ActionResponse(
  2228	            game_state=updated_state,
  2229	            log_message=result.get("message", "Hole scores entered and points calculated"),
  2230	            available_actions=[
  2231	                {"action_type": "GET_POST_HOLE_ANALYSIS", "prompt": "View Hole Analysis"},
  2232	                {"action_type": "ADVANCE_HOLE", "prompt": "Continue to Next Hole"}
  2233	            ],
  2234	            timeline_event={
  2235	                "id": f"scores_entered_{wgp_simulation.current_hole}_{datetime.now().timestamp()}",
  2236	                "timestamp": datetime.now().isoformat(),
  2237	                "type": "scores_entered",
  2238	                "description": f"Scores entered for hole {wgp_simulation.current_hole}",
  2239	                "details": {
  2240	                    "scores": scores,
  2241	                    "points_result": result
  2242	                }
  2243	            }
  2244	        )
  2245	    except Exception as e:
  2246	        logger.error(f"Error entering hole scores: {e}")
  2247	        raise HTTPException(status_code=500, detail=f"Failed to enter hole scores: {str(e)}")
  2248	
  2249	async def handle_get_advanced_analytics(payload: Dict[str, Any]) -> ActionResponse:
  2250	    """Handle getting advanced analytics dashboard data"""
  2251	    try:
  2252	        analytics = wgp_simulation.get_advanced_analytics()
  2253	        updated_state = wgp_simulation.get_game_state()
  2254	        
  2255	        # Include analytics data in the updated game state
  2256	        updated_state["analytics"] = analytics
  2257	        
  2258	        return ActionResponse(
  2259	            game_state=updated_state,
  2260	            log_message="Advanced analytics data retrieved",
  2261	            available_actions=[
  2262	                {"action_type": "PLAY_SHOT", "prompt": "Continue Game"},
  2263	                {"action_type": "GET_ADVANCED_ANALYTICS", "prompt": "Refresh Analytics"}
  2264	            ],
  2265	            timeline_event={
  2266	                "id": f"analytics_viewed_{datetime.now().timestamp()}",
  2267	                "timestamp": datetime.now().isoformat(),
  2268	                "type": "analytics_viewed",
  2269	                "description": "Advanced analytics dashboard accessed",
  2270	                "details": analytics  # Include full analytics data here
  2271	            }
  2272	        )
  2273	    except Exception as e:
  2274	        logger.error(f"Error getting advanced analytics: {e}")
  2275	        raise HTTPException(status_code=500, detail=f"Failed to get advanced analytics: {str(e)}")
  2276	
  2277	# Helper function to serialize game state
  2278	def _serialize_game_state():
  2279	    """Convert game state to serializable format"""
  2280	    try:
  2281	        # Get the current game state from the WGP simulation
  2282	        state = wgp_simulation.get_game_state()
  2283	        return state
  2284	    except Exception as e:
  2285	        logger.error(f"Error serializing game state: {e}")
  2286	        return {}
  2287	
  2288	
  2289	# Shot Range Analysis Endpoint
  2290	class ShotRangeAnalysisRequest(BaseModel):
  2291	    """Request model for shot range analysis"""
  2292	    lie_type: str = Field(..., description="Current lie (fairway, rough, bunker, etc)")
  2293	    distance_to_pin: float = Field(..., description="Distance to pin in yards")
  2294	    player_handicap: float = Field(..., description="Player's handicap")
  2295	    hole_number: int = Field(..., description="Current hole number")
  2296	    team_situation: str = Field(default="solo", description="Team situation (solo, partners)")
  2297	    score_differential: int = Field(default=0, description="Current score differential")
  2298	    opponent_styles: List[str] = Field(default=[], description="Opponent playing styles")
  2299	
  2300	
  2301	@app.post("/wgp/shot-range-analysis")
  2302	async def get_shot_range_analysis(request: ShotRangeAnalysisRequest):
  2303	    """Get poker-style shot range analysis for decision making"""
  2304	    try:
  2305	        # Perform shot range analysis
  2306	        analysis = analyze_shot_decision(
  2307	            current_lie=request.lie_type,
  2308	            distance=request.distance_to_pin,
  2309	            player_handicap=request.player_handicap,
  2310	            hole_number=request.hole_number,
  2311	            team_situation=request.team_situation,
  2312	            score_differential=request.score_differential,
  2313	            opponent_styles=request.opponent_styles
  2314	        )
  2315	        
  2316	        return {
  2317	            "status": "success",
  2318	            "analysis": analysis,
  2319	            "timestamp": datetime.now().isoformat()
  2320	        }
  2321	        
  2322	    except Exception as e:
  2323	        logger.error(f"Error in shot range analysis: {e}")
  2324	        raise HTTPException(status_code=500, detail=f"Failed to analyze shot range: {str(e)}")
  2325	
  2326	
  2327	# Real-Time Betting Odds Endpoints
  2328	class OddsCalculationRequest(BaseModel):
  2329	    """Request model for odds calculation"""
  2330	    players: List[Dict[str, Any]] = Field(..., description="Current player states")
  2331	    hole_state: Dict[str, Any] = Field(..., description="Current hole state")
  2332	    use_monte_carlo: bool = Field(default=False, description="Use Monte Carlo simulation for higher accuracy")
  2333	    simulation_params: Optional[Dict[str, Any]] = Field(default=None, description="Monte Carlo simulation parameters")
  2334	
  2335	
  2336	class BettingScenarioResponse(BaseModel):
  2337	    """Response model for betting scenarios"""
  2338	    scenario_type: str
  2339	    win_probability: float
  2340	    expected_value: float
  2341	    risk_level: str
  2342	    confidence_interval: Tuple[float, float]
  2343	    recommendation: str
  2344	    reasoning: str
  2345	    payout_matrix: Dict[str, float]
  2346	
  2347	
  2348	class OddsCalculationResponse(BaseModel):
  2349	    """Response model for odds calculation"""
  2350	    timestamp: float
  2351	    calculation_time_ms: float
  2352	    player_probabilities: Dict[str, Dict[str, Any]]
  2353	    team_probabilities: Dict[str, float]
  2354	    betting_scenarios: List[Dict[str, Any]]
  2355	    optimal_strategy: str
  2356	    risk_assessment: Dict[str, Any]
  2357	    educational_insights: List[str]
  2358	    confidence_level: float
  2359	    monte_carlo_used: bool = False
  2360	    simulation_details: Optional[Dict[str, Any]] = None
  2361	
  2362	
  2363	@app.post("/wgp/calculate-odds", response_model=OddsCalculationResponse)
  2364	async def calculate_real_time_odds(request: OddsCalculationRequest):
  2365	    """
  2366	    Calculate real-time betting odds and probabilities.
  2367	    Provides comprehensive analysis for strategic decision making.
  2368	    """
  2369	    try:
  2370	        from .services.odds_calculator import (
  2371	            OddsCalculator, 
  2372	            create_player_state_from_game_data,
  2373	            create_hole_state_from_game_data
  2374	        )
  2375	        from .services.monte_carlo import run_monte_carlo_simulation, SimulationParams
  2376	        
  2377	        start_time = time.time()
  2378	        
  2379	        # Convert request data to internal objects
  2380	        player_states = [create_player_state_from_game_data(p) for p in request.players]
  2381	        hole_state = create_hole_state_from_game_data(request.hole_state)
  2382	        
  2383	        # Initialize odds calculator
  2384	        calculator = OddsCalculator()
  2385	        
  2386	        # Determine if we should use Monte Carlo
  2387	        use_mc = request.use_monte_carlo
  2388	        if not use_mc:
  2389	            # Auto-enable Monte Carlo for complex scenarios
  2390	            complex_scenario = (
  2391	                len(player_states) > 4 or
  2392	                hole_state.teams.value != "pending" or
  2393	                any(p.distance_to_pin > 200 for p in player_states)
  2394	            )
  2395	            use_mc = complex_scenario
  2396	        
  2397	        simulation_details = None
  2398	        if use_mc:
  2399	            # Run Monte Carlo simulation
  2400	            mc_params = SimulationParams()
  2401	            if request.simulation_params:
  2402	                mc_params.num_simulations = request.simulation_params.get("num_simulations", 5000)
  2403	                mc_params.max_simulation_time_ms = request.simulation_params.get("max_time_ms", 25.0)
  2404	            
  2405	            simulation_result = run_monte_carlo_simulation(player_states, hole_state, 
  2406	                                                         mc_params.num_simulations, 
  2407	                                                         mc_params.max_simulation_time_ms)
  2408	            
  2409	            simulation_details = {
  2410	                "num_simulations_run": simulation_result.num_simulations_run,
  2411	                "simulation_time_ms": simulation_result.simulation_time_ms,
  2412	                "convergence_achieved": simulation_result.convergence_achieved,
  2413	                "confidence_intervals": simulation_result.confidence_intervals
  2414	            }
  2415	            
  2416	            # Enhance calculator with Monte Carlo results
  2417	            # This would integrate MC results into the main calculation
  2418	        
  2419	        # Calculate comprehensive odds
  2420	        odds_result = calculator.calculate_real_time_odds(
  2421	            player_states, 
  2422	            hole_state,
  2423	            game_context={"monte_carlo_result": simulation_details if use_mc else None}
  2424	        )
  2425	        
  2426	        # Convert betting scenarios to response format
  2427	        betting_scenarios = []
  2428	        for scenario in odds_result.betting_scenarios:
  2429	            betting_scenarios.append({
  2430	                "scenario_type": scenario.scenario_type,
  2431	                "win_probability": scenario.win_probability,
  2432	                "expected_value": scenario.expected_value,
  2433	                "risk_level": scenario.risk_level,
  2434	                "confidence_interval": scenario.confidence_interval,
  2435	                "recommendation": scenario.recommendation,
  2436	                "reasoning": scenario.reasoning,
  2437	                "payout_matrix": scenario.payout_matrix
  2438	            })
  2439	        
  2440	        total_time = (time.time() - start_time) * 1000
  2441	        
  2442	        return OddsCalculationResponse(
  2443	            timestamp=odds_result.timestamp,
  2444	            calculation_time_ms=total_time,
  2445	            player_probabilities=odds_result.player_probabilities,
  2446	            team_probabilities=odds_result.team_probabilities,
  2447	            betting_scenarios=betting_scenarios,
  2448	            optimal_strategy=odds_result.optimal_strategy,
  2449	            risk_assessment=odds_result.risk_assessment,
  2450	            educational_insights=odds_result.educational_insights,
  2451	            confidence_level=odds_result.confidence_level,
  2452	            monte_carlo_used=use_mc,
  2453	            simulation_details=simulation_details
  2454	        )
  2455	        
  2456	    except Exception as e:
  2457	        logger.error(f"Error calculating odds: {e}")
  2458	        logger.error(traceback.format_exc())
  2459	        raise HTTPException(status_code=500, detail=f"Failed to calculate odds: {str(e)}")
  2460	
  2461	
  2462	@app.get("/wgp/betting-opportunities")
  2463	async def get_current_betting_opportunities():
  2464	    """
  2465	    Get current betting opportunities based on game state.
  2466	    Lightweight endpoint for real-time updates.
  2467	    """
  2468	    try:
  2469	        # Get current game state
  2470	        current_state = wgp_simulation.get_game_state()
  2471	        
  2472	        # Quick opportunity assessment
  2473	        opportunities = []
  2474	        
  2475	        # Check if game is active
  2476	        if not current_state.get("active", False):
  2477	            return {"opportunities": [], "message": "No active game"}
  2478	        
  2479	        current_hole = current_state.get("current_hole", 1)
  2480	        hole_state = wgp_simulation.hole_states.get(current_hole)
  2481	        
  2482	        if hole_state:
  2483	            # Check for doubling opportunities
  2484	            if not hole_state.betting.doubled and hole_state.teams.type != "pending":
  2485	                opportunities.append({
  2486	                    "type": "offer_double",
  2487	                    "description": f"Double the wager from {hole_state.betting.current_wager} to {hole_state.betting.current_wager * 2} quarters",
  2488	                    "current_wager": hole_state.betting.current_wager,
  2489	                    "potential_wager": hole_state.betting.current_wager * 2,
  2490	                    "risk_level": "medium",
  2491	                    "timing": "optimal" if not hole_state.wagering_closed else "limited"
  2492	                })
  2493	            
  2494	            # Check for partnership opportunities
  2495	            if hole_state.teams.type == "pending":
  2496	                captain_id = hole_state.teams.captain
  2497	                captain_name = wgp_simulation._get_player_name(captain_id)
  2498	                
  2499	                available_partners = []
  2500	                for player in wgp_simulation.players:
  2501	                    if player.id != captain_id and hole_state.can_request_partnership(captain_id, player.id):
  2502	                        available_partners.append({
  2503	                            "id": player.id,
  2504	                            "name": player.name,
  2505	                            "handicap": player.handicap
  2506	                        })
  2507	                
  2508	                if available_partners:
  2509	                    opportunities.append({
  2510	                        "type": "partnership_decision",
  2511	                        "description": f"{captain_name} must choose a partner or go solo",
  2512	                        "captain": captain_name,
  2513	                        "available_partners": available_partners,
  2514	                        "solo_multiplier": 2,
  2515	                        "deadline_approaching": len(available_partners) < len(wgp_simulation.players) - 1
  2516	                    })
  2517	        
  2518	        return {
  2519	            "opportunities": opportunities,
  2520	            "hole_number": current_hole,
  2521	            "timestamp": datetime.now().isoformat(),
  2522	            "game_active": current_state.get("active", False)
  2523	        }
  2524	        
  2525	    except Exception as e:
  2526	        logger.error(f"Error getting betting opportunities: {e}")
  2527	        raise HTTPException(status_code=500, detail=f"Failed to get betting opportunities: {str(e)}")
  2528	
  2529	
  2530	@app.post("/wgp/quick-odds")
  2531	async def calculate_quick_odds(players_data: List[Dict[str, Any]] = Body(...)):
  2532	    """
  2533	    Quick odds calculation for immediate feedback.
  2534	    Optimized for sub-50ms response time.
  2535	    """
  2536	    try:
  2537	        from .services.odds_calculator import OddsCalculator, PlayerState, HoleState, TeamConfiguration
  2538	        
  2539	        start_time = time.time()
  2540	        
  2541	        # Simple validation
  2542	        if len(players_data) < 2:
  2543	            raise HTTPException(status_code=400, detail="At least 2 players required")
  2544	        
  2545	        # Create simplified player states
  2546	        players = []
  2547	        for i, p_data in enumerate(players_data):
  2548	            player = PlayerState(
  2549	                id=p_data.get("id", f"p{i}"),
  2550	                name=p_data.get("name", f"Player {i+1}"),
  2551	                handicap=float(p_data.get("handicap", 18)),
  2552	                distance_to_pin=float(p_data.get("distance_to_pin", 150)),
  2553	                lie_type=p_data.get("lie_type", "fairway")
  2554	            )
  2555	            players.append(player)
  2556	        
  2557	        # Create basic hole state
  2558	        hole = HoleState(
  2559	            hole_number=1,
  2560	            par=4,
  2561	            teams=TeamConfiguration.PENDING
  2562	        )
  2563	        
  2564	        # Quick calculation
  2565	        calculator = OddsCalculator()
  2566	        
  2567	        # Calculate win probabilities only
  2568	        quick_probs = {}
  2569	        for player in players:
  2570	            win_prob = calculator._calculate_player_win_vs_field(player, players, hole)
  2571	            quick_probs[player.id] = {
  2572	                "name": player.name,
  2573	                "win_probability": win_prob,
  2574	                "handicap": player.handicap,
  2575	                "distance": player.distance_to_pin
  2576	            }
  2577	        
  2578	        calculation_time = (time.time() - start_time) * 1000
  2579	        
  2580	        return {
  2581	            "probabilities": quick_probs,
  2582	            "calculation_time_ms": calculation_time,
  2583	            "method": "quick_analytical",
  2584	            "timestamp": time.time()
  2585	        }
  2586	        
  2587	    except Exception as e:
  2588	        logger.error(f"Error in quick odds calculation: {e}")
  2589	        raise HTTPException(status_code=500, detail=f"Failed to calculate quick odds: {str(e)}")
  2590	
  2591	
  2592	@app.get("/wgp/odds-history/{game_id}")
  2593	async def get_odds_history(game_id: str, hole_number: Optional[int] = None):
  2594	    """
  2595	    Get historical odds data for analysis and trends.
  2596	    """
  2597	    try:
  2598	        # This would typically query a database for historical odds
  2599	        # For now, return mock data structure
  2600	        
  2601	        history_data = {
  2602	            "game_id": game_id,
  2603	            "holes": {},
  2604	            "trends": {
  2605	                "volatility_by_hole": {},
  2606	                "betting_patterns": {},
  2607	                "accuracy_metrics": {}
  2608	            }
  2609	        }
  2610	        
  2611	        # If specific hole requested
  2612	        if hole_number:
  2613	            history_data["holes"][str(hole_number)] = {
  2614	                "initial_odds": {},
  2615	                "final_odds": {},
  2616	                "betting_actions": [],
  2617	                "outcome": {}
  2618	            }
  2619	        
  2620	        return history_data
  2621	        
  2622	    except Exception as e:
  2623	        logger.error(f"Error getting odds history: {e}")
  2624	        raise HTTPException(status_code=500, detail=f"Failed to get odds history: {str(e)}")
  2625	
  2626	
  2627	# Player Profile Management Endpoints
  2628	@app.post("/players", response_model=schemas.PlayerProfileResponse)
  2629	def create_player_profile(profile: schemas.PlayerProfileCreate):
  2630	    """Create a new player profile."""
  2631	    try:
  2632	        db = database.SessionLocal()
  2633	        from .services.player_service import PlayerService
  2634	        
  2635	        player_service = PlayerService(db)
  2636	        result = player_service.create_player_profile(profile)
  2637	        
  2638	        logger.info(f"Created player profile: {result.name}")
  2639	        return result
  2640	        
  2641	    except ValueError as e:
  2642	        logger.error(f"Validation error creating player profile: {e}")
  2643	        raise HTTPException(status_code=400, detail=str(e))
  2644	    except Exception as e:
  2645	        logger.error(f"Error creating player profile: {e}")
  2646	        raise HTTPException(status_code=500, detail=f"Failed to create player profile: {str(e)}")
  2647	    finally:
  2648	        db.close()
  2649	
  2650	@app.get("/players", response_model=List[schemas.PlayerProfileResponse])
  2651	def get_all_player_profiles(active_only: bool = Query(True, description="Return only active profiles")):
  2652	    """Get all player profiles."""
  2653	    try:
  2654	        db = database.SessionLocal()
  2655	        from .services.player_service import PlayerService
  2656	        
  2657	        player_service = PlayerService(db)
  2658	        profiles = player_service.get_all_player_profiles(active_only=active_only)
  2659	        
  2660	        logger.info(f"Retrieved {len(profiles)} player profiles")
  2661	        return profiles
  2662	        
  2663	    except Exception as e:
  2664	        logger.error(f"Error getting player profiles: {e}")
  2665	        raise HTTPException(status_code=500, detail=f"Failed to get player profiles: {str(e)}")
  2666	    finally:
  2667	        db.close()
  2668	
  2669	@app.get("/players/{player_id}", response_model=schemas.PlayerProfileResponse)
  2670	def get_player_profile(player_id: int):
  2671	    """Get a specific player profile."""
  2672	    try:
  2673	        db = database.SessionLocal()
  2674	        from .services.player_service import PlayerService
  2675	        
  2676	        player_service = PlayerService(db)
  2677	        profile = player_service.get_player_profile(player_id)
  2678	        
  2679	        if not profile:
  2680	            raise HTTPException(status_code=404, detail=f"Player {player_id} not found")
  2681	        
  2682	        return profile
  2683	        
  2684	    except HTTPException:
  2685	        raise
  2686	    except Exception as e:
  2687	        logger.error(f"Error getting player profile {player_id}: {e}")
  2688	        raise HTTPException(status_code=500, detail=f"Failed to get player profile: {str(e)}")
  2689	    finally:
  2690	        db.close()
  2691	
  2692	@app.put("/players/{player_id}", response_model=schemas.PlayerProfileResponse)
  2693	def update_player_profile(player_id: int, profile_update: schemas.PlayerProfileUpdate):
  2694	    """Update a player profile."""
  2695	    try:
  2696	        db = database.SessionLocal()
  2697	        from .services.player_service import PlayerService
  2698	        
  2699	        player_service = PlayerService(db)
  2700	        updated_profile = player_service.update_player_profile(player_id, profile_update)
  2701	        
  2702	        if not updated_profile:
  2703	            raise HTTPException(status_code=404, detail=f"Player {player_id} not found")
  2704	        
  2705	        logger.info(f"Updated player profile {player_id}")
  2706	        return updated_profile
  2707	        
  2708	    except ValueError as e:
  2709	        logger.error(f"Validation error updating player profile: {e}")
  2710	        raise HTTPException(status_code=400, detail=str(e))
  2711	    except HTTPException:
  2712	        raise
  2713	    except Exception as e:
  2714	        logger.error(f"Error updating player profile {player_id}: {e}")
  2715	        raise HTTPException(status_code=500, detail=f"Failed to update player profile: {str(e)}")
  2716	    finally:
  2717	        db.close()
  2718	
  2719	@app.delete("/players/{player_id}")
  2720	def delete_player_profile(player_id: int):
  2721	    """Delete (deactivate) a player profile."""
  2722	    try:
  2723	        db = database.SessionLocal()
  2724	        from .services.player_service import PlayerService
  2725	        
  2726	        player_service = PlayerService(db)
  2727	        success = player_service.delete_player_profile(player_id)
  2728	        
  2729	        if not success:
  2730	            raise HTTPException(status_code=404, detail=f"Player {player_id} not found")
  2731	        
  2732	        logger.info(f"Deleted player profile {player_id}")
  2733	        return {"message": f"Player {player_id} has been deleted"}
  2734	        
  2735	    except HTTPException:
  2736	        raise
  2737	    except Exception as e:
  2738	        logger.error(f"Error deleting player profile {player_id}: {e}")
  2739	        raise HTTPException(status_code=500, detail=f"Failed to delete player profile: {str(e)}")
  2740	    finally:
  2741	        db.close()
  2742	
  2743	@app.get("/players/name/{player_name}", response_model=schemas.PlayerProfileResponse)
  2744	def get_player_profile_by_name(player_name: str):
  2745	    """Get a player profile by name."""
  2746	    try:
  2747	        db = database.SessionLocal()
  2748	        from .services.player_service import PlayerService
  2749	        
  2750	        player_service = PlayerService(db)
  2751	        profile = player_service.get_player_profile_by_name(player_name)
  2752	        
  2753	        if not profile:
  2754	            raise HTTPException(status_code=404, detail=f"Player '{player_name}' not found")
  2755	        
  2756	        return profile
  2757	        
  2758	    except HTTPException:
  2759	        raise
  2760	    except Exception as e:
  2761	        logger.error(f"Error getting player profile by name {player_name}: {e}")
  2762	        raise HTTPException(status_code=500, detail=f"Failed to get player profile: {str(e)}")
  2763	    finally:
  2764	        db.close()
  2765	
  2766	# Player Statistics Endpoints
  2767	@app.get("/players/{player_id}/statistics", response_model=schemas.PlayerStatisticsResponse)
  2768	def get_player_statistics(player_id: int):
  2769	    """Get player statistics."""
  2770	    try:
  2771	        db = database.SessionLocal()
  2772	        from .services.player_service import PlayerService
  2773	        
  2774	        player_service = PlayerService(db)
  2775	        stats = player_service.get_player_statistics(player_id)
  2776	        
  2777	        if not stats:
  2778	            raise HTTPException(status_code=404, detail=f"Statistics for player {player_id} not found")
  2779	        
  2780	        return stats
  2781	        
  2782	    except HTTPException:
  2783	        raise
  2784	    except Exception as e:
  2785	        logger.error(f"Error getting player statistics {player_id}: {e}")
  2786	        raise HTTPException(status_code=500, detail=f"Failed to get player statistics: {str(e)}")
  2787	    finally:
  2788	        db.close()
  2789	
  2790	@app.get("/players/{player_id}/analytics", response_model=schemas.PlayerPerformanceAnalytics)
  2791	def get_player_analytics(player_id: int):
  2792	    """Get comprehensive player performance analytics."""
  2793	    try:
  2794	        db = database.SessionLocal()
  2795	        from .services.player_service import PlayerService
  2796	        
  2797	        player_service = PlayerService(db)
  2798	        analytics = player_service.get_player_performance_analytics(player_id)
  2799	        
  2800	        if not analytics:
  2801	            raise HTTPException(status_code=404, detail=f"Analytics for player {player_id} not found")
  2802	        
  2803	        return analytics
  2804	        
  2805	    except HTTPException:
  2806	        raise
  2807	    except Exception as e:
  2808	        logger.error(f"Error getting player analytics {player_id}: {e}")
  2809	        raise HTTPException(status_code=500, detail=f"Failed to get player analytics: {str(e)}")
  2810	    finally:
  2811	        db.close()
  2812	
  2813	@app.get("/players/{player_id}/profile-with-stats", response_model=schemas.PlayerProfileWithStats)
  2814	def get_player_profile_with_stats(player_id: int):
  2815	    """Get player profile combined with statistics and achievements."""
  2816	    try:
  2817	        db = database.SessionLocal()
  2818	        from .services.player_service import PlayerService
  2819	        
  2820	        player_service = PlayerService(db)
  2821	        
  2822	        # Get profile
  2823	        profile = player_service.get_player_profile(player_id)
  2824	        if not profile:
  2825	            raise HTTPException(status_code=404, detail=f"Player {player_id} not found")
  2826	        
  2827	        # Get statistics
  2828	        stats = player_service.get_player_statistics(player_id)
  2829	        if not stats:
  2830	            # Create empty stats if none exist
  2831	            stats = schemas.PlayerStatisticsResponse(
  2832	                id=0, player_id=player_id, games_played=0, games_won=0,
  2833	                total_earnings=0.0, holes_played=0, holes_won=0,
  2834	                avg_earnings_per_hole=0.0, betting_success_rate=0.0,
  2835	                successful_bets=0, total_bets=0, partnership_success_rate=0.0,
  2836	                partnerships_formed=0, partnerships_won=0, solo_attempts=0,
  2837	                solo_wins=0, favorite_game_mode="wolf_goat_pig", preferred_player_count=4,
  2838	                best_hole_performance=[], worst_hole_performance=[],
  2839	                performance_trends=[], last_updated=datetime.now().isoformat()
  2840	            )
  2841	        
  2842	        # Get recent achievements (would need to implement this query)
  2843	        recent_achievements = []  # Placeholder
  2844	        
  2845	        return schemas.PlayerProfileWithStats(
  2846	            profile=profile,
  2847	            statistics=stats,
  2848	            recent_achievements=recent_achievements
  2849	        )
  2850	        
  2851	    except HTTPException:
  2852	        raise
  2853	    except Exception as e:
  2854	        logger.error(f"Error getting player profile with stats {player_id}: {e}")
  2855	        raise HTTPException(status_code=500, detail=f"Failed to get player profile with stats: {str(e)}")
  2856	    finally:
  2857	        db.close()
  2858	
  2859	# Leaderboard and Comparative Analytics
  2860	@app.get("/leaderboard", response_model=List[schemas.LeaderboardEntry])
  2861	def get_leaderboard(
  2862	    limit: int = Query(100, ge=1, le=100),  # Default to 100 to show all players
  2863	    sort: str = Query("desc", regex="^(asc|desc)$")  # Add sort parameter
  2864	):
  2865	    """Get the player leaderboard."""
  2866	    try:
  2867	        db = database.SessionLocal()
  2868	        from .services.player_service import PlayerService
  2869	        
  2870	        player_service = PlayerService(db)
  2871	        leaderboard = player_service.get_leaderboard(limit=limit)
  2872	        
  2873	        # Sort by total_earnings based on sort parameter
  2874	        if sort == "asc":
  2875	            leaderboard.sort(key=lambda x: x.total_earnings or 0)
  2876	        else:
  2877	            leaderboard.sort(key=lambda x: x.total_earnings or 0, reverse=True)
  2878	        
  2879	        # Re-rank after sorting
  2880	        for i, entry in enumerate(leaderboard, 1):
  2881	            entry.rank = i
  2882	        
  2883	        return leaderboard
  2884	        
  2885	    except Exception as e:
  2886	        logger.error(f"Error getting leaderboard: {e}")
  2887	        raise HTTPException(status_code=500, detail=f"Failed to get leaderboard: {str(e)}")
  2888	    finally:
  2889	        db.close()
  2890	
  2891	@app.get("/leaderboard/{metric}")
  2892	def get_leaderboard_by_metric(
  2893	    metric: str, 
  2894	    limit: int = Query(10, ge=1, le=100)
  2895	):
  2896	    """Get leaderboard sorted by specific metric."""
  2897	    try:
  2898	        db = database.SessionLocal()
  2899	        from .services.statistics_service import StatisticsService
  2900	        
  2901	        stats_service = StatisticsService(db)
  2902	        leaderboard = stats_service.get_comparative_leaderboard(metric=metric, limit=limit)
  2903	        
  2904	        return {
  2905	            "metric": metric,
  2906	            "leaderboard": leaderboard,
  2907	            "total_players": len(leaderboard)
  2908	        }
  2909	        
  2910	    except Exception as e:
  2911	        logger.error(f"Error getting leaderboard by metric {metric}: {e}")
  2912	        raise HTTPException(status_code=500, detail=f"Failed to get leaderboard: {str(e)}")
  2913	    finally:
  2914	        db.close()
  2915	
  2916	@app.get("/analytics/game-stats")
  2917	def get_game_stats():
  2918	    """Get game statistics analytics"""
  2919	    try:
  2920	        db = database.SessionLocal()
  2921	        
  2922	        # Get basic game statistics
  2923	        total_games = db.query(models.GameRecord).count() if hasattr(models, 'GameRecord') else 0
  2924	        total_simulations = db.query(models.SimulationResult).count()
  2925	        
  2926	        # Get course usage
  2927	        courses = game_state.get_courses()
  2928	        course_names = list(courses.keys()) if courses else []
  2929	        
  2930	        return {
  2931	            "total_games": total_games,
  2932	            "total_simulations": total_simulations,
  2933	            "available_courses": len(course_names),
  2934	            "course_names": course_names,
  2935	            "game_modes": ["4-man", "5-man", "6-man"],
  2936	            "betting_types": ["Wolf", "Goat", "Pig", "Aardvark"],
  2937	            "last_updated": datetime.now().isoformat()
  2938	        }
  2939	        
  2940	    except Exception as e:
  2941	        logger.error(f"Error getting game stats: {e}")
  2942	        raise HTTPException(status_code=500, detail=f"Failed to get game stats: {str(e)}")
  2943	    finally:
  2944	        db.close()
  2945	
  2946	@app.get("/analytics/player-performance") 
  2947	def get_player_performance():
  2948	    """Get player performance analytics"""
  2949	    try:
  2950	        db = database.SessionLocal()
  2951	        
  2952	        # Get basic player statistics
  2953	        total_players = db.query(models.PlayerProfile).filter(models.PlayerProfile.is_active == 1).count()
  2954	        active_players = total_players  # For now, assume all active players are active
  2955	        
  2956	        # Get recent signups
  2957	        recent_signups = db.query(models.DailySignup).filter(
  2958	            models.DailySignup.status != "cancelled"
  2959	        ).count()
  2960	        
  2961	        return {
  2962	            "total_players": total_players,
  2963	            "active_players": active_players,
  2964	            "recent_signups": recent_signups,
  2965	            "average_handicap": 15.5,  # Placeholder calculation
  2966	            "performance_metrics": {
  2967	                "games_played": 0,
  2968	                "average_score": 0,
  2969	                "best_round": 0,
  2970	                "worst_round": 0
  2971	            },
  2972	            "last_updated": datetime.now().isoformat()
  2973	        }
  2974	        
  2975	    except Exception as e:
  2976	        logger.error(f"Error getting player performance: {e}")
  2977	        raise HTTPException(status_code=500, detail=f"Failed to get player performance: {str(e)}")
  2978	    finally:
  2979	        db.close()
  2980	
  2981	@app.get("/leaderboard/ghin-enhanced")
  2982	async def get_ghin_enhanced_leaderboard(
  2983	    limit: int = Query(100, ge=1, le=100)
  2984	):
  2985	    """Get leaderboard enhanced with GHIN handicap data."""
  2986	    try:
  2987	        db = database.SessionLocal()
  2988	        from .services.ghin_service import GHINService
  2989	        
  2990	        ghin_service = GHINService(db)
  2991	        
  2992	        # Try to initialize GHIN service for fresh data, but continue with stored data if unavailable
  2993	        try:
  2994	            await ghin_service.initialize()
  2995	        except Exception as e:
  2996	            logger.warning(f"GHIN service unavailable, using stored handicap data: {e}")
  2997	        
  2998	        # Always get enhanced leaderboard with stored GHIN data (even if service is offline)
  2999	        enhanced_leaderboard = ghin_service.get_leaderboard_with_ghin_data(limit=limit)
  3000	        
  3001	        return enhanced_leaderboard
  3002	        
  3003	    except Exception as e:
  3004	        logger.error(f"Error getting GHIN enhanced leaderboard: {e}")
  3005	        raise HTTPException(status_code=500, detail=f"Failed to get GHIN enhanced leaderboard: {str(e)}")
  3006	    finally:
  3007	        db.close()
  3008	
  3009	@app.post("/ghin/sync-handicaps")
  3010	async def sync_ghin_handicaps():
  3011	    """Sync handicaps for all players with GHIN IDs."""
  3012	    try:
  3013	        db = database.SessionLocal()
  3014	        from .services.ghin_service import GHINService
  3015	        
  3016	        ghin_service = GHINService(db)
  3017	        
  3018	        # Initialize and check if available
  3019	        await ghin_service.initialize()
  3020	        if not ghin_service.is_available():
  3021	            raise HTTPException(status_code=503, detail="GHIN service not available. Check configuration.")
  3022	        
  3023	        # Sync all player handicaps
  3024	        sync_results = await ghin_service.sync_all_players_handicaps()
  3025	        
  3026	        return {
  3027	            "message": "GHIN handicap sync completed",
  3028	            "results": sync_results
  3029	        }
  3030	        
  3031	    except Exception as e:
  3032	        logger.error(f"Error syncing GHIN handicaps: {e}")
  3033	        raise HTTPException(status_code=500, detail=f"Failed to sync GHIN handicaps: {str(e)}")
  3034	    finally:
  3035	        db.close()
  3036	
  3037	# Advanced Analytics Endpoints
  3038	@app.get("/players/{player_id}/advanced-metrics")
  3039	def get_player_advanced_metrics(player_id: int):
  3040	    """Get advanced performance metrics for a player."""
  3041	    try:
  3042	        db = database.SessionLocal()
  3043	        from .services.statistics_service import StatisticsService
  3044	        
  3045	        stats_service = StatisticsService(db)
  3046	        metrics = stats_service.get_advanced_player_metrics(player_id)
  3047	        
  3048	        return {
  3049	            "player_id": player_id,
  3050	            "metrics": metrics,
  3051	            "generated_at": datetime.now().isoformat()
  3052	        }
  3053	        
  3054	    except Exception as e:
  3055	        logger.error(f"Error getting advanced metrics for player {player_id}: {e}")
  3056	        raise HTTPException(status_code=500, detail=f"Failed to get advanced metrics: {str(e)}")
  3057	    finally:
  3058	        db.close()
  3059	
  3060	@app.get("/players/{player_id}/trends")
  3061	def get_player_trends(
  3062	    player_id: int, 
  3063	    days: int = Query(30, ge=7, le=365, description="Number of days to analyze")
  3064	):
  3065	    """Get performance trends for a player."""
  3066	    try:
  3067	        db = database.SessionLocal()
  3068	        from .services.statistics_service import StatisticsService
  3069	        
  3070	        stats_service = StatisticsService(db)
  3071	        trends = stats_service.get_performance_trends(player_id, days=days)
  3072	        
  3073	        return {
  3074	            "player_id": player_id,
  3075	            "period_days": days,
  3076	            "trends": trends,
  3077	            "generated_at": datetime.now().isoformat()
  3078	        }
  3079	        
  3080	    except Exception as e:
  3081	        logger.error(f"Error getting trends for player {player_id}: {e}")
  3082	        raise HTTPException(status_code=500, detail=f"Failed to get player trends: {str(e)}")
  3083	    finally:
  3084	        db.close()
  3085	
  3086	@app.get("/players/{player_id}/insights")
  3087	def get_player_insights(player_id: int):
  3088	    """Get personalized insights and recommendations for a player."""
  3089	    try:
  3090	        db = database.SessionLocal()
  3091	        from .services.statistics_service import StatisticsService
  3092	        
  3093	        stats_service = StatisticsService(db)
  3094	        insights = stats_service.get_player_insights(player_id)
  3095	        
  3096	        return {
  3097	            "player_id": player_id,
  3098	            "insights": [insight.__dict__ for insight in insights],
  3099	            "generated_at": datetime.now().isoformat()
  3100	        }
  3101	        
  3102	    except Exception as e:
  3103	        logger.error(f"Error getting insights for player {player_id}: {e}")
  3104	        raise HTTPException(status_code=500, detail=f"Failed to get player insights: {str(e)}")
  3105	    finally:
  3106	        db.close()
  3107	
  3108	@app.get("/players/{player_id}/skill-rating")
  3109	def get_player_skill_rating(player_id: int):
  3110	    """Get skill rating for a player."""
  3111	    try:
  3112	        db = database.SessionLocal()
  3113	        from .services.statistics_service import StatisticsService
  3114	        
  3115	        stats_service = StatisticsService(db)
  3116	        rating = stats_service.calculate_skill_rating(player_id)
  3117	        
  3118	        return {
  3119	            "player_id": player_id,
  3120	            "skill_rating": rating,
  3121	            "calculated_at": datetime.now().isoformat()
  3122	        }
  3123	        
  3124	    except Exception as e:
  3125	        logger.error(f"Error getting skill rating for player {player_id}: {e}")
  3126	        raise HTTPException(status_code=500, detail=f"Failed to get skill rating: {str(e)}")
  3127	    finally:
  3128	        db.close()
  3129	
  3130	# Game Result Recording
  3131	@app.post("/game-results")
  3132	def record_game_result(game_result: schemas.GamePlayerResultCreate):
  3133	    """Record a game result for a player."""
  3134	    try:
  3135	        db = database.SessionLocal()
  3136	        from .services.player_service import PlayerService
  3137	        
  3138	        player_service = PlayerService(db)
  3139	        success = player_service.record_game_result(game_result)
  3140	        
  3141	        if not success:
  3142	            raise HTTPException(status_code=500, detail="Failed to record game result")
  3143	        
  3144	        # Check for achievements
  3145	        achievements = player_service.check_and_award_achievements(
  3146	            game_result.player_profile_id, game_result
  3147	        )
  3148	        
  3149	        logger.info(f"Recorded game result for player {game_result.player_profile_id}")
  3150	        
  3151	        return {
  3152	            "message": "Game result recorded successfully",
  3153	            "achievements_earned": achievements
  3154	        }
  3155	        
  3156	    except HTTPException:
  3157	        raise
  3158	    except Exception as e:
  3159	        logger.error(f"Error recording game result: {e}")
  3160	        raise HTTPException(status_code=500, detail=f"Failed to record game result: {str(e)}")
  3161	    finally:
  3162	        db.close()
  3163	
  3164	# Analytics Overview
  3165	@app.get("/analytics/overview")
  3166	def get_analytics_overview():
  3167	    """Get overall analytics overview."""
  3168	    try:
  3169	        db = database.SessionLocal()
  3170	        from .services.statistics_service import StatisticsService
  3171	        
  3172	        stats_service = StatisticsService(db)
  3173	        
  3174	        # Get game mode analytics
  3175	        game_mode_analytics = stats_service.get_game_mode_analytics()
  3176	        
  3177	        # Get basic statistics
  3178	        total_players = db.query(models.PlayerProfile).filter(models.PlayerProfile.is_active == 1).count()
  3179	        total_games = db.query(models.GameRecord).count()
  3180	        active_players = db.query(models.PlayerProfile).filter(
  3181	            and_(models.PlayerProfile.is_active == 1, models.PlayerProfile.last_played.isnot(None))
  3182	        ).count()
  3183	        
  3184	        return {
  3185	            "total_players": total_players,
  3186	            "active_players": active_players,
  3187	            "total_games": total_games,
  3188	            "game_mode_analytics": game_mode_analytics,
  3189	            "generated_at": datetime.now().isoformat()
  3190	        }
  3191	        
  3192	    except Exception as e:
  3193	        logger.error(f"Error getting analytics overview: {e}")
  3194	        raise HTTPException(status_code=500, detail=f"Failed to get analytics overview: {str(e)}")
  3195	    finally:
  3196	        db.close()
  3197	
  3198	# Sheet Integration Endpoints
  3199	@app.post("/sheet-integration/analyze-structure")
  3200	def analyze_sheet_structure(sheet_headers: List[str]):
  3201	    """Analyze Google Sheet headers and create column mappings."""
  3202	    try:
  3203	        db = database.SessionLocal()
  3204	        from .services.sheet_integration_service import SheetIntegrationService
  3205	        
  3206	        sheet_service = SheetIntegrationService(db)
  3207	        mappings = sheet_service.create_column_mappings(sheet_headers)
  3208	        
  3209	        return {
  3210	            "headers_analyzed": len(sheet_headers),
  3211	            "mappings_created": len(mappings),
  3212	            "column_mappings": [
  3213	                {
  3214	                    "sheet_column": mapping.sheet_column,
  3215	                    "db_field": mapping.db_field,
  3216	                    "data_type": mapping.data_type,
  3217	                    "transformation": mapping.transformation
  3218	                }
  3219	                for mapping in mappings
  3220	            ],
  3221	            "analyzed_at": datetime.now().isoformat()
  3222	        }
  3223	        
  3224	    except Exception as e:
  3225	        logger.error(f"Error analyzing sheet structure: {e}")
  3226	        raise HTTPException(status_code=500, detail=f"Failed to analyze sheet structure: {str(e)}")
  3227	    finally:
  3228	        db.close()
  3229	
  3230	@app.post("/sheet-integration/create-leaderboard")
  3231	def create_leaderboard_from_sheet(sheet_data: List[Dict[str, Any]]):
  3232	    """Create a leaderboard from Google Sheet data without persisting to database."""
  3233	    try:
  3234	        db = database.SessionLocal()
  3235	        from .services.sheet_integration_service import SheetIntegrationService
  3236	        
  3237	        if not sheet_data:
  3238	            raise HTTPException(status_code=400, detail="Sheet data is required")
  3239	        
  3240	        # Extract headers from first row
  3241	        headers = list(sheet_data[0].keys())
  3242	        
  3243	        sheet_service = SheetIntegrationService(db)
  3244	        mappings = sheet_service.create_column_mappings(headers)
  3245	        leaderboard = sheet_service.create_leaderboard_from_sheet_data(sheet_data, mappings)
  3246	        
  3247	        return {
  3248	            "leaderboard": leaderboard,
  3249	            "total_players": len(leaderboard),
  3250	            "columns_mapped": len(mappings),
  3251	            "generated_at": datetime.now().isoformat()
  3252	        }
  3253	        
  3254	    except Exception as e:
  3255	        logger.error(f"Error creating leaderboard from sheet: {e}")
  3256	        raise HTTPException(status_code=500, detail=f"Failed to create leaderboard: {str(e)}")
  3257	    finally:
  3258	        db.close()
  3259	
  3260	@app.post("/sheet-integration/sync-data")
  3261	def sync_sheet_data(sheet_data: List[Dict[str, Any]]):
  3262	    """Sync Google Sheet data to database (creates/updates player profiles and statistics)."""
  3263	    try:
  3264	        db = database.SessionLocal()
  3265	        from .services.sheet_integration_service import SheetIntegrationService
  3266	        
  3267	        if not sheet_data:
  3268	            raise HTTPException(status_code=400, detail="Sheet data is required")
  3269	        
  3270	        # Extract headers from first row
  3271	        headers = list(sheet_data[0].keys())
  3272	        
  3273	        sheet_service = SheetIntegrationService(db)
  3274	        mappings = sheet_service.create_column_mappings(headers)
  3275	        results = sheet_service.sync_sheet_data_to_database(sheet_data, mappings)
  3276	        
  3277	        return {
  3278	            "sync_results": results,
  3279	            "synced_at": datetime.now().isoformat()
  3280	        }
  3281	        
  3282	    except Exception as e:
  3283	        logger.error(f"Error syncing sheet data: {e}")
  3284	        raise HTTPException(status_code=500, detail=f"Failed to sync sheet data: {str(e)}")
  3285	    finally:
  3286	        db.close()
  3287	
  3288	@app.get("/sheet-integration/export-current-data")
  3289	def export_current_data_for_sheet(sheet_headers: List[str] = Query(...)):
  3290	    """Export current database data in Google Sheet format for comparison."""
  3291	    try:
  3292	        db = database.SessionLocal()
  3293	        from .services.sheet_integration_service import SheetIntegrationService
  3294	        
  3295	        sheet_service = SheetIntegrationService(db)
  3296	        mappings = sheet_service.create_column_mappings(sheet_headers)
  3297	        exported_data = sheet_service.export_current_data_to_sheet_format(mappings)
  3298	        
  3299	        return {
  3300	            "exported_data": exported_data,
  3301	            "total_players": len(exported_data),
  3302	            "columns": sheet_headers,
  3303	            "exported_at": datetime.now().isoformat()
  3304	        }
  3305	        
  3306	    except Exception as e:
  3307	        logger.error(f"Error exporting current data: {e}")
  3308	        raise HTTPException(status_code=500, detail=f"Failed to export current data: {str(e)}")
  3309	    finally:
  3310	        db.close()
  3311	
  3312	@app.post("/sheet-integration/sync-wgp-sheet")
  3313	async def sync_wgp_sheet_data(request: Dict[str, str]):
  3314	    """Sync Wolf Goat Pig specific sheet data format."""
  3315	    try:
  3316	        db = database.SessionLocal()
  3317	        from .services.player_service import PlayerService
  3318	        from collections import defaultdict
  3319	        import httpx
  3320	        
  3321	        csv_url = request.get("csv_url")
  3322	        if not csv_url:
  3323	            raise HTTPException(status_code=400, detail="CSV URL is required")
  3324	        
  3325	        # Fetch the CSV data (follow redirects for Google Sheets export URLs)
  3326	        async with httpx.AsyncClient(follow_redirects=True) as client:
  3327	            response = await client.get(csv_url, timeout=30)
  3328	            response.raise_for_status()
  3329	        csv_text = response.text
  3330	        
  3331	        # Parse CSV
  3332	        lines = csv_text.strip().split('\n')
  3333	        if not lines:
  3334	            raise HTTPException(status_code=400, detail="Empty sheet data")
  3335	        
  3336	        # Find the actual header row (looking for "Member" column)
  3337	        header_line_index = -1
  3338	        headers = []
  3339	        
  3340	        for i, line in enumerate(lines):
  3341	            temp_headers = [h.strip().strip('"') for h in line.split(',')]
  3342	            # Check if this line contains the actual column headers
  3343	            if any('member' in h.lower() for h in temp_headers if h) and \
  3344	               any('quarters' in h.lower() for h in temp_headers if h):
  3345	                header_line_index = i
  3346	                headers = temp_headers
  3347	                logger.info(f"Found headers at row {i + 1}: {headers}")
  3348	                break
  3349	        
  3350	        if header_line_index == -1:
  3351	            # Fallback: assume headers are in the first non-empty row with multiple values
  3352	            for i, line in enumerate(lines):
  3353	                temp_headers = [h.strip().strip('"') for h in line.split(',')]
  3354	                if len([h for h in temp_headers if h]) >= 3:  # At least 3 non-empty columns
  3355	                    header_line_index = i
  3356	                    headers = temp_headers
  3357	                    logger.info(f"Using row {i + 1} as headers (fallback): {headers}")
  3358	                    break
  3359	        
  3360	        if not headers:
  3361	            raise HTTPException(status_code=400, detail="Could not find valid headers in sheet")
  3362	        
  3363	        # Create header index mapping for flexible column handling
  3364	        header_map = {header.lower(): idx for idx, header in enumerate(headers) if header}
  3365	        
  3366	        # Process each row based on detected columns
  3367	        player_stats = {}
  3368	        
  3369	        # Start processing from the row after headers
  3370	        for line in lines[header_line_index + 1:]:
  3371	            if line.strip():
  3372	                values = [v.strip().strip('"') for v in line.split(',')]
  3373	                
  3374	                # Skip empty rows or rows with too few values
  3375	                if len(values) < 2 or not any(v for v in values[:5]):  # Check first 5 columns
  3376	                    continue
  3377	                
  3378	                # Extract player name (try different column names)
  3379	                player_name = None
  3380	                for name_key in ['member', 'player', 'name', 'golfer']:
  3381	                    if name_key in header_map and header_map[name_key] < len(values):
  3382	                        player_name = values[header_map[name_key]]
  3383	                        break
  3384	                
  3385	                # Skip if no player name, or if it's a header/summary row
  3386	                if not player_name or player_name.lower() in ['member', 'player', 'name', '', 'total', 'average', 'grand total']:
  3387	                    logger.info(f"Skipping non-player row: {player_name}")
  3388	                    continue
  3389	                
  3390	                # Stop if we hit summary sections (like "Most Rounds Played")
  3391	                if any(keyword in player_name.lower() for keyword in ['most rounds', 'top 5', 'best score', 'worst score', 'group size']):
  3392	                    logger.info(f"Stopping at summary section: {player_name}")
  3393	                    break
  3394	                
  3395	                # Initialize player stats if not exists
  3396	                if player_name not in player_stats:
  3397	                    player_stats[player_name] = {
  3398	                        "quarters": 0,
  3399	                        "average": 0,
  3400	                        "rounds": 0,
  3401	                        "qb": 0,
  3402	                        "games_won": 0,
  3403	                        "total_earnings": 0
  3404	                    }
  3405	                
  3406	                # Map the sheet columns to our data model
  3407	                # Score column (total earnings - can be negative)
  3408	                score_value = None
  3409	                for score_key in ['score', 'sum score', 'total score', 'quarters']:
  3410	                    if score_key in header_map and header_map[score_key] < len(values):
  3411	                        score_value = values[header_map[score_key]]
  3412	                        break
  3413	                
  3414	                if score_value and score_value != '':
  3415	                    try:
  3416	                        # Handle negative values (e.g., "-155")
  3417	                        score_int = int(float(score_value))  # Handle decimal values too
  3418	                        # Accumulate total earnings across multiple games
  3419	                        player_stats[player_name]["quarters"] += score_int
  3420	                        player_stats[player_name]["total_earnings"] += float(score_int)
  3421	                        logger.debug(f"Added {score_value} to {player_name}, total now: {player_stats[player_name]['total_earnings']}")
  3422	                    except (ValueError, IndexError) as e:
  3423	                        logger.warning(f"Error parsing score for {player_name}: {e}")
  3424	                        pass
  3425	                
  3426	                # Average column
  3427	                if 'average' in header_map and header_map['average'] < len(values):
  3428	                    try:
  3429	                        avg_value = values[header_map['average']]
  3430	                        if avg_value and avg_value != '':
  3431	                            player_stats[player_name]["average"] = float(avg_value)
  3432	                            logger.debug(f"Set {player_name} average to {avg_value}")
  3433	                    except (ValueError, IndexError) as e:
  3434	                        logger.warning(f"Error parsing average for {player_name}: {e}")
  3435	                        pass
  3436	                
  3437	                # Count rounds/games played (increment for each row)
  3438	                player_stats[player_name]["rounds"] += 1
  3439	                logger.debug(f"Incremented {player_name} rounds to {player_stats[player_name]['rounds']}")
  3440	                
  3441	                # Check if they won this game (positive score)
  3442	                if score_value and score_value != '':
  3443	                    try:
  3444	                        if float(score_value) > 0:
  3445	                            player_stats[player_name]["games_won"] += 1
  3446	                    except (ValueError, TypeError):
  3447	                        pass
  3448	                
  3449	                # QB column
  3450	                if 'qb' in header_map and header_map['qb'] < len(values):
  3451	                    try:
  3452	                        qb_value = values[header_map['qb']]
  3453	                        if qb_value and qb_value != '':
  3454	                            player_stats[player_name]["qb"] = int(qb_value)
  3455	                            logger.debug(f"Set {player_name} QB to {qb_value}")
  3456	                    except (ValueError, IndexError) as e:
  3457	                        logger.warning(f"Error parsing QB for {player_name}: {e}")
  3458	                        pass
  3459	                
  3460	                # Log successful player data extraction
  3461	                if player_stats[player_name]["quarters"] != 0 or player_stats[player_name]["rounds"] > 0:
  3462	                    logger.info(f"Extracted data for {player_name}: {player_stats[player_name]}")
  3463	        
  3464	        # Calculate averages for all players after processing all rows
  3465	        for player_name, stats in player_stats.items():
  3466	            if stats["rounds"] > 0:
  3467	                stats["average"] = stats["total_earnings"] / stats["rounds"]
  3468	                logger.debug(f"Calculated average for {player_name}: {stats['average']}")
  3469	        
  3470	        # Create/update players in database
  3471	        player_service = PlayerService(db)
  3472	        sync_results = {
  3473	            "players_processed": 0,
  3474	            "players_created": 0,
  3475	            "players_updated": 0,
  3476	            "errors": []
  3477	        }
  3478	        
  3479	        # Track GHIN data for response payload
  3480	        ghin_data_collection = {}
  3481	        
  3482	        for player_name, stats in player_stats.items():
  3483	            try:
  3484	                # Check if player exists
  3485	                existing_player = db.query(models.PlayerProfile).filter(
  3486	                    models.PlayerProfile.name == player_name
  3487	                ).first()
  3488	                
  3489	                if not existing_player:
  3490	                    # Create new player
  3491	                    player_data = schemas.PlayerProfileCreate(
  3492	                        name=player_name,
  3493	                        handicap=10.0,  # Default handicap
  3494	                        email=f"{player_name.lower().replace(' ', '.')}@wgp.com"
  3495	                    )
  3496	                    new_player = player_service.create_player_profile(player_data)
  3497	                    sync_results["players_created"] += 1
  3498	                    player_id = new_player.id
  3499	                else:
  3500	                    player_id = existing_player.id
  3501	                    sync_results["players_updated"] += 1
  3502	                
  3503	                # Update or create statistics record
  3504	                player_stats_record = db.query(models.PlayerStatistics).filter(
  3505	                    models.PlayerStatistics.player_id == player_id
  3506	                ).first()
  3507	                
  3508	                if not player_stats_record:
  3509	                    # Create new statistics record
  3510	                    player_stats_record = models.PlayerStatistics(player_id=player_id)
  3511	                    db.add(player_stats_record)
  3512	                
  3513	                # Update statistics with sheet data
  3514	                player_stats_record.games_played = stats.get("rounds", 0)
  3515	                player_stats_record.total_earnings = stats.get("total_earnings", 0)
  3516	                
  3517	                # Calculate win percentage based on average earnings per game
  3518	                if stats.get("rounds", 0) > 0 and stats.get("average", 0) > 0:
  3519	                    # If average is positive, estimate wins based on that
  3520	                    # Assuming positive average means winning more often
  3521	                    estimated_win_rate = min(100, max(0, (stats.get("average", 0) + 50) / 100 * 50))
  3522	                    player_stats_record.win_percentage = estimated_win_rate
  3523	                    player_stats_record.games_won = int(stats.get("rounds", 0) * estimated_win_rate / 100)
  3524	                else:
  3525	                    player_stats_record.win_percentage = 0
  3526	                    player_stats_record.games_won = 0
  3527	                
  3528	                # Store additional metrics
  3529	                player_stats_record.avg_earnings_per_game = stats.get("average", 0)
  3530	                
  3531	                # Update timestamp
  3532	                player_stats_record.last_updated = datetime.now().isoformat()
  3533	                
  3534	                # Try to fetch GHIN data if player has GHIN ID
  3535	                ghin_data = None
  3536	                if existing_player and existing_player.ghin_id:
  3537	                    try:
  3538	                        from .services.ghin_service import GHINService
  3539	                        ghin_service = GHINService(db)
  3540	                        
  3541	                        # Check if GHIN service is available
  3542	                        if await ghin_service.initialize():
  3543	                            ghin_data = await ghin_service.sync_player_handicap(player_id)
  3544	                            if ghin_data:
  3545	                                # Update handicap from GHIN
  3546	                                existing_player.handicap = ghin_data.get('handicap_index', existing_player.handicap)
  3547	                                logger.info(f"Updated GHIN data for {player_name}: handicap={ghin_data.get('handicap_index')}")
  3548	                        else:
  3549	                            # Fall back to stored GHIN data
  3550	                            ghin_data = ghin_service.get_player_ghin_data(player_id)
  3551	                            if ghin_data:
  3552	                                logger.info(f"Using stored GHIN data for {player_name}")
  3553	                    except Exception as ghin_error:
  3554	                        logger.warning(f"Failed to fetch GHIN data for {player_name}: {ghin_error}")
  3555	                
  3556	                # Store GHIN data for response payload
  3557	                if ghin_data:
  3558	                    ghin_data_collection[player_name] = {
  3559	                        "ghin_id": ghin_data.get("ghin_id"),
  3560	                        "current_handicap": ghin_data.get("current_handicap"),
  3561	                        "recent_scores": ghin_data.get("recent_scores", [])[:5],  # Last 5 scores
  3562	                        "last_updated": ghin_data.get("last_updated")
  3563	                    }
  3564	                
  3565	                db.commit()
  3566	                
  3567	                sync_results["players_processed"] += 1
  3568	                
  3569	            except Exception as e:
  3570	                sync_results["errors"].append(f"Error processing {player_name}: {str(e)}")
  3571	                continue
  3572	        
  3573	        # Log summary of synced data
  3574	        logger.info(f"Synced {len(player_stats)} players from sheet")
  3575	        logger.info(f"Sync results: {sync_results}")
  3576	        
  3577	        # Return detailed sync information including the data that was synced
  3578	        return {
  3579	            "sync_results": sync_results,
  3580	            "player_count": len(player_stats),
  3581	            "synced_at": datetime.now().isoformat(),
  3582	            "headers_found": headers,
  3583	            "players_synced": list(player_stats.keys()),
  3584	            "sample_data": {name: stats for name, stats in list(player_stats.items())[:3]},  # First 3 players as sample
  3585	            "ghin_data": ghin_data_collection,  # GHIN scores and handicap data
  3586	            "ghin_players_count": len(ghin_data_collection)
  3587	        }
  3588	        
  3589	    except httpx.RequestError as e:
  3590	        logger.error(f"Error fetching Google Sheet: {e}")
  3591	        raise HTTPException(status_code=400, detail=f"Failed to fetch sheet: {str(e)}")
  3592	    except Exception as e:
  3593	        logger.error(f"Error syncing WGP sheet data: {e}")
  3594	        raise HTTPException(status_code=500, detail=f"Failed to sync data: {str(e)}")
  3595	    finally:
  3596	        db.close()
  3597	
  3598	# Admin endpoints for email configuration
  3599	@app.get("/admin/email-config")
  3600	def get_email_config(x_admin_email: str = Header(None)):
  3601	    """Get current email configuration (admin only)"""
  3602	    # Check admin access
  3603	    admin_emails = ['stuagano@gmail.com', 'admin@wgp.com']
  3604	    if not x_admin_email or x_admin_email not in admin_emails:
  3605	        raise HTTPException(status_code=403, detail="Admin access required")
  3606	    
  3607	    # Return current config (without password)
  3608	    return {
  3609	        "config": {
  3610	            "smtp_host": os.getenv("SMTP_HOST", "smtp.gmail.com"),
  3611	            "smtp_port": os.getenv("SMTP_PORT", "587"),
  3612	            "smtp_username": os.getenv("SMTP_USER", ""),
  3613	            "from_email": os.getenv("FROM_EMAIL", ""),
  3614	            "from_name": os.getenv("FROM_NAME", "Wolf Goat Pig Admin"),
  3615	            # Don't return password
  3616	            "smtp_password": "â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" if os.getenv("SMTP_PASSWORD") else ""
  3617	        }
  3618	    }
  3619	
  3620	@app.post("/admin/email-config")
  3621	def update_email_config(config: Dict[str, Any], x_admin_email: str = Header(None)):
  3622	    """Update email configuration (admin only)"""
  3623	    # Check admin access
  3624	    admin_emails = ['stuagano@gmail.com', 'admin@wgp.com']
  3625	    if not x_admin_email or x_admin_email not in admin_emails:
  3626	        raise HTTPException(status_code=403, detail="Admin access required")
  3627	    
  3628	    try:
  3629	        # Update environment variables (in memory for this session)
  3630	        if config.get("smtp_host"):
  3631	            os.environ["SMTP_HOST"] = config["smtp_host"]
  3632	        if config.get("smtp_port"):
  3633	            os.environ["SMTP_PORT"] = str(config["smtp_port"])
  3634	        if config.get("smtp_username"):
  3635	            os.environ["SMTP_USER"] = config["smtp_username"]
  3636	        if config.get("smtp_password") and not config["smtp_password"].startswith("â€¢"):
  3637	            os.environ["SMTP_PASSWORD"] = config["smtp_password"]
  3638	        if config.get("from_email"):
  3639	            os.environ["FROM_EMAIL"] = config["from_email"]
  3640	        if config.get("from_name"):
  3641	            os.environ["FROM_NAME"] = config["from_name"]
  3642	        
  3643	        # Reinitialize email service with new config
  3644	        global email_service_instance
  3645	        email_service_instance = None  # Reset to force reinitialization
  3646	        
  3647	        return {"status": "success", "message": "Email configuration updated"}
  3648	    except Exception as e:
  3649	        logger.error(f"Error updating email config: {e}")
  3650	        raise HTTPException(status_code=500, detail=str(e))
  3651	
  3652	@app.post("/admin/test-email")
  3653	async def test_admin_email(request: Dict[str, Any], x_admin_email: str = Header(None)):
  3654	    """Send a test email with provided configuration (admin only)"""
  3655	    # Check admin access
  3656	    admin_emails = ['stuagano@gmail.com', 'admin@wgp.com']
  3657	    if not x_admin_email or x_admin_email not in admin_emails:
  3658	        raise HTTPException(status_code=403, detail="Admin access required")
  3659	    
  3660	    try:
  3661	        test_email = request.get("test_email")
  3662	        config = request.get("config", {})
  3663	        
  3664	        if not test_email:
  3665	            raise HTTPException(status_code=400, detail="Test email address required")
  3666	        
  3667	        # Temporarily apply config if provided
  3668	        if config:
  3669	            # Save current values
  3670	            old_config = {
  3671	                "SMTP_HOST": os.getenv("SMTP_HOST"),
  3672	                "SMTP_PORT": os.getenv("SMTP_PORT"),
  3673	                "SMTP_USER": os.getenv("SMTP_USER"),
  3674	                "SMTP_PASSWORD": os.getenv("SMTP_PASSWORD"),
  3675	                "FROM_EMAIL": os.getenv("FROM_EMAIL"),
  3676	                "FROM_NAME": os.getenv("FROM_NAME")
  3677	            }
  3678	            
  3679	            # Apply test config
  3680	            if config.get("smtp_host"):
  3681	                os.environ["SMTP_HOST"] = config["smtp_host"]
  3682	            if config.get("smtp_port"):
  3683	                os.environ["SMTP_PORT"] = str(config["smtp_port"])
  3684	            if config.get("smtp_username"):
  3685	                os.environ["SMTP_USER"] = config["smtp_username"]
  3686	            if config.get("smtp_password") and not config["smtp_password"].startswith("â€¢"):
  3687	                os.environ["SMTP_PASSWORD"] = config["smtp_password"]
  3688	            if config.get("from_email"):
  3689	                os.environ["FROM_EMAIL"] = config["from_email"]
  3690	            if config.get("from_name"):
  3691	                os.environ["FROM_NAME"] = config["from_name"]
  3692	        
  3693	        # Create new email service with test config
  3694	        from .services.email_service import EmailService
  3695	        test_service = EmailService()
  3696	        
  3697	        if not test_service.is_configured:
  3698	            raise HTTPException(
  3699	                status_code=400,
  3700	                detail="Email service not configured. Please provide SMTP settings."
  3701	            )
  3702	        
  3703	        # Send test email
  3704	        success = test_service.send_test_email(
  3705	            to_email=test_email,
  3706	            admin_name=x_admin_email
  3707	        )
  3708	        
  3709	        # Restore original config if we changed it
  3710	        if config and 'old_config' in locals():
  3711	            for key, value in old_config.items():
  3712	                if value is not None:
  3713	                    os.environ[key] = value
  3714	                elif key in os.environ:
  3715	                    del os.environ[key]
  3716	        
  3717	        if success:
  3718	            return {"status": "success", "message": f"Test email sent to {test_email}"}
  3719	        else:
  3720	            raise HTTPException(status_code=500, detail="Failed to send test email")
  3721	            
  3722	    except HTTPException:
  3723	        raise
  3724	    except Exception as e:
  3725	        logger.error(f"Error sending test email: {e}")
  3726	        raise HTTPException(status_code=500, detail=str(e))
  3727	
  3728	# OAuth2 Email endpoints
  3729	@app.get("/admin/oauth2-status")
  3730	def get_oauth2_status(x_admin_email: str = Header(None)):
  3731	    """Get OAuth2 configuration status (admin only)"""
  3732	    # Check admin access
  3733	    admin_emails = ['stuagano@gmail.com', 'admin@wgp.com']
  3734	    if not x_admin_email or x_admin_email not in admin_emails:
  3735	        raise HTTPException(status_code=403, detail="Admin access required")
  3736	    
  3737	    try:
  3738	        oauth2_service = get_oauth2_email_service()
  3739	        status = oauth2_service.get_configuration_status()
  3740	        return {"status": status}
  3741	    except Exception as e:
  3742	        logger.error(f"Error getting OAuth2 status: {e}")
  3743	        raise HTTPException(status_code=500, detail=str(e))
  3744	
  3745	@app.post("/admin/oauth2-authorize")
  3746	def start_oauth2_authorization(request: Dict[str, Any], x_admin_email: str = Header(None)):
  3747	    """Start OAuth2 authorization flow (admin only)"""
  3748	    # Check admin access
  3749	    admin_emails = ['stuagano@gmail.com', 'admin@wgp.com']
  3750	    if not x_admin_email or x_admin_email not in admin_emails:
  3751	        raise HTTPException(status_code=403, detail="Admin access required")
  3752	    
  3753	    try:
  3754	        oauth2_service = get_oauth2_email_service()
  3755	        
  3756	        # Set from_email and from_name if provided
  3757	        if request.get("from_email"):
  3758	            oauth2_service.from_email = request["from_email"]
  3759	            os.environ["FROM_EMAIL"] = request["from_email"]
  3760	        if request.get("from_name"):
  3761	            oauth2_service.from_name = request["from_name"]
  3762	            os.environ["FROM_NAME"] = request["from_name"]
  3763	        
  3764	        # Let the service auto-detect the correct redirect URI
  3765	        # The redirect URI should point to the backend API, not the frontend
  3766	        auth_url = oauth2_service.get_auth_url()
  3767	        
  3768	        return {"auth_url": auth_url, "message": "Visit the auth_url to complete authorization"}
  3769	        
  3770	    except FileNotFoundError as e:
  3771	        raise HTTPException(
  3772	            status_code=400,
  3773	            detail="Gmail credentials file not found. Please upload your Gmail API credentials file first."
  3774	        )
  3775	    except Exception as e:
  3776	        logger.error(f"Error starting OAuth2 authorization: {e}")
  3777	        raise HTTPException(status_code=500, detail=str(e))
  3778	
  3779	@app.get("/admin/oauth2-callback")
  3780	def handle_oauth2_callback(code: str = Query(...), state: str = Query(None)):
  3781	    """Handle OAuth2 callback from Google"""
  3782	    try:
  3783	        oauth2_service = get_oauth2_email_service()
  3784	        success = oauth2_service.handle_oauth_callback(code)
  3785	        
  3786	        if success:
  3787	            # Return HTML page that will close the window and notify the parent
  3788	            html_content = """
  3789	            <!DOCTYPE html>
  3790	            <html>
  3791	            <head>
  3792	                <title>OAuth2 Authorization Complete</title>
  3793	                <style>
  3794	                    body {
  3795	                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
  3796	                        display: flex;
  3797	                        justify-content: center;
  3798	                        align-items: center;
  3799	                        height: 100vh;
  3800	                        margin: 0;
  3801	                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  3802	                    }
  3803	                    .container {
  3804	                        background: white;
  3805	                        padding: 40px;
  3806	                        border-radius: 10px;
  3807	                        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
  3808	                        text-align: center;
  3809	                        max-width: 400px;
  3810	                    }
  3811	                    h1 {
  3812	                        color: #4CAF50;
  3813	                        margin-bottom: 20px;
  3814	                    }
  3815	                    p {
  3816	                        color: #666;
  3817	                        margin-bottom: 20px;
  3818	                    }
  3819	                    .spinner {
  3820	                        border: 3px solid #f3f3f3;
  3821	                        border-top: 3px solid #4CAF50;
  3822	                        border-radius: 50%;
  3823	                        width: 40px;
  3824	                        height: 40px;
  3825	                        animation: spin 1s linear infinite;
  3826	                        margin: 20px auto;
  3827	                    }
  3828	                    @keyframes spin {
  3829	                        0% { transform: rotate(0deg); }
  3830	                        100% { transform: rotate(360deg); }
  3831	                    }
  3832	                </style>
  3833	            </head>
  3834	            <body>
  3835	                <div class="container">
  3836	                    <h1>âœ… Authorization Successful!</h1>
  3837	                    <p>OAuth2 authorization has been completed successfully.</p>
  3838	                    <div class="spinner"></div>
  3839	                    <p>This window will close automatically...</p>
  3840	                </div>
  3841	                <script>
  3842	                    // Notify parent window if it exists
  3843	                    if (window.opener) {
  3844	                        window.opener.postMessage({ type: 'oauth2-success' }, '*');
  3845	                    }
  3846	                    // Close window after 2 seconds
  3847	                    setTimeout(() => {
  3848	                        window.close();
  3849	                    }, 2000);
  3850	                </script>
  3851	            </body>
  3852	            </html>
  3853	            """
  3854	            return HTMLResponse(content=html_content, status_code=200)
  3855	        else:
  3856	            # Return error HTML page
  3857	            html_content = """
  3858	            <!DOCTYPE html>
  3859	            <html>
  3860	            <head>
  3861	                <title>OAuth2 Authorization Failed</title>
  3862	                <style>
  3863	                    body {
  3864	                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  3865	                        display: flex;
  3866	                        justify-content: center;
  3867	                        align-items: center;
  3868	                        height: 100vh;
  3869	                        margin: 0;
  3870	                        background: linear-gradient(135deg, #f5576c 0%, #f093fb 100%);
  3871	                    }
  3872	                    .container {
  3873	                        background: white;
  3874	                        padding: 40px;
  3875	                        border-radius: 10px;
  3876	                        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
  3877	                        text-align: center;
  3878	                        max-width: 400px;
  3879	                    }
  3880	                    h1 {
  3881	                        color: #f44336;
  3882	                        margin-bottom: 20px;
  3883	                    }
  3884	                    p {
  3885	                        color: #666;
  3886	                    }
  3887	                </style>
  3888	            </head>
  3889	            <body>
  3890	                <div class="container">
  3891	                    <h1>âŒ Authorization Failed</h1>
  3892	                    <p>Failed to complete OAuth2 authorization.</p>
  3893	                    <p>Please close this window and try again.</p>
  3894	                </div>
  3895	            </body>
  3896	            </html>
  3897	            """
  3898	            return HTMLResponse(content=html_content, status_code=400)
  3899	            
  3900	    except Exception as e:
  3901	        logger.error(f"Error handling OAuth2 callback: {e}")
  3902	        # Return error HTML page
  3903	        html_content = f"""
  3904	        <!DOCTYPE html>
  3905	        <html>
  3906	        <head>
  3907	            <title>OAuth2 Error</title>
  3908	            <style>
  3909	                body {{
  3910	                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  3911	                    display: flex;
  3912	                    justify-content: center;
  3913	                    align-items: center;
  3914	                    height: 100vh;
  3915	                    margin: 0;
  3916	                    background: linear-gradient(135deg, #f5576c 0%, #f093fb 100%);
  3917	                }}
  3918	                .container {{
  3919	                    background: white;
  3920	                    padding: 40px;
  3921	                    border-radius: 10px;
  3922	                    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
  3923	                    text-align: center;
  3924	                    max-width: 400px;
  3925	                }}
  3926	                h1 {{
  3927	                    color: #f44336;
  3928	                    margin-bottom: 20px;
  3929	                }}
  3930	                p {{
  3931	                    color: #666;
  3932	                    margin-bottom: 10px;
  3933	                }}
  3934	                .error {{
  3935	                    background: #ffebee;
  3936	                    color: #c62828;
  3937	                    padding: 10px;
  3938	                    border-radius: 5px;
  3939	                    margin-top: 20px;
  3940	                    font-family: monospace;
  3941	                    font-size: 12px;
  3942	                }}
  3943	            </style>
  3944	        </head>
  3945	        <body>
  3946	            <div class="container">
  3947	                <h1>âŒ OAuth2 Error</h1>
  3948	                <p>An error occurred during OAuth2 authorization.</p>
  3949	                <div class="error">{str(e)}</div>
  3950	                <p>Please close this window and try again.</p>
  3951	            </div>
  3952	        </body>
  3953	        </html>
  3954	        """
  3955	        return HTMLResponse(content=html_content, status_code=500)
  3956	
  3957	@app.post("/admin/oauth2-test-email")
  3958	async def test_oauth2_email(request: Dict[str, Any], x_admin_email: str = Header(None)):
  3959	    """Send test email using OAuth2 (admin only)"""
  3960	    # Check admin access
  3961	    admin_emails = ['stuagano@gmail.com', 'admin@wgp.com']
  3962	    if not x_admin_email or x_admin_email not in admin_emails:
  3963	        raise HTTPException(status_code=403, detail="Admin access required")
  3964	    
  3965	    try:
  3966	        test_email = request.get("test_email")
  3967	        if not test_email:
  3968	            raise HTTPException(status_code=400, detail="Test email address required")
  3969	        
  3970	        oauth2_service = get_oauth2_email_service()
  3971	        
  3972	        if not oauth2_service.is_configured:
  3973	            raise HTTPException(
  3974	                status_code=400,
  3975	                detail="OAuth2 email service not configured. Please complete OAuth2 authorization first."
  3976	            )
  3977	        
  3978	        success = oauth2_service.send_test_email(test_email, x_admin_email)
  3979	        
  3980	        if success:
  3981	            return {"status": "success", "message": f"Test email sent to {test_email} using OAuth2"}
  3982	        else:
  3983	            raise HTTPException(status_code=500, detail="Failed to send test email")
  3984	            
  3985	    except HTTPException:
  3986	        raise
  3987	    except Exception as e:
  3988	        logger.error(f"Error sending OAuth2 test email: {e}")
  3989	        raise HTTPException(status_code=500, detail=str(e))
  3990	
  3991	@app.post("/admin/upload-credentials")
  3992	async def upload_gmail_credentials(file: UploadFile = File(...), x_admin_email: str = Header(None)):
  3993	    """Upload Gmail API credentials file (admin only)"""
  3994	    # Check admin access
  3995	    admin_emails = ['stuagano@gmail.com', 'admin@wgp.com']
  3996	    if not x_admin_email or x_admin_email not in admin_emails:
  3997	        raise HTTPException(status_code=403, detail="Admin access required")
  3998	    
  3999	    try:
  4000	        # Validate file type
  4001	        if not file.filename.endswith('.json'):
  4002	            raise HTTPException(status_code=400, detail="File must be a JSON file")
  4003	        
  4004	        # Read and validate JSON content
  4005	        content = await file.read()
  4006	        credentials_data = json.loads(content)
  4007	        
  4008	        # Validate it's a Google OAuth2 credentials file
  4009	        if 'installed' not in credentials_data and 'web' not in credentials_data:
  4010	            raise HTTPException(
  4011	                status_code=400,
  4012	                detail="Invalid credentials file format. Please ensure it's a Google OAuth2 credentials file."
  4013	            )
  4014	        
  4015	        # Save credentials file
  4016	        oauth2_service = get_oauth2_email_service()
  4017	        with open(oauth2_service.credentials_path, 'w') as f:
  4018	            json.dump(credentials_data, f)
  4019	        
  4020	        return {"status": "success", "message": "Gmail credentials file uploaded successfully"}
  4021	        
  4022	    except json.JSONDecodeError:
  4023	        raise HTTPException(status_code=400, detail="Invalid JSON file")
  4024	    except HTTPException:
  4025	        raise
  4026	    except Exception as e:
  4027	        logger.error(f"Error uploading credentials: {e}")
  4028	        raise HTTPException(status_code=500, detail=str(e))
  4029	
  4030	@app.post("/sheet-integration/fetch-google-sheet")
  4031	async def fetch_google_sheet(request: Dict[str, str]):
  4032	    """Fetch data from a Google Sheets CSV URL."""
  4033	    try:
  4034	        import httpx
  4035	        csv_url = request.get("csv_url")
  4036	        if not csv_url:
  4037	            raise HTTPException(status_code=400, detail="CSV URL is required")
  4038	        
  4039	        # Fetch the CSV data from Google Sheets (follow redirects)
  4040	        async with httpx.AsyncClient(follow_redirects=True) as client:
  4041	            response = await client.get(csv_url, timeout=30)
  4042	            response.raise_for_status()
  4043	        
  4044	        csv_text = response.text
  4045	        
  4046	        # Parse CSV data
  4047	        lines = csv_text.strip().split('\n')
  4048	        if not lines:
  4049	            raise HTTPException(status_code=400, detail="Empty sheet data")
  4050	        
  4051	        headers = [h.strip().strip('"') for h in lines[0].split(',')]
  4052	        data = []
  4053	        
  4054	        for line in lines[1:]:
  4055	            if line.strip():
  4056	                values = [v.strip().strip('"') for v in line.split(',')]
  4057	                row = {}
  4058	                for i, header in enumerate(headers):
  4059	                    row[header] = values[i] if i < len(values) else ''
  4060	                data.append(row)
  4061	        
  4062	        return {
  4063	            "headers": headers,
  4064	            "data": data,
  4065	            "total_rows": len(data),
  4066	            "fetched_at": datetime.now().isoformat()
  4067	        }
  4068	        
  4069	    except httpx.RequestError as e:
  4070	        logger.error(f"Error fetching Google Sheet: {e}")
  4071	        raise HTTPException(status_code=400, detail=f"Failed to fetch sheet: {str(e)}")
  4072	    except Exception as e:
  4073	        logger.error(f"Error processing Google Sheet data: {e}")
  4074	        raise HTTPException(status_code=500, detail=f"Failed to process sheet data: {str(e)}")
  4075	
  4076	@app.post("/sheet-integration/compare-data")
  4077	def compare_sheet_with_database(sheet_data: List[Dict[str, Any]]):
  4078	    """Compare Google Sheet data with current database data."""
  4079	    try:
  4080	        db = database.SessionLocal()
  4081	        from .services.sheet_integration_service import SheetIntegrationService
  4082	        
  4083	        if not sheet_data:
  4084	            raise HTTPException(status_code=400, detail="Sheet data is required")
  4085	        
  4086	        # Extract headers from first row
  4087	        headers = list(sheet_data[0].keys())
  4088	        
  4089	        sheet_service = SheetIntegrationService(db)
  4090	        mappings = sheet_service.create_column_mappings(headers)
  4091	        
  4092	        # Get current database data in sheet format
  4093	        current_data = sheet_service.export_current_data_to_sheet_format(mappings)
  4094	        
  4095	        # Generate comparison report
  4096	        comparison_report = sheet_service.generate_sheet_comparison_report(
  4097	            current_data, sheet_data, mappings
  4098	        )
  4099	        
  4100	        return {
  4101	            "comparison_report": comparison_report,
  4102	            "compared_at": datetime.now().isoformat()
  4103	        }
  4104	        
  4105	    except Exception as e:
  4106	        logger.error(f"Error comparing sheet data: {e}")
  4107	        raise HTTPException(status_code=500, detail=f"Failed to compare data: {str(e)}")
  4108	    finally:
  4109	        db.close()
  4110	
  4111	# ============================================================================
  4112	# SIMULATION API ENDPOINTS
  4113	# ============================================================================
  4114	
  4115	# Request/Response models for simulation endpoints
  4116	class SimulationSetupRequest(BaseModel):
  4117	    """Request model for simulation setup"""
  4118	    players: List[Dict[str, Any]]
  4119	    course_id: Optional[int] = None
  4120	    computer_players: Optional[List[str]] = []
  4121	    personalities: Optional[List[str]] = []
  4122	    game_options: Optional[Dict[str, Any]] = {}
  4123	
  4124	class SimulationPlayShotRequest(BaseModel):
  4125	    """Request model for playing next shot"""
  4126	    decision: Optional[Dict[str, Any]] = {}
  4127	
  4128	class SimulationPlayHoleRequest(BaseModel):
  4129	    """Request model for hole simulation decision"""
  4130	    decision: Dict[str, Any]
  4131	
  4132	class BettingDecisionRequest(BaseModel):
  4133	    """Request model for betting decisions"""
  4134	    decision: Dict[str, Any]
  4135	
  4136	
  4137	def _get_current_hole_state():
  4138	    """Safely fetch the current hole state from the active simulation."""
  4139	    if not wgp_simulation:
  4140	        return None
  4141	    return wgp_simulation.hole_states.get(wgp_simulation.current_hole)
  4142	
  4143	
  4144	def _get_default_player_id(preferred_role: str = "captain") -> Optional[str]:
  4145	    """
  4146	    Provide a sensible default player identifier for legacy API calls that
  4147	    don't explicitly include a player context.
  4148	    """
  4149	    hole_state = _get_current_hole_state()
  4150	    if hole_state and getattr(hole_state, "teams", None):
  4151	        if preferred_role == "captain" and getattr(hole_state.teams, "captain", None):
  4152	            return hole_state.teams.captain
  4153	        if preferred_role == "solo" and getattr(hole_state.teams, "solo_player", None):
  4154	            return hole_state.teams.solo_player
  4155	
  4156	    if wgp_simulation and getattr(wgp_simulation, "players", None):
  4157	        for player in wgp_simulation.players:
  4158	            if player.id == "human":
  4159	                return player.id
  4160	        return wgp_simulation.players[0].id if wgp_simulation.players else None
  4161	    return None
  4162	
  4163	
  4164	def _get_opposing_team_id(reference_player_id: Optional[str] = None) -> str:
  4165	    """
  4166	    Determine the opposing team identifier for double responses.
  4167	    Falls back to generic label when team structure is not yet established.
  4168	    """
  4169	    hole_state = _get_current_hole_state()
  4170	    if not hole_state or not getattr(hole_state, "teams", None):
  4171	        return "opponents"
  4172	
  4173	    if hole_state.teams.type == "partners":
  4174	        team1 = set(hole_state.teams.team1 or [])
  4175	        team2 = set(hole_state.teams.team2 or [])
  4176	
  4177	        if reference_player_id and reference_player_id in team1:
  4178	            return "team2"
  4179	        if reference_player_id and reference_player_id in team2:
  4180	            return "team1"
  4181	        return "team2" if team1 else "opponents"
  4182	
  4183	    return "opponents"
  4184	
  4185	
  4186	def _get_pending_partnership_request() -> Dict[str, Any]:
  4187	    """Return any pending partnership request details from the current hole."""
  4188	    hole_state = _get_current_hole_state()
  4189	    if hole_state and getattr(hole_state, "teams", None):
  4190	        return hole_state.teams.pending_request or {}
  4191	    return {}
  4192	
  4193	
  4194	def _normalize_probabilities(probabilities: Dict[str, float]) -> Dict[str, float]:
  4195	    """Normalize probability buckets so they sum to ~1.0 and clamp negatives."""
  4196	    safe_probs = {k: max(0.0, float(v)) for k, v in probabilities.items()}
  4197	    total = sum(safe_probs.values())
  4198	    if total <= 0:
  4199	        bucket_count = len(safe_probs)
  4200	        if bucket_count == 0:
  4201	            return {}
  4202	        equal_share = 1.0 / bucket_count
  4203	        return {k: equal_share for k in safe_probs}
  4204	    return {k: v / total for k, v in safe_probs.items()}
  4205	
  4206	
  4207	def _compute_shot_probabilities(
  4208	    player_stats: Optional[Dict[str, Any]] = None,
  4209	    hole_info: Optional[Dict[str, Any]] = None,
  4210	    lie_type: Optional[str] = None
  4211	) -> Dict[str, float]:
  4212	    """Generate a balanced shot probability distribution based on context."""
  4213	    player_stats = player_stats or {}
  4214	    hole_info = hole_info or {}
  4215	    lie_type = (lie_type or hole_info.get("lie_type") or "").lower()
  4216	
  4217	    base_distribution = {
  4218	        "excellent": 0.18,
  4219	        "good": 0.32,
  4220	        "average": 0.30,
  4221	        "poor": 0.15,
  4222	        "disaster": 0.05,
  4223	    }
  4224	
  4225	    handicap = float(player_stats.get("handicap", 18) or 18)
  4226	    skill_delta = max(min((18 - handicap) / 40.0, 0.2), -0.2)
  4227	    base_distribution["excellent"] += skill_delta
  4228	    base_distribution["good"] += skill_delta * 0.5
  4229	    base_distribution["poor"] -= abs(skill_delta) * 0.4
  4230	    base_distribution["disaster"] = max(0.02, base_distribution["disaster"] - skill_delta * 0.3)
  4231	
  4232	    difficulty = str(hole_info.get("difficulty", "medium")).lower()
  4233	    if difficulty in {"hard", "very hard", "difficult"}:
  4234	        base_distribution["excellent"] *= 0.75
  4235	        base_distribution["good"] *= 0.85
  4236	        base_distribution["poor"] *= 1.2
  4237	        base_distribution["disaster"] *= 1.3
  4238	    elif difficulty in {"easy", "very easy"}:
  4239	        base_distribution["excellent"] *= 1.15
  4240	        base_distribution["good"] *= 1.05
  4241	        base_distribution["poor"] *= 0.85
  4242	        base_distribution["disaster"] *= 0.75
  4243	
  4244	    distance = hole_info.get("distance") or hole_info.get("distance_to_pin")
  4245	    if isinstance(distance, (int, float)):
  4246	        if distance < 100:
  4247	            base_distribution["excellent"] *= 1.1
  4248	            base_distribution["good"] *= 1.05
  4249	            base_distribution["poor"] *= 0.9
  4250	        elif distance > 200:
  4251	            base_distribution["excellent"] *= 0.85
  4252	            base_distribution["good"] *= 0.9
  4253	            base_distribution["poor"] *= 1.1
  4254	            base_distribution["disaster"] *= 1.15
  4255	
  4256	    if lie_type in {"tee"}:
  4257	        base_distribution["excellent"] *= 1.2
  4258	        base_distribution["good"] *= 1.1
  4259	        base_distribution["poor"] *= 0.8
  4260	        base_distribution["disaster"] *= 0.6
  4261	    elif lie_type in {"rough", "deep_rough"}:
  4262	        base_distribution["excellent"] *= 0.7
  4263	        base_distribution["good"] *= 0.8
  4264	        base_distribution["poor"] *= 1.2
  4265	        base_distribution["disaster"] *= 1.3
  4266	    elif lie_type in {"bunker"}:
  4267	        base_distribution["excellent"] *= 0.6
  4268	        base_distribution["good"] *= 0.75
  4269	        base_distribution["poor"] *= 1.25
  4270	        base_distribution["disaster"] *= 1.4
  4271	    elif lie_type in {"green"}:
  4272	        base_distribution["excellent"] *= 1.4
  4273	        base_distribution["good"] *= 1.15
  4274	        base_distribution["poor"] *= 0.6
  4275	        base_distribution["disaster"] *= 0.4
  4276	
  4277	    return _normalize_probabilities(base_distribution)
  4278	
  4279	@app.post("/simulation/setup")
  4280	def setup_simulation(request: Dict[str, Any]):
  4281	    """Initialize a new simulation with specified players and configuration"""
  4282	    global wgp_simulation
  4283	    
  4284	    try:
  4285	        logger.info("Setting up new simulation...")
  4286	        
  4287	        # Handle both old and new request formats
  4288	        if 'human_player' in request and 'computer_players' in request:
  4289	            # Frontend format: { human_player, computer_players, course_name }
  4290	            human_player = request['human_player']
  4291	            computer_players = request['computer_players']
  4292	            course_name = request.get('course_name')
  4293	            
  4294	            # Combine into players list
  4295	            all_players = [human_player] + computer_players
  4296	        elif 'players' in request:
  4297	            # Backend format: { players, course_id, ... }
  4298	            all_players = request['players']
  4299	            course_name = request.get('course_name')
  4300	        else:
  4301	            raise HTTPException(status_code=400, detail="Missing player data")
  4302	        
  4303	        # Validate players
  4304	        if not all_players or len(all_players) < 4:
  4305	            raise HTTPException(status_code=400, detail="At least 4 players required")
  4306	        
  4307	        if len(all_players) > 6:
  4308	            raise HTTPException(status_code=400, detail="Maximum 6 players allowed")
  4309	        
  4310	        # Create WGPPlayer objects
  4311	        wgp_players = []
  4312	        for i, player_data in enumerate(all_players):
  4313	            wgp_player = WGPPlayer(
  4314	                id=player_data.get("id", f"player_{i+1}"),
  4315	                name=player_data.get("name", f"Player {i+1}"),
  4316	                handicap=float(player_data.get("handicap", 10))
  4317	            )
  4318	            wgp_players.append(wgp_player)
  4319	        
  4320	        # Initialize simulation with players
  4321	        wgp_simulation = WolfGoatPigSimulation(
  4322	            player_count=len(wgp_players),
  4323	            players=wgp_players
  4324	        )
  4325	        
  4326	        # Enhance with timeline tracking
  4327	        wgp_simulation = enhance_simulation_with_timeline(wgp_simulation)
  4328	        
  4329	        # Set computer players if specified
  4330	        if 'computer_players' in request and request['computer_players']:
  4331	            comp_players = request['computer_players']
  4332	            personalities = request.get('personalities', ["balanced"] * len(comp_players))
  4333	            wgp_simulation.set_computer_players(comp_players, personalities)
  4334	        
  4335	        # Load course if specified
  4336	        course_id = request.get('course_id')
  4337	        course_lookup_candidates = []
  4338	        if course_name:
  4339	            course_lookup_candidates.append(str(course_name))
  4340	        if course_id is not None:
  4341	            course_lookup_candidates.append(str(course_id))
  4342	
  4343	        if course_lookup_candidates:
  4344	            selected_course_name = None
  4345	            try:
  4346	                courses = game_state.get_courses()
  4347	                if isinstance(courses, dict):
  4348	                    for candidate in course_lookup_candidates:
  4349	                        if candidate in courses:
  4350	                            selected_course_name = candidate
  4351	                            break
  4352	                        # Allow matching by case-insensitive name
  4353	                        for existing_name in courses.keys():
  4354	                            if existing_name.lower() == candidate.lower():
  4355	                                selected_course_name = existing_name
  4356	                                break
  4357	                        if selected_course_name:
  4358	                            break
  4359	                if selected_course_name:
  4360	                    logger.info(f"Using course: {selected_course_name}")
  4361	                    try:
  4362	                        game_state.course_manager.load_course(selected_course_name)
  4363	                    except Exception as load_error:
  4364	                        logger.warning(f"Failed to load course '{selected_course_name}': {load_error}")
  4365	                else:
  4366	                    logger.warning(f"Course not found: {course_lookup_candidates[0]}")
  4367	            except Exception as course_error:
  4368	                logger.warning(f"Could not load course {course_lookup_candidates[0]}: {course_error}")
  4369	        
  4370	        # Initialize hole 1
  4371	        wgp_simulation._initialize_hole(1)
  4372	        wgp_simulation.enable_shot_progression()
  4373	        
  4374	        # Get initial game state
  4375	        game_state_data = wgp_simulation.get_game_state()
  4376	        
  4377	        logger.info("Simulation setup completed successfully")
  4378	        
  4379	        return {
  4380	            "status": "ok",
  4381	            "message": "Simulation initialized successfully",
  4382	            "game_state": game_state_data,
  4383	            "players": [
  4384	                {
  4385	                    "id": p.id,
  4386	                    "name": p.name, 
  4387	                    "handicap": p.handicap,
  4388	                    "points": p.points
  4389	                } for p in wgp_simulation.players
  4390	            ],
  4391	            "current_hole": wgp_simulation.current_hole,
  4392	            "next_shot_available": True,  # After setup, first shot is always available
  4393	            "feedback": ["ðŸŽ® Game started! You're on the first tee."]
  4394	        }
  4395	        
  4396	    except Exception as e:
  4397	        logger.error(f"Simulation setup failed: {e}")
  4398	        raise HTTPException(status_code=500, detail=f"Failed to setup simulation: {str(e)}")
  4399	
  4400	@app.post("/simulation/play-next-shot")
  4401	def play_next_shot(request: SimulationPlayShotRequest = None):
  4402	    """Simulate the next shot in the current hole"""
  4403	    global wgp_simulation
  4404	    
  4405	    try:
  4406	        if not wgp_simulation:
  4407	            raise HTTPException(status_code=400, detail="Simulation not initialized. Call /simulation/setup first.")
  4408	        
  4409	        # Get next player to shoot
  4410	        next_player = wgp_simulation._get_next_shot_player()
  4411	        if not next_player:
  4412	            raise HTTPException(status_code=400, detail="No player available to shoot")
  4413	        
  4414	        # Simulate the shot
  4415	        shot_response = wgp_simulation.simulate_shot(next_player)
  4416	        
  4417	        # Get updated game state
  4418	        updated_state = wgp_simulation.get_game_state()
  4419	        
  4420	        # Get next shot player info
  4421	        next_shot_player = wgp_simulation._get_next_shot_player()
  4422	        next_player_name = wgp_simulation._get_player_name(next_shot_player) if next_shot_player else None
  4423	        
  4424	        # Check if there's another shot available
  4425	        hole_complete = updated_state.get("hole_complete", False)
  4426	        next_shot_available = not hole_complete and next_shot_player is not None
  4427	        
  4428	        # Build readable feedback messages from shot data
  4429	        feedback = []
  4430	        if shot_response:
  4431	            # Extract shot data
  4432	            shot_data = shot_response.get('shot_result', {})
  4433	            player_id = shot_data.get('player_id', 'player')
  4434	            
  4435	            # Get player display name
  4436	            player_name = 'Player'
  4437	            for player in wgp_simulation.players:
  4438	                if player.id == player_id:
  4439	                    player_name = player.name
  4440	                    break
  4441	            
  4442	            # Extract shot details
  4443	            distance_to_pin = shot_data.get('distance_to_pin', 0)
  4444	            shot_quality = shot_data.get('shot_quality', 'unknown')
  4445	            shot_number = shot_data.get('shot_number', 1)
  4446	            lie_type = shot_data.get('lie_type', 'unknown')
  4447	            
  4448	            # Create readable feedback
  4449	            feedback.append(f"ðŸŒï¸ {player_name} hits {shot_quality} shot from {lie_type} - {round(distance_to_pin)}yd to pin")
  4450	            
  4451	            # Add shot assessment
  4452	            if shot_quality == 'excellent':
  4453	                feedback.append(f"ðŸŽ¯ Great shot! {player_name} is in excellent position")
  4454	            elif shot_quality == 'poor':
  4455	                feedback.append(f"ðŸ˜¬ Tough break for {player_name}, recovery shot needed")
  4456	        
  4457	        return {
  4458	            "status": "ok",
  4459	            "success": True,
  4460	            "shot_result": shot_response,
  4461	            "game_state": updated_state,
  4462	            "next_player": next_player_name,
  4463	            "hole_complete": hole_complete,
  4464	            "next_shot_available": next_shot_available,
  4465	            "feedback": feedback
  4466	        }
  4467	        
  4468	    except Exception as e:
  4469	        logger.error(f"Play next shot failed: {e}")
  4470	        raise HTTPException(status_code=500, detail=f"Failed to play next shot: {str(e)}")
  4471	
  4472	@app.post("/simulation/play-hole")
  4473	def simulate_hole(request: Dict[str, Any] = Body(default_factory=dict)):
  4474	    """Process in-hole decisions or simulate an entire hole when no action supplied"""
  4475	    global wgp_simulation
  4476	    
  4477	    try:
  4478	        if not wgp_simulation:
  4479	            raise HTTPException(status_code=400, detail="Simulation not initialized. Call /simulation/setup first.")
  4480	        
  4481	        payload = request or {}
  4482	        if isinstance(payload.get("decision"), dict):
  4483	            payload = {**payload, **payload["decision"]}
  4484	        
  4485	        action = payload.get("action")
  4486	        if not action:
  4487	            if payload.get("accept_partnership") is True:
  4488	                action = "accept_partnership"
  4489	            elif payload.get("accept_partnership") is False:
  4490	                action = "decline_partnership"
  4491	            elif payload.get("accept_double") is True:
  4492	                action = "accept_double"
  4493	            elif payload.get("decline_double") is True:
  4494	                action = "decline_double"
  4495	            elif payload.get("offer_double"):
  4496	                action = "offer_double"
  4497	        
  4498	        interaction_needed = None
  4499	        result: Dict[str, Any] = {}
  4500	        
  4501	        if action:
  4502	            hole_state = _get_current_hole_state()
  4503	            captain_id = payload.get("captain_id") or payload.get("player_id") or _get_default_player_id()
  4504	            
  4505	            if action == "request_partner":
  4506	                partner_id = payload.get("partner_id") or payload.get("requested_partner")
  4507	                if not partner_id:
  4508	                    raise HTTPException(status_code=400, detail="Partner ID required for partnership request")
  4509	                if not captain_id:
  4510	                    raise HTTPException(status_code=400, detail="Captain ID required for partnership request")
  4511	                
  4512	                result = wgp_simulation.request_partner(captain_id, partner_id)
  4513	                interaction_needed = {
  4514	                    "type": "partnership_response",
  4515	                    "requested_partner": partner_id,
  4516	                    "captain_id": captain_id
  4517	                }
  4518	            
  4519	            elif action in ("accept_partnership", "decline_partnership"):
  4520	                pending_request = _get_pending_partnership_request()
  4521	                partner_id = payload.get("partner_id") or pending_request.get("requested")
  4522	                if not partner_id:
  4523	                    raise HTTPException(status_code=400, detail="No pending partnership request to resolve")
  4524	                accept = action == "accept_partnership"
  4525	                result = wgp_simulation.respond_to_partnership(partner_id, accept)
  4526	            
  4527	            elif action in ("go_solo", "captain_go_solo"):
  4528	                if not captain_id:
  4529	                    raise HTTPException(status_code=400, detail="Captain ID required for solo decision")
  4530	                result = wgp_simulation.captain_go_solo(captain_id)
  4531	            
  4532	            elif action == "offer_double":
  4533	                if not captain_id:
  4534	                    raise HTTPException(status_code=400, detail="Player ID required to offer double")
  4535	                result = wgp_simulation.offer_double(captain_id)
  4536	                interaction_needed = {
  4537	                    "type": "double_response",
  4538	                    "offering_player": captain_id
  4539	                }
  4540	            
  4541	            elif action in ("accept_double", "decline_double"):
  4542	                offer_history = []
  4543	                if hole_state and getattr(hole_state, "betting", None):
  4544	                    offer_history = hole_state.betting.doubles_history or []
  4545	                offering_player = None
  4546	                if offer_history:
  4547	                    offering_player = offer_history[-1].get("offering_player")
  4548	                offering_player = offering_player or payload.get("offering_player")
  4549	                
  4550	                responding_team = payload.get("team_id") or _get_opposing_team_id(offering_player or captain_id)
  4551	                accept = action == "accept_double"
  4552	                result = wgp_simulation.respond_to_double(responding_team, accept)
  4553	            
  4554	            else:
  4555	                result = {"status": "unsupported_action", "message": f"Action '{action}' not recognized"}
  4556	        
  4557	        else:
  4558	            hole_results = []
  4559	            max_shots = 20  # Safety limit
  4560	            shot_count = 0
  4561	            
  4562	            while shot_count < max_shots:
  4563	                next_player = wgp_simulation._get_next_shot_player()
  4564	                if not next_player:
  4565	                    break
  4566	                    
  4567	                shot_response = wgp_simulation.simulate_shot(next_player)
  4568	                hole_results.append(shot_response)
  4569	                shot_count += 1
  4570	                
  4571	                game_state_data = wgp_simulation.get_game_state()
  4572	                if game_state_data.get("hole_complete", False):
  4573	                    break
  4574	            
  4575	            updated_state = wgp_simulation.get_game_state()
  4576	            return {
  4577	                "success": True,
  4578	                "hole_results": hole_results,
  4579	                "game_state": updated_state,
  4580	                "shots_played": shot_count
  4581	            }
  4582	        
  4583	        updated_state = wgp_simulation.get_game_state()
  4584	        if interaction_needed is None:
  4585	            pending_request = _get_pending_partnership_request()
  4586	            if pending_request:
  4587	                interaction_needed = {
  4588	                    "type": "partnership_response",
  4589	                    "requested_partner": pending_request.get("requested"),
  4590	                    "captain_id": pending_request.get("captain")
  4591	                }
  4592	        
  4593	        return {
  4594	            "success": True,
  4595	            "result": result,
  4596	            "game_state": updated_state,
  4597	            "interaction_needed": interaction_needed,
  4598	            "hole_complete": updated_state.get("hole_complete", False)
  4599	        }
  4600	        
  4601	    except HTTPException:
  4602	        raise
  4603	    except ValueError as ve:
  4604	        raise HTTPException(status_code=400, detail=str(ve))
  4605	    except Exception as e:
  4606	        logger.error(f"Hole simulation failed: {e}")
  4607	        raise HTTPException(status_code=500, detail=f"Failed to simulate hole: {str(e)}")
  4608	
  4609	
  4610	if ENABLE_TEST_ENDPOINTS:
  4611	
  4612	    @app.post("/simulation/test/seed-state")
  4613	    def seed_simulation_state(payload: SimulationSeedRequest, x_admin_email: Optional[str] = Header(None)):
  4614	        """Testing-only helper for seeding the current simulation state.
  4615	
  4616	        Allows BDD and backend tests to manipulate the in-memory simulation using
  4617	        the public HTTP API instead of reaching into the global simulation object.
  4618	        """
  4619	
  4620	        global wgp_simulation
  4621	
  4622	        require_admin(x_admin_email)
  4623	
  4624	        if not wgp_simulation:
  4625	            raise HTTPException(status_code=400, detail="Simulation not initialized. Call /simulation/setup first.")
  4626	
  4627	        if payload.current_hole is not None:
  4628	            if payload.current_hole not in wgp_simulation.hole_states:
  4629	                try:
  4630	                    wgp_simulation._initialize_hole(payload.current_hole)
  4631	                except Exception as exc:  # pragma: no cover - defensive fallback
  4632	                    raise HTTPException(status_code=500, detail=f"Failed to initialise hole {payload.current_hole}: {exc}") from exc
  4633	            wgp_simulation.current_hole = payload.current_hole
  4634	
  4635	        hole_state = _get_current_hole_state()
  4636	        if not hole_state:
  4637	            raise HTTPException(status_code=400, detail="No active hole to seed")
  4638	
  4639	        player_ids = {player.id for player in wgp_simulation.players}
  4640	
  4641	        # Seed ball positions
  4642	        if payload.ball_positions:
  4643	            if payload.ball_positions_replace:
  4644	                hole_state.ball_positions.clear()
  4645	
  4646	            if payload.clear_balls_in_hole:
  4647	                hole_state.balls_in_hole = []
  4648	
  4649	            for seed in payload.ball_positions:
  4650	                if seed.player_id not in player_ids:
  4651	                    raise HTTPException(status_code=422, detail=f"Unknown player id '{seed.player_id}'")
  4652	
  4653	                ball = BallPosition(
  4654	                    player_id=seed.player_id,
  4655	                    distance_to_pin=seed.distance_to_pin,
  4656	                    lie_type=seed.lie_type,
  4657	                    shot_count=seed.shot_count,
  4658	                    penalty_strokes=seed.penalty_strokes,
  4659	                )
  4660	                ball.holed = seed.holed
  4661	                ball.conceded = seed.conceded
  4662	
  4663	                hole_state.ball_positions[seed.player_id] = ball
  4664	
  4665	                if seed.holed:
  4666	                    if seed.player_id not in hole_state.balls_in_hole:
  4667	                        hole_state.balls_in_hole.append(seed.player_id)
  4668	                elif seed.player_id in hole_state.balls_in_hole:
  4669	                    hole_state.balls_in_hole.remove(seed.player_id)
  4670	
  4671	        # Update ordering metadata
  4672	        if payload.line_of_scrimmage is not None:
  4673	            if payload.line_of_scrimmage and payload.line_of_scrimmage not in player_ids:
  4674	                raise HTTPException(status_code=422, detail=f"Unknown line of scrimmage player '{payload.line_of_scrimmage}'")
  4675	            hole_state.line_of_scrimmage = payload.line_of_scrimmage
  4676	            if payload.betting is None:
  4677	                hole_state.betting.line_of_scrimmage = payload.line_of_scrimmage
  4678	
  4679	        if payload.current_order_of_play is not None:
  4680	            unknown = [pid for pid in payload.current_order_of_play if pid not in player_ids]
  4681	            if unknown:
  4682	                raise HTTPException(status_code=422, detail=f"Unknown players in order of play: {', '.join(unknown)}")
  4683	            hole_state.current_order_of_play = payload.current_order_of_play
  4684	
  4685	        if payload.shot_order is not None:
  4686	            unknown = [pid for pid in payload.shot_order if pid not in player_ids]
  4687	            if unknown:
  4688	                raise HTTPException(status_code=422, detail=f"Unknown players in shot order: {', '.join(unknown)}")
  4689	            hole_state.hitting_order = payload.shot_order
  4690	
  4691	        if payload.next_player_to_hit is not None:
  4692	            if payload.next_player_to_hit and payload.next_player_to_hit not in player_ids:
  4693	                raise HTTPException(status_code=422, detail=f"Unknown next player '{payload.next_player_to_hit}'")
  4694	            hole_state.next_player_to_hit = payload.next_player_to_hit
  4695	
  4696	        if payload.wagering_closed is not None:
  4697	            hole_state.wagering_closed = payload.wagering_closed
  4698	
  4699	        if payload.betting:
  4700	            betting = hole_state.betting
  4701	            updates = payload.betting.dict(exclude_unset=True)
  4702	            line_of_scrimmage = updates.pop("line_of_scrimmage", None)
  4703	            if line_of_scrimmage is not None:
  4704	                if line_of_scrimmage and line_of_scrimmage not in player_ids:
  4705	                    raise HTTPException(status_code=422, detail=f"Unknown line of scrimmage player '{line_of_scrimmage}'")
  4706	                hole_state.line_of_scrimmage = line_of_scrimmage
  4707	                betting.line_of_scrimmage = line_of_scrimmage
  4708	
  4709	            for key, value in updates.items():
  4710	                setattr(betting, key, value)
  4711	
  4712	        if payload.team_formation:
  4713	            formation_data = payload.team_formation
  4714	            hole_state.teams = TeamFormation(
  4715	                type=formation_data.get("type", hole_state.teams.type),
  4716	                captain=formation_data.get("captain", hole_state.teams.captain),
  4717	                second_captain=formation_data.get("second_captain", hole_state.teams.second_captain),
  4718	                team1=formation_data.get("team1", hole_state.teams.team1),
  4719	                team2=formation_data.get("team2", hole_state.teams.team2),
  4720	                team3=formation_data.get("team3", hole_state.teams.team3),
  4721	                solo_player=formation_data.get("solo_player", hole_state.teams.solo_player),
  4722	                opponents=formation_data.get("opponents", hole_state.teams.opponents),
  4723	                pending_request=formation_data.get("pending_request", hole_state.teams.pending_request),
  4724	            )
  4725	
  4726	        if payload.reset_doubles_history:
  4727	            hole_state.betting.doubles_history = []
  4728	
  4729	        return {
  4730	            "status": "seeded",
  4731	            "game_state": wgp_simulation.get_game_state(),
  4732	        }
  4733	
  4734	
  4735	@app.get("/simulation/state")
  4736	def get_simulation_state(x_admin_email: Optional[str] = Header(None)):
  4737	    """Return the current simulation state for diagnostics and testing."""
  4738	    global wgp_simulation
  4739	
  4740	    if not ENABLE_TEST_ENDPOINTS:
  4741	        raise HTTPException(status_code=404, detail="Not found")
  4742	
  4743	    require_admin(x_admin_email)
  4744	
  4745	    if not wgp_simulation:
  4746	        raise HTTPException(status_code=404, detail="Simulation not initialized")
  4747	
  4748	    try:
  4749	        return wgp_simulation.get_game_state()
  4750	    except Exception as exc:  # pragma: no cover
  4751	        logger.error(f"Failed to fetch simulation state: {exc}")
  4752	        raise HTTPException(status_code=500, detail="Failed to fetch simulation state")
  4753	
  4754	@app.get("/simulation/available-personalities")
  4755	def get_available_personalities():
  4756	    """Get list of available AI personality types"""
  4757	    try:
  4758	        personalities = [
  4759	            {
  4760	                "id": "aggressive",
  4761	                "name": "Aggressive",
  4762	                "description": "Takes risks, goes for bold shots and betting decisions"
  4763	            },
  4764	            {
  4765	                "id": "conservative", 
  4766	                "name": "Conservative",
  4767	                "description": "Plays it safe, avoids risky bets and shots"
  4768	            },
  4769	            {
  4770	                "id": "balanced",
  4771	                "name": "Balanced",
  4772	                "description": "Balanced approach to risk and reward"
  4773	            },
  4774	            {
  4775	                "id": "strategic",
  4776	                "name": "Strategic", 
  4777	                "description": "Focuses on long-term game positioning"
  4778	            },
  4779	            {
  4780	                "id": "maverick",
  4781	                "name": "Maverick",
  4782	                "description": "Unpredictable playing style, keeps opponents guessing"
  4783	            }
  4784	        ]
  4785	        
  4786	        return {
  4787	            "status": "ok",
  4788	            "success": True,
  4789	            "personalities": personalities
  4790	        }
  4791	        
  4792	    except Exception as e:
  4793	        logger.error(f"Failed to get personalities: {e}")
  4794	        raise HTTPException(status_code=500, detail=f"Failed to get personalities: {str(e)}")
  4795	
  4796	# Legacy endpoints for frontend compatibility - return direct arrays
  4797	@app.get("/personalities")
  4798	def get_personalities_legacy():
  4799	    """Legacy endpoint for personalities - returns direct array for frontend compatibility"""
  4800	    try:
  4801	        personalities = [
  4802	            {"id": "aggressive", "name": "Aggressive"},
  4803	            {"id": "conservative", "name": "Conservative"},
  4804	            {"id": "balanced", "name": "Balanced"},
  4805	            {"id": "strategic", "name": "Strategic"},
  4806	            {"id": "maverick", "name": "Maverick"}
  4807	        ]
  4808	        return personalities
  4809	    except Exception as e:
  4810	        logger.error(f"Failed to get personalities: {e}")
  4811	        raise HTTPException(status_code=500, detail=f"Failed to get personalities: {str(e)}")
  4812	
  4813	@app.get("/suggested_opponents") 
  4814	def get_suggested_opponents_legacy():
  4815	    """Legacy endpoint for suggested opponents - returns direct array for frontend compatibility"""
  4816	    try:
  4817	        # Return array of individual players, not grouped opponents
  4818	        opponents = [
  4819	            {"name": "Clive", "handicap": "8", "personality": "aggressive"},
  4820	            {"name": "Gary", "handicap": "12", "personality": "conservative"}, 
  4821	            {"name": "Bernard", "handicap": "15", "personality": "strategic"},
  4822	            {"name": "Alex", "handicap": "5", "personality": "balanced"},
  4823	            {"name": "Sam", "handicap": "18", "personality": "maverick"},
  4824	            {"name": "Jordan", "handicap": "22", "personality": "conservative"},
  4825	            {"name": "Ace", "handicap": "3", "personality": "aggressive"},
  4826	            {"name": "Blade", "handicap": "6", "personality": "aggressive"},
  4827	            {"name": "Chase", "handicap": "9", "personality": "strategic"}
  4828	        ]
  4829	        return opponents
  4830	    except Exception as e:
  4831	        logger.error(f"Failed to get suggested opponents: {e}")
  4832	        raise HTTPException(status_code=500, detail=f"Failed to get suggested opponents: {str(e)}")
  4833	
  4834	@app.get("/simulation/suggested-opponents")
  4835	def get_suggested_opponents():
  4836	    """Get list of suggested AI opponent configurations"""
  4837	    try:
  4838	        opponents = [
  4839	            {
  4840	                "id": "classic_quartet",
  4841	                "name": "Classic Quartet",
  4842	                "description": "Traditional Wolf Goat Pig characters",
  4843	                "players": [
  4844	                    {"name": "Clive", "handicap": 8, "personality": "aggressive"},
  4845	                    {"name": "Gary", "handicap": 12, "personality": "conservative"},
  4846	                    {"name": "Bernard", "handicap": 15, "personality": "strategic"}
  4847	                ]
  4848	            },
  4849	            {
  4850	                "id": "mixed_bag",
  4851	                "name": "Mixed Bag",
  4852	                "description": "Diverse skill levels and personalities",
  4853	                "players": [
  4854	                    {"name": "Alex", "handicap": 5, "personality": "balanced"},
  4855	                    {"name": "Sam", "handicap": 18, "personality": "maverick"},
  4856	                    {"name": "Jordan", "handicap": 22, "personality": "conservative"}
  4857	                ]
  4858	            },
  4859	            {
  4860	                "id": "high_rollers",
  4861	                "name": "High Rollers", 
  4862	                "description": "Aggressive betting and low handicaps",
  4863	                "players": [
  4864	                    {"name": "Ace", "handicap": 3, "personality": "aggressive"},
  4865	                    {"name": "Blade", "handicap": 6, "personality": "aggressive"},
  4866	                    {"name": "Chase", "handicap": 9, "personality": "strategic"}
  4867	                ]
  4868	            }
  4869	        ]
  4870	        
  4871	        return {
  4872	            "status": "ok",
  4873	            "success": True,
  4874	            "opponents": opponents
  4875	        }
  4876	        
  4877	    except Exception as e:
  4878	        logger.error(f"Failed to get suggested opponents: {e}")
  4879	        raise HTTPException(status_code=500, detail=f"Failed to get suggested opponents: {str(e)}")
  4880	
  4881	@app.get("/simulation/shot-probabilities")  
  4882	def get_shot_probabilities():
  4883	    """Get current shot outcome probabilities for the active player"""
  4884	    global wgp_simulation
  4885	    
  4886	    try:
  4887	        if not wgp_simulation:
  4888	            raise HTTPException(status_code=400, detail="Simulation not initialized")
  4889	        
  4890	        # Get next player to shoot
  4891	        next_player = wgp_simulation._get_next_shot_player()
  4892	        if not next_player:
  4893	            return {"success": True, "probabilities": {}}
  4894	        
  4895	        # Get current hole state
  4896	        hole_state = _get_current_hole_state()
  4897	        if not hole_state:
  4898	            return {"success": True, "probabilities": {}}
  4899	        
  4900	        # Get player's current ball position
  4901	        ball_position = hole_state.get_player_ball_position(next_player)
  4902	        
  4903	        player_obj = next((p for p in wgp_simulation.players if p.id == next_player), None)
  4904	        hole_info = {
  4905	            "difficulty": getattr(hole_state, "hole_difficulty", "medium"),
  4906	            "par": getattr(hole_state, "hole_par", 4),
  4907	            "distance": getattr(ball_position, "distance_to_pin", None)
  4908	        }
  4909	        probabilities = _compute_shot_probabilities(
  4910	            player_stats={"handicap": getattr(player_obj, "handicap", 18)} if player_obj else None,
  4911	            hole_info=hole_info,
  4912	            lie_type=getattr(ball_position, "lie_type", None)
  4913	        )
  4914	
  4915	        return {
  4916	            "success": True,
  4917	            "probabilities": probabilities,
  4918	            "player_id": next_player,
  4919	            "ball_position": {
  4920	                "lie_type": ball_position.lie_type if ball_position else "unknown",
  4921	                "distance_to_pin": ball_position.distance_to_pin if ball_position else 0
  4922	            }
  4923	        }
  4924	        
  4925	    except Exception as e:
  4926	        logger.error(f"Failed to get shot probabilities: {e}")
  4927	        raise HTTPException(status_code=500, detail=f"Failed to get shot probabilities: {str(e)}")
  4928	
  4929	
  4930	@app.post("/simulation/shot-probabilities")
  4931	def calculate_shot_probabilities(payload: Dict[str, Any]):
  4932	    """Calculate shot probabilities for arbitrary scenarios (used by tests/tools)"""
  4933	    try:
  4934	        player_stats = payload.get("player_stats") or {}
  4935	        hole_info = payload.get("hole_info") or {}
  4936	        lie_type = payload.get("lie_type")
  4937	        
  4938	        probabilities = _compute_shot_probabilities(player_stats, hole_info, lie_type)
  4939	        insights = []
  4940	        if player_stats.get("handicap") is not None:
  4941	            handicap = float(player_stats["handicap"])
  4942	            if handicap <= 10:
  4943	                insights.append("Low handicap boosts excellent shot odds.")
  4944	            elif handicap >= 20:
  4945	                insights.append("Higher handicap reduces premium shot outcomes.")
  4946	        
  4947	        difficulty = str(hole_info.get("difficulty", "")).lower()
  4948	        if difficulty in {"hard", "very hard", "difficult"}:
  4949	            insights.append("Difficult hole increases chance of poor or disaster outcomes.")
  4950	        elif difficulty in {"easy", "very easy"}:
  4951	            insights.append("Easier hole improves strong shot percentages.")
  4952	        
  4953	        return {
  4954	            "success": True,
  4955	            "probabilities": probabilities,
  4956	            "insights": insights
  4957	        }
  4958	    except Exception as exc:
  4959	        logger.error(f"Shot probability calculation failed: {exc}")
  4960	        raise HTTPException(status_code=500, detail=f"Failed to calculate shot probabilities: {str(exc)}")
  4961	
  4962	@app.post("/simulation/betting-decision")
  4963	def make_betting_decision(request: Dict[str, Any]):
  4964	    """Process a betting decision in the simulation with poker-style actions"""
  4965	    global wgp_simulation
  4966	    
  4967	    try:
  4968	        if not wgp_simulation:
  4969	            raise HTTPException(status_code=400, detail="Simulation not initialized")
  4970	        
  4971	        # Handle both old format and new format
  4972	        decision = request['decision'] if isinstance(request, dict) and 'decision' in request else request
  4973	        
  4974	        action = decision.get("action")
  4975	        decision_type = decision.get("type") or decision.get("decision_type")
  4976	        if action and not decision_type:
  4977	            legacy_action_map = {
  4978	                "request_partner": "partnership_request",
  4979	                "accept_partnership": "partnership_response",
  4980	                "decline_partnership": "partnership_response",
  4981	                "offer_double": "double_offer",
  4982	                "accept_double": "double_response",
  4983	                "decline_double": "double_response",
  4984	                "go_solo": "go_solo",
  4985	            }
  4986	            decision_type = legacy_action_map.get(action, action)
  4987	        
  4988	        player_id = decision.get("player_id") or decision.get("captain_id") or _get_default_player_id()
  4989	        
  4990	        result = {"success": False, "message": "Unknown decision type"}
  4991	        interaction_needed = None
  4992	        
  4993	        # Process different types of betting decisions
  4994	        if decision_type == "partnership_request":
  4995	            partner_id = decision.get("partner_id")
  4996	            if not partner_id:
  4997	                partner_id = decision.get("requested_partner")
  4998	            if partner_id:
  4999	                if not player_id:
  5000	                    raise HTTPException(status_code=400, detail="Captain player_id required for partnership request")
  5001	                result = wgp_simulation.request_partner(player_id, partner_id)
  5002	                interaction_needed = {
  5003	                    "type": "partnership_response",
  5004	                    "requested_partner": partner_id,
  5005	                    "captain_id": player_id
  5006	                }
  5007	                
  5008	        elif decision_type == "partnership_response":
  5009	            partner_id = decision.get("partner_id") or decision.get("requested_partner")
  5010	            if not partner_id:
  5011	                pending = _get_pending_partnership_request()
  5012	                partner_id = pending.get("requested")
  5013	            if not partner_id:
  5014	                raise HTTPException(status_code=400, detail="No pending partnership request to resolve")
  5015	            accept = decision.get("accept", decision.get("accept_partnership", action == "accept_partnership"))
  5016	            result = wgp_simulation.respond_to_partnership(partner_id, bool(accept))
  5017	            
  5018	        elif decision_type == "double_offer":
  5019	            if not player_id:
  5020	                raise HTTPException(status_code=400, detail="player_id required to offer a double")
  5021	            result = wgp_simulation.offer_double(player_id)
  5022	            interaction_needed = {
  5023	                "type": "double_response",
  5024	                "offering_player": player_id
  5025	            }
  5026	            
  5027	        elif decision_type == "double_response":
  5028	            accept = decision.get("accept", decision.get("accept_double", action == "accept_double"))
  5029	            hole_state = _get_current_hole_state()
  5030	            offer_history = []
  5031	            if hole_state and getattr(hole_state, "betting", None):
  5032	                offer_history = hole_state.betting.doubles_history or []
  5033	            offering_player = decision.get("offering_player")
  5034	            if not offering_player and offer_history:
  5035	                offering_player = offer_history[-1].get("offering_player")
  5036	            responding_team = decision.get("team_id") or _get_opposing_team_id(offering_player or player_id)
  5037	            result = wgp_simulation.respond_to_double(responding_team, bool(accept))
  5038	            
  5039	        elif decision_type == "go_solo":
  5040	            if not player_id:
  5041	                raise HTTPException(status_code=400, detail="player_id required for go_solo decision")
  5042	            result = wgp_simulation.captain_go_solo(player_id)
  5043	            
  5044	        # Get updated game state
  5045	        updated_state = wgp_simulation.get_game_state()
  5046	        
  5047	        return {
  5048	            "success": True,
  5049	            "decision_result": result,
  5050	            "game_state": updated_state,
  5051	            "interaction_needed": interaction_needed
  5052	        }
  5053	    except HTTPException:
  5054	        raise
  5055	    except ValueError as ve:
  5056	        raise HTTPException(status_code=400, detail=str(ve))
  5057	    except Exception as e:
  5058	        logger.error(f"Betting decision failed: {e}")
  5059	        raise HTTPException(status_code=500, detail=f"Failed to process betting decision: {str(e)}")
  5060	
  5061	@app.get("/simulation/post-hole-analytics/{hole_number}")
  5062	def get_post_hole_analytics(hole_number: int):
  5063	    """Get comprehensive post-hole analytics for learning and improvement"""
  5064	    global wgp_simulation, post_hole_analyzer
  5065	    
  5066	    try:
  5067	        if not wgp_simulation:
  5068	            raise HTTPException(status_code=400, detail="Simulation not initialized")
  5069	        
  5070	        # Get hole state
  5071	        hole_state = wgp_simulation.hole_states.get(hole_number)
  5072	        if not hole_state:
  5073	            raise HTTPException(status_code=404, detail=f"Hole {hole_number} not found")
  5074	        
  5075	        # Check if hole is complete
  5076	        if not hole_state.hole_complete:
  5077	            raise HTTPException(status_code=400, detail=f"Hole {hole_number} is not complete yet")
  5078	        
  5079	        # Get game state and timeline events
  5080	        game_state = wgp_simulation.get_game_state()
  5081	        timeline_events = []
  5082	        if hasattr(wgp_simulation, 'hole_progression') and wgp_simulation.hole_progression:
  5083	            timeline_events = wgp_simulation.hole_progression.timeline_events
  5084	        
  5085	        # Generate analytics
  5086	        analytics = post_hole_analyzer.analyze_hole(hole_state, game_state, timeline_events)
  5087	        
  5088	        # Convert to dict for JSON response
  5089	        analytics_dict = {
  5090	            "hole_number": analytics.hole_number,
  5091	            "hole_par": analytics.hole_par,
  5092	            "hole_yardage": analytics.hole_yardage,
  5093	            "winner": analytics.winner,
  5094	            "quarters_exchanged": analytics.quarters_exchanged,
  5095	            "final_scores": analytics.final_scores,
  5096	            "decision_points": [
  5097	                {
  5098	                    "decision_type": dp.decision_type,
  5099	                    "player_id": dp.player_id,
  5100	                    "timestamp": dp.timestamp,
  5101	                    "options_available": dp.options_available,
  5102	                    "decision_made": dp.decision_made,
  5103	                    "outcome": dp.outcome,
  5104	                    "quarters_impact": dp.quarters_impact,
  5105	                    "quality": dp.quality.value,
  5106	                    "explanation": dp.explanation
  5107	                }
  5108	                for dp in analytics.decision_points
  5109	            ],
  5110	            "partnership_analysis": {
  5111	                "partnership_formed": analytics.partnership_analysis.partnership_formed,
  5112	                "captain_id": analytics.partnership_analysis.captain_id,
  5113	                "partner_id": analytics.partnership_analysis.partner_id,
  5114	                "timing": analytics.partnership_analysis.timing,
  5115	                "success": analytics.partnership_analysis.success,
  5116	                "chemistry_rating": analytics.partnership_analysis.chemistry_rating,
  5117	                "alternative_partners": analytics.partnership_analysis.alternative_partners,
  5118	                "optimal_choice": analytics.partnership_analysis.optimal_choice,
  5119	                "explanation": analytics.partnership_analysis.explanation
  5120	            } if analytics.partnership_analysis else None,
  5121	            "betting_analysis": {
  5122	                "doubles_offered": analytics.betting_analysis.doubles_offered,
  5123	                "doubles_accepted": analytics.betting_analysis.doubles_accepted,
  5124	                "doubles_declined": analytics.betting_analysis.doubles_declined,
  5125	                "duncan_used": analytics.betting_analysis.duncan_used,
  5126	                "timing_quality": analytics.betting_analysis.timing_quality,
  5127	                "aggressive_rating": analytics.betting_analysis.aggressive_rating,
  5128	                "missed_opportunities": analytics.betting_analysis.missed_opportunities,
  5129	                "costly_mistakes": analytics.betting_analysis.costly_mistakes,
  5130	                "net_quarter_impact": analytics.betting_analysis.net_quarter_impact
  5131	            },
  5132	            "shot_analysis": {
  5133	                "total_shots": analytics.shot_analysis.total_shots,
  5134	                "shot_quality_distribution": analytics.shot_analysis.shot_quality_distribution,
  5135	                "clutch_shots": analytics.shot_analysis.clutch_shots,
  5136	                "worst_shot": analytics.shot_analysis.worst_shot,
  5137	                "best_shot": analytics.shot_analysis.best_shot,
  5138	                "pressure_performance": analytics.shot_analysis.pressure_performance
  5139	            },
  5140	            "key_moments": [
  5141	                {
  5142	                    "description": km.description,
  5143	                    "impact": km.impact,
  5144	                    "quarters_swing": km.quarters_swing,
  5145	                    "player_involved": km.player_involved,
  5146	                    "timestamp": km.timestamp
  5147	                }
  5148	                for km in analytics.key_moments
  5149	            ],
  5150	            "biggest_mistake": analytics.biggest_mistake,
  5151	            "best_decision": analytics.best_decision,
  5152	            "learning_points": analytics.learning_points,
  5153	            "overall_performance": analytics.overall_performance,
  5154	            "decision_making_score": analytics.decision_making_score,
  5155	            "risk_management_score": analytics.risk_management_score,
  5156	            "ai_comparison": analytics.ai_comparison,
  5157	            "historical_comparison": analytics.historical_comparison,
  5158	            "tips_for_improvement": analytics.tips_for_improvement,
  5159	            "similar_scenarios_to_practice": analytics.similar_scenarios_to_practice
  5160	        }
  5161	        
  5162	        return analytics_dict
  5163	        
  5164	    except HTTPException:
  5165	        raise
  5166	    except Exception as e:
  5167	        logger.error(f"Error generating post-hole analytics: {e}")
  5168	        raise HTTPException(status_code=500, detail=str(e))
  5169	
  5170	@app.get("/simulation/turn-based-state")
  5171	def get_turn_based_state():
  5172	    """Get structured turn-based game state for Wolf Goat Pig"""
  5173	    global wgp_simulation
  5174	    
  5175	    try:
  5176	        if not wgp_simulation:
  5177	            raise HTTPException(status_code=400, detail="Simulation not initialized")
  5178	        
  5179	        current_hole = wgp_simulation.current_hole
  5180	        hole_state = wgp_simulation.hole_states.get(current_hole)
  5181	        
  5182	        if not hole_state:
  5183	            return {"success": False, "message": "No active hole"}
  5184	        
  5185	        # Determine current game phase
  5186	        phase = "setup"
  5187	        if hole_state.teams.type == "pending":
  5188	            phase = "captain_selection"
  5189	        elif hole_state.teams.pending_request:
  5190	            phase = "partnership_decision"
  5191	        elif hole_state.teams.type in ["partners", "solo"]:
  5192	            phase = "match_play"
  5193	        
  5194	        # Get captain information
  5195	        captain_id = hole_state.teams.captain
  5196	        captain_player = None
  5197	        if captain_id:
  5198	            captain_player = next((p for p in wgp_simulation.players if p.id == captain_id), None)
  5199	        
  5200	        # Get rotation order for this hole
  5201	        rotation_order = getattr(hole_state, 'rotation_order', [p.id for p in wgp_simulation.players])
  5202	        
  5203	        # Get shots played
  5204	        shots_played = []
  5205	        for player_id, position in hole_state.ball_positions.items():
  5206	            shots_played.append({
  5207	                "player_id": player_id,
  5208	                "shot_number": position.shot_count,
  5209	                "distance_to_pin": position.distance_to_pin,
  5210	                "lie_type": position.lie_type,
  5211	                "holed": position.holed
  5212	            })
  5213	        
  5214	        # Determine whose turn it is for decisions or shots
  5215	        current_turn = None
  5216	        furthest_player = None
  5217	        
  5218	        if phase == "match_play":
  5219	            # Find furthest from hole for shot order
  5220	            max_distance = -1
  5221	            for player_id, pos in hole_state.ball_positions.items():
  5222	                if not pos.holed and pos.distance_to_pin > max_distance:
  5223	                    max_distance = pos.distance_to_pin
  5224	                    furthest_player = next((p for p in wgp_simulation.players if p.id == player_id), None)
  5225	            current_turn = furthest_player.id if furthest_player else None
  5226	        
  5227	        # Get pending decision info
  5228	        pending_decision = None
  5229	        if hole_state.teams.pending_request:
  5230	            pending_decision = {
  5231	                "type": "partnership_request",
  5232	                "from_player": hole_state.teams.pending_request.get("requestor"),
  5233	                "to_player": hole_state.teams.pending_request.get("requested"),
  5234	                "message": f"Partnership requested by {wgp_simulation._get_player_name(hole_state.teams.pending_request.get('requestor'))}"
  5235	            }
  5236	        
  5237	        # Check for betting opportunities
  5238	        betting_opportunities = []
  5239	        if phase == "match_play" and not hole_state.betting.doubled:
  5240	            # Check Line of Scrimmage rule
  5241	            line_of_scrimmage_player = furthest_player.id if furthest_player else None
  5242	            betting_opportunities.append({
  5243	                "type": "double_offer",
  5244	                "available": True,
  5245	                "line_of_scrimmage": line_of_scrimmage_player,
  5246	                "current_wager": hole_state.betting.current_wager,
  5247	                "potential_wager": hole_state.betting.current_wager * 2
  5248	            })
  5249	        
  5250	        # Get team formations
  5251	        teams_display = []
  5252	        if hole_state.teams.type == "partners":
  5253	            team1_names = [wgp_simulation._get_player_name(pid) for pid in hole_state.teams.team1]
  5254	            team2_names = [wgp_simulation._get_player_name(pid) for pid in hole_state.teams.team2]
  5255	            teams_display.append({
  5256	                "type": "partnership",
  5257	                "description": f"{' & '.join(team1_names)} vs {' & '.join(team2_names)}"
  5258	            })
  5259	        elif hole_state.teams.type == "solo":
  5260	            solo_name = wgp_simulation._get_player_name(hole_state.teams.solo_player)
  5261	            opponent_names = [wgp_simulation._get_player_name(pid) for pid in hole_state.teams.opponents]
  5262	            teams_display.append({
  5263	                "type": "solo",
  5264	                "description": f"{solo_name} (Solo) vs {', '.join(opponent_names)}"
  5265	            })
  5266	        
  5267	        return {
  5268	            "success": True,
  5269	            "turn_based_state": {
  5270	                "current_hole": current_hole,
  5271	                "phase": phase,
  5272	                "current_turn": current_turn,
  5273	                "captain_id": captain_id,
  5274	                "captain_name": captain_player.name if captain_player else None,
  5275	                "rotation_order": rotation_order,
  5276	                "teams": teams_display,
  5277	                "betting": {
  5278	                    "current_wager": hole_state.betting.current_wager,
  5279	                    "base_wager": hole_state.betting.base_wager,
  5280	                    "doubled": hole_state.betting.doubled,
  5281	                    "in_hole": any(pos.holed for pos in hole_state.ball_positions.values())
  5282	                },
  5283	                "pending_decision": pending_decision,
  5284	                "betting_opportunities": betting_opportunities,
  5285	                "shots_played": shots_played,
  5286	                "ball_positions": [
  5287	                    {
  5288	                        "player_id": player_id,
  5289	                        "player_name": wgp_simulation._get_player_name(player_id),
  5290	                        "distance_to_pin": pos.distance_to_pin,
  5291	                        "lie_type": pos.lie_type,
  5292	                        "shot_count": pos.shot_count,
  5293	                        "holed": pos.holed
  5294	                    } for player_id, pos in hole_state.ball_positions.items()
  5295	                ],
  5296	                "furthest_from_hole": {
  5297	                    "player_id": furthest_player.id if furthest_player else None,
  5298	                    "player_name": furthest_player.name if furthest_player else None,
  5299	                    "distance": max_distance if furthest_player else None
  5300	                } if furthest_player else None
  5301	            }
  5302	        }
  5303	        
  5304	    except Exception as e:
  5305	        logger.error(f"Failed to get turn-based state: {e}")
  5306	        raise HTTPException(status_code=500, detail=f"Failed to get turn-based state: {str(e)}")
  5307	
  5308	@app.get("/simulation/timeline")
  5309	def get_simulation_timeline(limit: int = 20):
  5310	    """Get timeline events in reverse chronological order"""
  5311	    global wgp_simulation
  5312	    
  5313	    try:
  5314	        if not wgp_simulation:
  5315	            raise HTTPException(status_code=400, detail="Simulation not initialized")
  5316	        
  5317	        # Get timeline events from the simulation
  5318	        if hasattr(wgp_simulation, 'timeline_manager'):
  5319	            events = wgp_simulation.timeline_manager.get_recent_events(limit)
  5320	        else:
  5321	            # Fallback to hole progression events
  5322	            events = []
  5323	            if wgp_simulation.hole_progression:
  5324	                events = wgp_simulation.hole_progression.get_timeline_events()[:limit]
  5325	        
  5326	        return {
  5327	            "success": True,
  5328	            "events": events,
  5329	            "total_events": len(events)
  5330	        }
  5331	        
  5332	    except Exception as e:
  5333	        logger.error(f"Failed to get timeline: {e}")
  5334	        raise HTTPException(status_code=500, detail=f"Failed to get timeline: {str(e)}")
  5335	
  5336	@app.get("/simulation/poker-state")
  5337	def get_poker_betting_state():
  5338	    """Get current betting state in poker terms"""
  5339	    global wgp_simulation
  5340	    
  5341	    try:
  5342	        if not wgp_simulation:
  5343	            raise HTTPException(status_code=400, detail="Simulation not initialized")
  5344	        
  5345	        # Get poker-style betting state using correct hole state structure
  5346	        current_hole = wgp_simulation.current_hole
  5347	        hole_state = wgp_simulation.hole_states.get(current_hole)
  5348	        
  5349	        if not hole_state:
  5350	            raise HTTPException(status_code=400, detail="No active hole state")
  5351	        
  5352	        # Format poker betting state manually
  5353	        betting = hole_state.betting
  5354	        pot_size = betting.current_wager * len(wgp_simulation.players)
  5355	        if betting.doubled:
  5356	            pot_size *= 2
  5357	        
  5358	        # Determine betting phase
  5359	        phase = "pre-flop"  # Before tee shots
  5360	        shots_taken = sum(1 for shot in hole_state.shots_completed.values() if shot)
  5361	        if shots_taken >= len(wgp_simulation.players):
  5362	            phase = "flop"  # After tee shots
  5363	        if hole_state.current_shot_number > len(wgp_simulation.players) * 2:
  5364	            phase = "turn"  # Mid-hole
  5365	        if any(hole_state.balls_in_hole):
  5366	            phase = "river"  # Near completion
  5367	        
  5368	        poker_state = {
  5369	            "pot_size": pot_size,
  5370	            "base_bet": betting.base_wager,
  5371	            "current_bet": betting.current_wager,
  5372	            "betting_phase": phase,
  5373	            "doubled": betting.doubled,
  5374	            "players_in": len(wgp_simulation.players),
  5375	            "wagering_closed": hole_state.wagering_closed
  5376	        }
  5377	        
  5378	        # Get available betting options for current player
  5379	        current_player_id = hole_state.next_player_to_hit or "human"
  5380	        betting_options = []  # Simplified for now
  5381	        
  5382	        return {
  5383	            "success": True,
  5384	            "pot_size": poker_state["pot_size"],
  5385	            "base_bet": poker_state["base_bet"],
  5386	            "current_bet": poker_state["current_bet"],
  5387	            "betting_phase": poker_state["betting_phase"],
  5388	            "doubled": poker_state["doubled"],
  5389	            "players_in": poker_state["players_in"],
  5390	            "wagering_closed": poker_state["wagering_closed"],
  5391	            "betting_options": betting_options,
  5392	            "current_player": current_player_id
  5393	        }
  5394	        
  5395	    except Exception as e:
  5396	        logger.error(f"Failed to get poker state: {e}")
  5397	        raise HTTPException(status_code=500, detail=f"Failed to get poker state: {str(e)}")
  5398	
  5399	# Daily Sign-up System Endpoints
  5400	
  5401	@app.get("/signups/weekly", response_model=schemas.WeeklySignupView)
  5402	def get_weekly_signups(week_start: str = Query(description="YYYY-MM-DD format for Monday of the week")):
  5403	    """Get sign-ups for a rolling 7-day period starting from specified Monday."""
  5404	    try:
  5405	        db = database.SessionLocal()
  5406	        from datetime import datetime, timedelta
  5407	        
  5408	        # Parse the week start date
  5409	        start_date = datetime.strptime(week_start, '%Y-%m-%d')
  5410	        
  5411	        # Get all 7 days
  5412	        daily_summaries = []
  5413	        for i in range(7):
  5414	            current_date = start_date + timedelta(days=i)
  5415	            date_str = current_date.strftime('%Y-%m-%d')
  5416	            
  5417	            signups = db.query(models.DailySignup).filter(
  5418	                models.DailySignup.date == date_str,
  5419	                models.DailySignup.status != "cancelled"
  5420	            ).all()
  5421	            
  5422	            daily_summaries.append(schemas.DailySignupSummary(
  5423	                date=date_str,
  5424	                signups=[schemas.DailySignupResponse.from_orm(signup) for signup in signups],
  5425	                total_count=len(signups)
  5426	            ))
  5427	        
  5428	        return schemas.WeeklySignupView(
  5429	            week_start=week_start,
  5430	            daily_summaries=daily_summaries
  5431	        )
  5432	        
  5433	    except ValueError as e:
  5434	        raise HTTPException(status_code=400, detail=f"Invalid date format: {str(e)}")
  5435	    except Exception as e:
  5436	        logger.error(f"Error getting weekly signups: {e}")
  5437	        raise HTTPException(status_code=500, detail=f"Failed to get weekly signups: {str(e)}")
  5438	    finally:
  5439	        db.close()
  5440	
  5441	@app.get("/signups")
  5442	def get_signups(limit: int = Query(50, description="Maximum number of signups to return")):
  5443	    """Get recent signups with basic information"""
  5444	    try:
  5445	        db = database.SessionLocal()
  5446	        
  5447	        # Get recent signups
  5448	        signups = db.query(models.DailySignup).filter(
  5449	            models.DailySignup.status != "cancelled"
  5450	        ).order_by(models.DailySignup.created_at.desc()).limit(limit).all()
  5451	        
  5452	        return {
  5453	            "signups": [
  5454	                {
  5455	                    "id": signup.id,
  5456	                    "date": signup.date,
  5457	                    "player_name": signup.player_name,
  5458	                    "player_profile_id": signup.player_profile_id,
  5459	                    "status": signup.status,
  5460	                    "signup_time": signup.signup_time,
  5461	                    "preferred_start_time": signup.preferred_start_time,
  5462	                    "notes": signup.notes,
  5463	                    "created_at": signup.created_at if signup.created_at else None
  5464	                }
  5465	                for signup in signups
  5466	            ],
  5467	            "total": len(signups)
  5468	        }
  5469	        
  5470	    except Exception as e:
  5471	        logger.error(f"Error getting signups: {e}")
  5472	        raise HTTPException(status_code=500, detail=f"Failed to get signups: {str(e)}")
  5473	    finally:
  5474	        db.close()
  5475	
  5476	@app.post("/signups", response_model=schemas.DailySignupResponse)
  5477	def create_signup(signup: schemas.DailySignupCreate):
  5478	    """Create a daily sign-up for a player."""
  5479	    try:
  5480	        db = database.SessionLocal()
  5481	        
  5482	        # Check if player already signed up for this date
  5483	        existing = db.query(models.DailySignup).filter(
  5484	            models.DailySignup.date == signup.date,
  5485	            models.DailySignup.player_profile_id == signup.player_profile_id,
  5486	            models.DailySignup.status != "cancelled"
  5487	        ).first()
  5488	        
  5489	        if existing:
  5490	            raise HTTPException(status_code=400, detail="Player already signed up for this date")
  5491	        
  5492	        # Create new signup
  5493	        db_signup = models.DailySignup(
  5494	            date=signup.date,
  5495	            player_profile_id=signup.player_profile_id,
  5496	            player_name=signup.player_name,
  5497	            signup_time=datetime.now().isoformat(),
  5498	            preferred_start_time=signup.preferred_start_time,
  5499	            notes=signup.notes,
  5500	            status="signed_up",
  5501	            created_at=datetime.now().isoformat(),
  5502	            updated_at=datetime.now().isoformat()
  5503	        )
  5504	        
  5505	        db.add(db_signup)
  5506	        db.commit()
  5507	        db.refresh(db_signup)
  5508	
  5509	        logger.info(f"Created signup for player {signup.player_name} on {signup.date}")
  5510	
  5511	        # Mirror the signup to the legacy CGI sheet when configured.
  5512	        try:
  5513	            legacy_service = get_legacy_signup_service()
  5514	            legacy_service.sync_signup_created(db_signup)
  5515	        except Exception:
  5516	            logger.exception(
  5517	                "Legacy signup sync failed for create id=%s", db_signup.id
  5518	            )
  5519	
  5520	        return schemas.DailySignupResponse.from_orm(db_signup)
  5521	        
  5522	    except HTTPException:
  5523	        raise
  5524	    except Exception as e:
  5525	        db.rollback()
  5526	        logger.error(f"Error creating signup: {e}")
  5527	        raise HTTPException(status_code=500, detail=f"Failed to create signup: {str(e)}")
  5528	    finally:
  5529	        db.close()
  5530	
  5531	@app.put("/signups/{signup_id}", response_model=schemas.DailySignupResponse)
  5532	def update_signup(signup_id: int, signup_update: schemas.DailySignupUpdate):
  5533	    """Update a daily sign-up."""
  5534	    try:
  5535	        db = database.SessionLocal()
  5536	        
  5537	        db_signup = db.query(models.DailySignup).filter(models.DailySignup.id == signup_id).first()
  5538	        if not db_signup:
  5539	            raise HTTPException(status_code=404, detail="Sign-up not found")
  5540	        
  5541	        # Update fields
  5542	        if signup_update.preferred_start_time is not None:
  5543	            db_signup.preferred_start_time = signup_update.preferred_start_time
  5544	        if signup_update.notes is not None:
  5545	            db_signup.notes = signup_update.notes
  5546	        if signup_update.status is not None:
  5547	            db_signup.status = signup_update.status
  5548	            
  5549	        db_signup.updated_at = datetime.now().isoformat()
  5550	        
  5551	        db.commit()
  5552	        db.refresh(db_signup)
  5553	
  5554	        logger.info(f"Updated signup {signup_id}")
  5555	
  5556	        try:
  5557	            legacy_service = get_legacy_signup_service()
  5558	            legacy_service.sync_signup_updated(db_signup)
  5559	        except Exception:
  5560	            logger.exception(
  5561	                "Legacy signup sync failed for update id=%s", db_signup.id
  5562	            )
  5563	
  5564	        return schemas.DailySignupResponse.from_orm(db_signup)
  5565	        
  5566	    except HTTPException:
  5567	        raise
  5568	    except Exception as e:
  5569	        db.rollback()
  5570	        logger.error(f"Error updating signup {signup_id}: {e}")
  5571	        raise HTTPException(status_code=500, detail=f"Failed to update signup: {str(e)}")
  5572	    finally:
  5573	        db.close()
  5574	
  5575	@app.delete("/signups/{signup_id}")
  5576	def cancel_signup(signup_id: int):
  5577	    """Cancel a daily sign-up."""
  5578	    try:
  5579	        db = database.SessionLocal()
  5580	        
  5581	        db_signup = db.query(models.DailySignup).filter(models.DailySignup.id == signup_id).first()
  5582	        if not db_signup:
  5583	            raise HTTPException(status_code=404, detail="Sign-up not found")
  5584	        
  5585	        db_signup.status = "cancelled"
  5586	        db_signup.updated_at = datetime.now().isoformat()
  5587	        
  5588	        db.commit()
  5589	
  5590	        logger.info(f"Cancelled signup {signup_id}")
  5591	
  5592	        try:
  5593	            legacy_service = get_legacy_signup_service()
  5594	            legacy_service.sync_signup_cancelled(db_signup)
  5595	        except Exception:
  5596	            logger.exception(
  5597	                "Legacy signup sync failed for cancel id=%s", db_signup.id
  5598	            )
  5599	
  5600	        return {"message": "Sign-up cancelled successfully"}
  5601	        
  5602	    except HTTPException:
  5603	        raise
  5604	    except Exception as e:
  5605	        db.rollback()
  5606	        logger.error(f"Error cancelling signup {signup_id}: {e}")
  5607	        raise HTTPException(status_code=500, detail=f"Failed to cancel signup: {str(e)}")
  5608	    finally:
  5609	        db.close()
  5610	
  5611	# Daily Message Board Endpoints
  5612	
  5613	@app.get("/messages/daily", response_model=List[schemas.DailyMessageResponse])
  5614	def get_daily_messages(date: str = Query(description="YYYY-MM-DD format")):
  5615	    """Get all messages for a specific date."""
  5616	    try:
  5617	        db = database.SessionLocal()
  5618	        
  5619	        messages = db.query(models.DailyMessage).filter(
  5620	            models.DailyMessage.date == date,
  5621	            models.DailyMessage.is_active == 1
  5622	        ).order_by(models.DailyMessage.message_time).all()
  5623	        
  5624	        return [schemas.DailyMessageResponse.from_orm(message) for message in messages]
  5625	        
  5626	    except Exception as e:
  5627	        logger.error(f"Error getting messages for date {date}: {e}")
  5628	        raise HTTPException(status_code=500, detail=f"Failed to get messages: {str(e)}")
  5629	    finally:
  5630	        db.close()
  5631	
  5632	@app.get("/signups/weekly-with-messages", response_model=schemas.WeeklySignupWithMessagesView)
  5633	def get_weekly_signups_with_messages(week_start: str = Query(description="YYYY-MM-DD format for Monday of the week")):
  5634	    """Get sign-ups and messages for a rolling 7-day period starting from specified Monday."""
  5635	    try:
  5636	        db = database.SessionLocal()
  5637	        from datetime import datetime, timedelta
  5638	        
  5639	        # Parse the week start date
  5640	        start_date = datetime.strptime(week_start, '%Y-%m-%d')
  5641	        
  5642	        # Get all 7 days
  5643	        daily_summaries = []
  5644	        for i in range(7):
  5645	            current_date = start_date + timedelta(days=i)
  5646	            date_str = current_date.strftime('%Y-%m-%d')
  5647	            
  5648	            # Get signups
  5649	            signups = db.query(models.DailySignup).filter(
  5650	                models.DailySignup.date == date_str,
  5651	                models.DailySignup.status != "cancelled"
  5652	            ).all()
  5653	            
  5654	            # Get messages
  5655	            messages = db.query(models.DailyMessage).filter(
  5656	                models.DailyMessage.date == date_str,
  5657	                models.DailyMessage.is_active == 1
  5658	            ).order_by(models.DailyMessage.message_time).all()
  5659	            
  5660	            daily_summaries.append(schemas.DailySignupWithMessages(
  5661	                date=date_str,
  5662	                signups=[schemas.DailySignupResponse.from_orm(signup) for signup in signups],
  5663	                total_count=len(signups),
  5664	                messages=[schemas.DailyMessageResponse.from_orm(message) for message in messages],
  5665	                message_count=len(messages)
  5666	            ))
  5667	        
  5668	        return schemas.WeeklySignupWithMessagesView(
  5669	            week_start=week_start,
  5670	            daily_summaries=daily_summaries
  5671	        )
  5672	        
  5673	    except ValueError as e:
  5674	        raise HTTPException(status_code=400, detail=f"Invalid date format: {str(e)}")
  5675	    except Exception as e:
  5676	        logger.error(f"Error getting weekly data with messages: {e}")
  5677	        raise HTTPException(status_code=500, detail=f"Failed to get weekly data: {str(e)}")
  5678	    finally:
  5679	        db.close()
  5680	
  5681	@app.post("/messages", response_model=schemas.DailyMessageResponse)
  5682	def create_message(message: schemas.DailyMessageCreate):
  5683	    """Create a new daily message."""
  5684	    try:
  5685	        db = database.SessionLocal()
  5686	        from datetime import datetime
  5687	        
  5688	        # Create new message
  5689	        db_message = models.DailyMessage(
  5690	            date=message.date,
  5691	            player_profile_id=message.player_profile_id or 1,  # Default player if not provided
  5692	            player_name=message.player_name or "Anonymous",
  5693	            message=message.message,
  5694	            message_time=datetime.now().isoformat(),
  5695	            is_active=1,
  5696	            created_at=datetime.now().isoformat(),
  5697	            updated_at=datetime.now().isoformat()
  5698	        )
  5699	        
  5700	        db.add(db_message)
  5701	        db.commit()
  5702	        db.refresh(db_message)
  5703	        
  5704	        logger.info(f"Created message {db_message.id} for date {message.date}")
  5705	        return schemas.DailyMessageResponse.from_orm(db_message)
  5706	        
  5707	    except Exception as e:
  5708	        db.rollback()
  5709	        logger.error(f"Error creating message: {e}")
  5710	        raise HTTPException(status_code=500, detail=f"Failed to create message: {str(e)}")
  5711	    finally:
  5712	        db.close()
  5713	
  5714	@app.put("/messages/{message_id}", response_model=schemas.DailyMessageResponse)
  5715	def update_message(message_id: int, message_update: schemas.DailyMessageUpdate):
  5716	    """Update an existing message."""
  5717	    try:
  5718	        db = database.SessionLocal()
  5719	        from datetime import datetime
  5720	        
  5721	        db_message = db.query(models.DailyMessage).filter(models.DailyMessage.id == message_id).first()
  5722	        if not db_message:
  5723	            raise HTTPException(status_code=404, detail="Message not found")
  5724	        
  5725	        if message_update.message is not None:
  5726	            db_message.message = message_update.message
  5727	            db_message.updated_at = datetime.now().isoformat()
  5728	        
  5729	        db.commit()
  5730	        db.refresh(db_message)
  5731	        
  5732	        logger.info(f"Updated message {message_id}")
  5733	        return schemas.DailyMessageResponse.from_orm(db_message)
  5734	        
  5735	    except HTTPException:
  5736	        raise
  5737	    except Exception as e:
  5738	        db.rollback()
  5739	        logger.error(f"Error updating message {message_id}: {e}")
  5740	        raise HTTPException(status_code=500, detail=f"Failed to update message: {str(e)}")
  5741	    finally:
  5742	        db.close()
  5743	
  5744	@app.delete("/messages/{message_id}")
  5745	def delete_message(message_id: int):
  5746	    """Delete (deactivate) a message."""
  5747	    try:
  5748	        db = database.SessionLocal()
  5749	        from datetime import datetime
  5750	        
  5751	        db_message = db.query(models.DailyMessage).filter(models.DailyMessage.id == message_id).first()
  5752	        if not db_message:
  5753	            raise HTTPException(status_code=404, detail="Message not found")
  5754	        
  5755	        db_message.is_active = 0
  5756	        db_message.updated_at = datetime.now().isoformat()
  5757	        
  5758	        db.commit()
  5759	        
  5760	        logger.info(f"Deleted message {message_id}")
  5761	        return {"message": "Message deleted successfully"}
  5762	        
  5763	    except HTTPException:
  5764	        raise
  5765	    except Exception as e:
  5766	        db.rollback()
  5767	        logger.error(f"Error deleting message {message_id}: {e}")
  5768	        raise HTTPException(status_code=500, detail=f"Failed to delete message: {str(e)}")
  5769	    finally:
  5770	        db.close()
  5771	
  5772	# Player Availability Endpoints
  5773	
  5774	@app.get("/players/me/availability", response_model=List[schemas.PlayerAvailabilityResponse])
  5775	async def get_my_availability(current_user: models.PlayerProfile = Depends(get_current_user)):
  5776	    """Get current user's weekly availability."""
  5777	    try:
  5778	        db = database.SessionLocal()
  5779	        
  5780	        availability = db.query(models.PlayerAvailability).filter(
  5781	            models.PlayerAvailability.player_profile_id == current_user.id
  5782	        ).all()
  5783	        
  5784	        return [schemas.PlayerAvailabilityResponse.from_orm(a) for a in availability]
  5785	        
  5786	    except Exception as e:
  5787	        logger.error(f"Error getting availability for user {current_user.id}: {e}")
  5788	        raise HTTPException(status_code=500, detail=f"Failed to get availability: {str(e)}")
  5789	    finally:
  5790	        db.close()
  5791	
  5792	@app.post("/players/me/availability", response_model=schemas.PlayerAvailabilityResponse)
  5793	async def set_my_availability(
  5794	    availability: schemas.PlayerAvailabilityCreate,
  5795	    current_user: models.PlayerProfile = Depends(get_current_user)
  5796	):
  5797	    """Set or update current user's availability for a specific day."""
  5798	    try:
  5799	        db = database.SessionLocal()
  5800	        
  5801	        # Override the player_profile_id with the current user's ID
  5802	        availability.player_profile_id = current_user.id
  5803	        
  5804	        # Check if availability already exists for this day
  5805	        existing = db.query(models.PlayerAvailability).filter(
  5806	            models.PlayerAvailability.player_profile_id == current_user.id,
  5807	            models.PlayerAvailability.day_of_week == availability.day_of_week
  5808	        ).first()
  5809	        
  5810	        if existing:
  5811	            # Update existing
  5812	            existing.available_from_time = availability.available_from_time
  5813	            existing.available_to_time = availability.available_to_time
  5814	            existing.is_available = availability.is_available
  5815	            existing.notes = availability.notes
  5816	            existing.updated_at = datetime.now().isoformat()
  5817	            
  5818	            db.commit()
  5819	            db.refresh(existing)
  5820	            
  5821	            logger.info(f"Updated availability for user {current_user.id}, day {availability.day_of_week}")
  5822	            return schemas.PlayerAvailabilityResponse.from_orm(existing)
  5823	        else:
  5824	            # Create new
  5825	            db_availability = models.PlayerAvailability(
  5826	                player_profile_id=current_user.id,
  5827	                day_of_week=availability.day_of_week,
  5828	                available_from_time=availability.available_from_time,
  5829	                available_to_time=availability.available_to_time,
  5830	                is_available=availability.is_available,
  5831	                notes=availability.notes,
  5832	                created_at=datetime.now().isoformat(),
  5833	                updated_at=datetime.now().isoformat()
  5834	            )
  5835	            
  5836	            db.add(db_availability)
  5837	            db.commit()
  5838	            db.refresh(db_availability)
  5839	            
  5840	            logger.info(f"Created availability for user {current_user.id}, day {availability.day_of_week}")
  5841	            return schemas.PlayerAvailabilityResponse.from_orm(db_availability)
  5842	        
  5843	    except Exception as e:
  5844	        db.rollback()
  5845	        logger.error(f"Error setting availability for user {current_user.id}: {e}")
  5846	        raise HTTPException(status_code=500, detail=f"Failed to set availability: {str(e)}")
  5847	    finally:
  5848	        db.close()
  5849	
  5850	@app.get("/players/{player_id}/availability", response_model=List[schemas.PlayerAvailabilityResponse])
  5851	def get_player_availability(player_id: int):
  5852	    """Get a player's weekly availability."""
  5853	    try:
  5854	        db = database.SessionLocal()
  5855	        
  5856	        availability = db.query(models.PlayerAvailability).filter(
  5857	            models.PlayerAvailability.player_profile_id == player_id
  5858	        ).order_by(models.PlayerAvailability.day_of_week).all()
  5859	        
  5860	        return [schemas.PlayerAvailabilityResponse.from_orm(avail) for avail in availability]
  5861	        
  5862	    except Exception as e:
  5863	        logger.error(f"Error getting availability for player {player_id}: {e}")
  5864	        raise HTTPException(status_code=500, detail=f"Failed to get availability: {str(e)}")
  5865	    finally:
  5866	        db.close()
  5867	
  5868	@app.get("/players/availability/all", response_model=List[Dict])
  5869	def get_all_players_availability():
  5870	    """Get all players' weekly availability with their names."""
  5871	    try:
  5872	        db = database.SessionLocal()
  5873	        
  5874	        # Get all players with their availability
  5875	        players_with_availability = db.query(models.PlayerProfile).all()
  5876	        
  5877	        result = []
  5878	        for player in players_with_availability:
  5879	            player_data = {
  5880	                "player_id": player.id,
  5881	                "player_name": player.name,
  5882	                "email": player.email,
  5883	                "availability": []
  5884	            }
  5885	            
  5886	            # Get this player's availability
  5887	            availability = db.query(models.PlayerAvailability).filter(
  5888	                models.PlayerAvailability.player_profile_id == player.id
  5889	            ).all()
  5890	            
  5891	            for avail in availability:
  5892	                player_data["availability"].append({
  5893	                    "day_of_week": avail.day_of_week,
  5894	                    "is_available": avail.is_available,
  5895	                    "available_from_time": avail.available_from_time,
  5896	                    "available_to_time": avail.available_to_time,
  5897	                    "notes": avail.notes
  5898	                })
  5899	            
  5900	            result.append(player_data)
  5901	        
  5902	        return result
  5903	        
  5904	    except Exception as e:
  5905	        logger.error(f"Error getting all players availability: {e}")
  5906	        raise HTTPException(status_code=500, detail=f"Failed to get availability: {str(e)}")
  5907	    finally:
  5908	        db.close()
  5909	
  5910	@app.post("/players/{player_id}/availability", response_model=schemas.PlayerAvailabilityResponse)
  5911	def set_player_availability(player_id: int, availability: schemas.PlayerAvailabilityCreate):
  5912	    """Set or update a player's availability for a specific day."""
  5913	    try:
  5914	        db = database.SessionLocal()
  5915	        
  5916	        # Check if availability already exists for this day
  5917	        existing = db.query(models.PlayerAvailability).filter(
  5918	            models.PlayerAvailability.player_profile_id == player_id,
  5919	            models.PlayerAvailability.day_of_week == availability.day_of_week
  5920	        ).first()
  5921	        
  5922	        if existing:
  5923	            # Update existing
  5924	            existing.available_from_time = availability.available_from_time
  5925	            existing.available_to_time = availability.available_to_time
  5926	            existing.is_available = availability.is_available
  5927	            existing.notes = availability.notes
  5928	            existing.updated_at = datetime.now().isoformat()
  5929	            
  5930	            db.commit()
  5931	            db.refresh(existing)
  5932	            
  5933	            logger.info(f"Updated availability for player {player_id}, day {availability.day_of_week}")
  5934	            return schemas.PlayerAvailabilityResponse.from_orm(existing)
  5935	        else:
  5936	            # Create new
  5937	            db_availability = models.PlayerAvailability(
  5938	                player_profile_id=player_id,
  5939	                day_of_week=availability.day_of_week,
  5940	                available_from_time=availability.available_from_time,
  5941	                available_to_time=availability.available_to_time,
  5942	                is_available=availability.is_available,
  5943	                notes=availability.notes,
  5944	                created_at=datetime.now().isoformat(),
  5945	                updated_at=datetime.now().isoformat()
  5946	            )
  5947	            
  5948	            db.add(db_availability)
  5949	            db.commit()
  5950	            db.refresh(db_availability)
  5951	            
  5952	            logger.info(f"Created availability for player {player_id}, day {availability.day_of_week}")
  5953	            return schemas.PlayerAvailabilityResponse.from_orm(db_availability)
  5954	        
  5955	    except Exception as e:
  5956	        db.rollback()
  5957	        logger.error(f"Error setting availability for player {player_id}: {e}")
  5958	        raise HTTPException(status_code=500, detail=f"Failed to set availability: {str(e)}")
  5959	    finally:
  5960	        db.close()
  5961	
  5962	# Team Formation Helpers & Endpoints
  5963	
  5964	
  5965	def _get_active_signups_for_date(db: Session, date: str) -> List[models.DailySignup]:
  5966	    """Fetch non-cancelled signups for the requested date."""
  5967	    return db.query(models.DailySignup).filter(
  5968	        models.DailySignup.date == date,
  5969	        models.DailySignup.status != "cancelled"
  5970	    ).all()
  5971	
  5972	
  5973	def _build_player_payload(
  5974	    signups: List[models.DailySignup],
  5975	    *,
  5976	    include_handicap: bool = False,
  5977	    db: Optional[Session] = None
  5978	) -> List[Dict[str, Any]]:
  5979	    """Convert signup records into the player dictionaries used by formation services."""
  5980	    if include_handicap and db is None:
  5981	        raise ValueError("Database session is required when include_handicap=True")
  5982	
  5983	    players: List[Dict[str, Any]] = []
  5984	    handicap_lookup: Dict[int, float] = {}
  5985	
  5986	    if include_handicap:
  5987	        profile_ids = [s.player_profile_id for s in signups if s.player_profile_id is not None]
  5988	        if profile_ids:
  5989	            profiles = db.query(models.PlayerProfile).filter(
  5990	                models.PlayerProfile.id.in_(profile_ids)
  5991	            ).all()
  5992	            handicap_lookup = {profile.id: profile.handicap for profile in profiles}
  5993	
  5994	    for signup in signups:
  5995	        player_data: Dict[str, Any] = {
  5996	            "id": signup.id,
  5997	            "player_profile_id": signup.player_profile_id,
  5998	            "player_name": signup.player_name,
  5999	            "preferred_start_time": signup.preferred_start_time,
  6000	            "notes": signup.notes,
  6001	            "signup_time": signup.signup_time
  6002	        }
  6003	
  6004	        if include_handicap:
  6005	            player_data["handicap"] = handicap_lookup.get(signup.player_profile_id, 18.0)
  6006	
  6007	        players.append(player_data)
  6008	
  6009	    return players
  6010	
  6011	
  6012	@app.post("/signups/{date}/team-formation/random")
  6013	def generate_random_teams_for_date(
  6014	    date: str = Path(description="Date in YYYY-MM-DD format"),
  6015	    seed: Optional[int] = Query(None, description="Random seed for reproducible results"),
  6016	    max_teams: Optional[int] = Query(None, description="Maximum number of teams to create")
  6017	):
  6018	    """Generate random 4-player teams from players signed up for a specific date."""
  6019	    try:
  6020	        db = database.SessionLocal()
  6021	
  6022	        # Get all signups for the specified date
  6023	        signups = _get_active_signups_for_date(db, date)
  6024	        
  6025	        if len(signups) < 4:
  6026	            raise HTTPException(
  6027	                status_code=400, 
  6028	                detail=f"Not enough players signed up for {date}. Need at least 4 players, found {len(signups)}"
  6029	            )
  6030	        
  6031	        # Convert signups to player dictionaries
  6032	        players = _build_player_payload(signups)
  6033	        
  6034	        # Generate random teams
  6035	        teams = TeamFormationService.generate_random_teams(
  6036	            players=players,
  6037	            seed=seed,
  6038	            max_teams=max_teams
  6039	        )
  6040	        
  6041	        # Create summary
  6042	        summary = TeamFormationService.create_team_summary(teams)
  6043	        summary["date"] = date
  6044	        summary["total_signups"] = len(signups)
  6045	        
  6046	        # Validate results
  6047	        validation = TeamFormationService.validate_team_formation(teams)
  6048	        
  6049	        logger.info(f"Generated {len(teams)} random teams for date {date}")
  6050	        
  6051	        return {
  6052	            "summary": summary,
  6053	            "teams": teams,
  6054	            "validation": validation,
  6055	            "remaining_players": len(signups) % 4
  6056	        }
  6057	        
  6058	    except HTTPException:
  6059	        raise
  6060	    except Exception as e:
  6061	        logger.error(f"Error generating random teams for date {date}: {e}")
  6062	        raise HTTPException(status_code=500, detail=f"Failed to generate teams: {str(e)}")
  6063	    finally:
  6064	        db.close()
  6065	
  6066	@app.post("/signups/{date}/team-formation/balanced")
  6067	def generate_balanced_teams_for_date(
  6068	    date: str = Path(description="Date in YYYY-MM-DD format"),
  6069	    seed: Optional[int] = Query(None, description="Random seed for reproducible results")
  6070	):
  6071	    """Generate skill-balanced 4-player teams from players signed up for a specific date."""
  6072	    try:
  6073	        db = database.SessionLocal()
  6074	
  6075	        # Get all signups for the specified date
  6076	        signups = _get_active_signups_for_date(db, date)
  6077	        
  6078	        if len(signups) < 4:
  6079	            raise HTTPException(
  6080	                status_code=400,
  6081	                detail=f"Not enough players signed up for {date}. Need at least 4 players, found {len(signups)}"
  6082	            )
  6083	        
  6084	        # Get player profiles with handicap information
  6085	        players = _build_player_payload(signups, include_handicap=True, db=db)
  6086	        
  6087	        # Generate balanced teams
  6088	        teams = TeamFormationService.generate_balanced_teams(
  6089	            players=players,
  6090	            skill_key="handicap",
  6091	            seed=seed
  6092	        )
  6093	        
  6094	        # Create summary
  6095	        summary = TeamFormationService.create_team_summary(teams)
  6096	        summary["date"] = date
  6097	        summary["total_signups"] = len(signups)
  6098	        
  6099	        # Validate results
  6100	        validation = TeamFormationService.validate_team_formation(teams)
  6101	        
  6102	        logger.info(f"Generated {len(teams)} balanced teams for date {date}")
  6103	        
  6104	        return {
  6105	            "summary": summary,
  6106	            "teams": teams,
  6107	            "validation": validation,
  6108	            "remaining_players": len(signups) % 4
  6109	        }
  6110	        
  6111	    except HTTPException:
  6112	        raise
  6113	    except Exception as e:
  6114	        logger.error(f"Error generating balanced teams for date {date}: {e}")
  6115	        raise HTTPException(status_code=500, detail=f"Failed to generate balanced teams: {str(e)}")
  6116	    finally:
  6117	        db.close()
  6118	
  6119	@app.post("/signups/{date}/team-formation/rotations")
  6120	def generate_team_rotations_for_date(
  6121	    date: str = Path(description="Date in YYYY-MM-DD format"),
  6122	    num_rotations: int = Query(3, description="Number of different team rotations to create"),
  6123	    seed: Optional[int] = Query(None, description="Random seed for reproducible results")
  6124	):
  6125	    """Generate multiple team rotation options for variety throughout the day."""
  6126	    try:
  6127	        db = database.SessionLocal()
  6128	
  6129	        # Get all signups for the specified date
  6130	        signups = _get_active_signups_for_date(db, date)
  6131	        
  6132	        if len(signups) < 4:
  6133	            raise HTTPException(
  6134	                status_code=400,
  6135	                detail=f"Not enough players signed up for {date}. Need at least 4 players, found {len(signups)}"
  6136	            )
  6137	        
  6138	        # Convert signups to player dictionaries
  6139	        players = _build_player_payload(signups)
  6140	        
  6141	        # Generate team rotations
  6142	        rotations = TeamFormationService.create_team_pairings_with_rotations(
  6143	            players=players,
  6144	            num_rotations=num_rotations,
  6145	            seed=seed
  6146	        )
  6147	        
  6148	        logger.info(f"Generated {len(rotations)} team rotations for date {date}")
  6149	        
  6150	        return {
  6151	            "date": date,
  6152	            "total_signups": len(signups),
  6153	            "num_rotations": len(rotations),
  6154	            "rotations": rotations
  6155	        }
  6156	        
  6157	    except HTTPException:
  6158	        raise
  6159	    except Exception as e:
  6160	        logger.error(f"Error generating team rotations for date {date}: {e}")
  6161	        raise HTTPException(status_code=500, detail=f"Failed to generate rotations: {str(e)}")
  6162	    finally:
  6163	        db.close()
  6164	
  6165	
  6166	@app.post("/signups/{date}/sunday-game/pairings")
  6167	def generate_sunday_game_pairings(
  6168	    date: str = Path(description="Date in YYYY-MM-DD format"),
  6169	    num_rotations: int = Query(3, description="Number of Sunday pairing options to generate"),
  6170	    seed: Optional[int] = Query(None, description="Override random seed for reproducible results")
  6171	):
  6172	    """Generate randomized Sunday game pairings with optional deterministic seeding."""
  6173	    try:
  6174	        db = database.SessionLocal()
  6175	
  6176	        signups = _get_active_signups_for_date(db, date)
  6177	
  6178	        if len(signups) < 4:
  6179	            raise HTTPException(
  6180	                status_code=400,
  6181	                detail=f"Not enough players signed up for {date}. Need at least 4 players, found {len(signups)}"
  6182	            )
  6183	
  6184	        players = _build_player_payload(signups)
  6185	
  6186	        pairing_result = generate_sunday_pairings(
  6187	            players,
  6188	            num_rotations=num_rotations,
  6189	            seed=seed
  6190	        )
  6191	
  6192	        return {
  6193	            "date": date,
  6194	            "total_signups": len(signups),
  6195	            "player_count": pairing_result["player_count"],
  6196	            "pairing_sets_available": pairing_result["total_rotations"],
  6197	            "selected_rotation": pairing_result["selected_rotation"],
  6198	            "rotations": pairing_result["rotations"],
  6199	            "random_seed": pairing_result["random_seed"],
  6200	            "remaining_players": pairing_result["remaining_players"]
  6201	        }
  6202	
  6203	    except HTTPException:
  6204	        raise
  6205	    except Exception as e:
  6206	        logger.error(f"Error generating Sunday game pairings for {date}: {e}")
  6207	        raise HTTPException(status_code=500, detail=f"Failed to generate Sunday pairings: {str(e)}")
  6208	    finally:
  6209	        db.close()
  6210	
  6211	@app.get("/signups/{date}/players")
  6212	def get_players_for_date(date: str = Path(description="Date in YYYY-MM-DD format")):
  6213	    """Get all players signed up for a specific date."""
  6214	    try:
  6215	        db = database.SessionLocal()
  6216	        
  6217	        # Get all signups for the specified date
  6218	        signups = db.query(models.DailySignup).filter(
  6219	            models.DailySignup.date == date,
  6220	            models.DailySignup.status != "cancelled"
  6221	        ).all()
  6222	        
  6223	        players = []
  6224	        for signup in signups:
  6225	            # Get player profile for additional info
  6226	            player_profile = db.query(models.PlayerProfile).filter(
  6227	                models.PlayerProfile.id == signup.player_profile_id
  6228	            ).first()
  6229	            
  6230	            player_data = {
  6231	                "signup_id": signup.id,
  6232	                "player_profile_id": signup.player_profile_id,
  6233	                "player_name": signup.player_name,
  6234	                "preferred_start_time": signup.preferred_start_time,
  6235	                "notes": signup.notes,
  6236	                "signup_time": signup.signup_time,
  6237	                "handicap": player_profile.handicap if player_profile else None,
  6238	                "email": player_profile.email if player_profile else None
  6239	            }
  6240	            players.append(player_data)
  6241	        
  6242	        return {
  6243	            "date": date,
  6244	            "total_players": len(players),
  6245	            "players": players,
  6246	            "can_form_teams": len(players) >= 4,
  6247	            "max_complete_teams": len(players) // 4,
  6248	            "remaining_players": len(players) % 4
  6249	        }
  6250	        
  6251	    except Exception as e:
  6252	        logger.error(f"Error getting players for date {date}: {e}")
  6253	        raise HTTPException(status_code=500, detail=f"Failed to get players: {str(e)}")
  6254	    finally:
  6255	        db.close()
  6256	
  6257	# Email Preferences Endpoints
  6258	
  6259	@app.get("/players/{player_id}/email-preferences", response_model=schemas.EmailPreferencesResponse)
  6260	def get_email_preferences(player_id: int):
  6261	    """Get a player's email preferences."""
  6262	    try:
  6263	        db = database.SessionLocal()
  6264	        
  6265	        preferences = db.query(models.EmailPreferences).filter(
  6266	            models.EmailPreferences.player_profile_id == player_id
  6267	        ).first()
  6268	        
  6269	        if not preferences:
  6270	            # Create default preferences
  6271	            preferences = models.EmailPreferences(
  6272	                player_profile_id=player_id,
  6273	                created_at=datetime.now().isoformat(),
  6274	                updated_at=datetime.now().isoformat()
  6275	            )
  6276	            db.add(preferences)
  6277	            db.commit()
  6278	            db.refresh(preferences)
  6279	            
  6280	        return schemas.EmailPreferencesResponse.from_orm(preferences)
  6281	        
  6282	    except Exception as e:
  6283	        logger.error(f"Error getting email preferences for player {player_id}: {e}")
  6284	        raise HTTPException(status_code=500, detail=f"Failed to get email preferences: {str(e)}")
  6285	    finally:
  6286	        db.close()
  6287	
  6288	@app.put("/players/{player_id}/email-preferences", response_model=schemas.EmailPreferencesResponse)
  6289	def update_email_preferences(player_id: int, preferences_update: schemas.EmailPreferencesUpdate):
  6290	    """Update a player's email preferences."""
  6291	    try:
  6292	        db = database.SessionLocal()
  6293	        
  6294	        preferences = db.query(models.EmailPreferences).filter(
  6295	            models.EmailPreferences.player_profile_id == player_id
  6296	        ).first()
  6297	        
  6298	        if not preferences:
  6299	            raise HTTPException(status_code=404, detail="Email preferences not found")
  6300	        
  6301	        # Update fields
  6302	        if preferences_update.daily_signups_enabled is not None:
  6303	            preferences.daily_signups_enabled = preferences_update.daily_signups_enabled
  6304	        if preferences_update.signup_confirmations_enabled is not None:
  6305	            preferences.signup_confirmations_enabled = preferences_update.signup_confirmations_enabled
  6306	        if preferences_update.signup_reminders_enabled is not None:
  6307	            preferences.signup_reminders_enabled = preferences_update.signup_reminders_enabled
  6308	        if preferences_update.game_invitations_enabled is not None:
  6309	            preferences.game_invitations_enabled = preferences_update.game_invitations_enabled
  6310	        if preferences_update.weekly_summary_enabled is not None:
  6311	            preferences.weekly_summary_enabled = preferences_update.weekly_summary_enabled
  6312	        if preferences_update.email_frequency is not None:
  6313	            preferences.email_frequency = preferences_update.email_frequency
  6314	        if preferences_update.preferred_notification_time is not None:
  6315	            preferences.preferred_notification_time = preferences_update.preferred_notification_time
  6316	            
  6317	        preferences.updated_at = datetime.now().isoformat()
  6318	        
  6319	        db.commit()
  6320	        db.refresh(preferences)
  6321	        
  6322	        logger.info(f"Updated email preferences for player {player_id}")
  6323	        return schemas.EmailPreferencesResponse.from_orm(preferences)
  6324	        
  6325	    except HTTPException:
  6326	        raise
  6327	    except Exception as e:
  6328	        db.rollback()
  6329	        logger.error(f"Error updating email preferences for player {player_id}: {e}")
  6330	        raise HTTPException(status_code=500, detail=f"Failed to update email preferences: {str(e)}")
  6331	    finally:
  6332	        db.close()
  6333	
  6334	# =============================================================================
  6335	# AUTHENTICATED EMAIL PREFERENCE ENDPOINTS  
  6336	# =============================================================================
  6337	
  6338	@app.get("/players/me/email-preferences", response_model=schemas.EmailPreferencesResponse)
  6339	async def get_my_email_preferences(current_user: models.PlayerProfile = Depends(get_current_user)):
  6340	    """Get current user's email preferences"""
  6341	    db = database.SessionLocal()
  6342	    try:
  6343	        # Try to find existing preferences
  6344	        prefs = db.query(models.EmailPreferences).filter(
  6345	            models.EmailPreferences.player_profile_id == current_user.id
  6346	        ).first()
  6347	        
  6348	        if not prefs:
  6349	            # Create default preferences
  6350	            prefs = models.EmailPreferences(
  6351	                player_profile_id=current_user.id,
  6352	                created_at=datetime.now().isoformat(),
  6353	                updated_at=datetime.now().isoformat()
  6354	            )
  6355	            db.add(prefs)
  6356	            db.commit()
  6357	            db.refresh(prefs)
  6358	        
  6359	        return schemas.EmailPreferencesResponse(
  6360	            id=prefs.id,
  6361	            player_profile_id=prefs.player_profile_id,
  6362	            daily_signups_enabled=bool(prefs.daily_signups_enabled),
  6363	            signup_confirmations_enabled=bool(prefs.signup_confirmations_enabled),
  6364	            signup_reminders_enabled=bool(prefs.signup_reminders_enabled),
  6365	            game_invitations_enabled=bool(prefs.game_invitations_enabled),
  6366	            weekly_summary_enabled=bool(prefs.weekly_summary_enabled),
  6367	            email_frequency=prefs.email_frequency,
  6368	            preferred_notification_time=prefs.preferred_notification_time
  6369	        )
  6370	    except Exception as e:
  6371	        logger.error(f"Error getting email preferences for user {current_user.id}: {e}")
  6372	        raise HTTPException(status_code=500, detail=f"Failed to get email preferences: {str(e)}")
  6373	    finally:
  6374	        db.close()
  6375	
  6376	@app.put("/players/me/email-preferences", response_model=schemas.EmailPreferencesResponse)
  6377	async def update_my_email_preferences(
  6378	    preferences_update: schemas.EmailPreferencesUpdate,
  6379	    current_user: models.PlayerProfile = Depends(get_current_user)
  6380	):
  6381	    """Update current user's email preferences"""
  6382	    db = database.SessionLocal()
  6383	    try:
  6384	        # Find or create preferences
  6385	        prefs = db.query(models.EmailPreferences).filter(
  6386	            models.EmailPreferences.player_profile_id == current_user.id
  6387	        ).first()
  6388	        
  6389	        if not prefs:
  6390	            prefs = models.EmailPreferences(
  6391	                player_profile_id=current_user.id,
  6392	                created_at=datetime.now().isoformat()
  6393	            )
  6394	            db.add(prefs)
  6395	        
  6396	        # Update preferences
  6397	        update_data = preferences_update.dict(exclude_unset=True)
  6398	        for field, value in update_data.items():
  6399	            if hasattr(prefs, field):
  6400	                # Convert bool to int for SQLite
  6401	                if isinstance(value, bool):
  6402	                    value = 1 if value else 0
  6403	                setattr(prefs, field, value)
  6404	        
  6405	        prefs.updated_at = datetime.now().isoformat()
  6406	        db.commit()
  6407	        db.refresh(prefs)
  6408	        
  6409	        logger.info(f"Updated email preferences for user {current_user.id}")
  6410	        
  6411	        return schemas.EmailPreferencesResponse(
  6412	            id=prefs.id,
  6413	            player_profile_id=prefs.player_profile_id,
  6414	            daily_signups_enabled=bool(prefs.daily_signups_enabled),
  6415	            signup_confirmations_enabled=bool(prefs.signup_confirmations_enabled),
  6416	            signup_reminders_enabled=bool(prefs.signup_reminders_enabled),
  6417	            game_invitations_enabled=bool(prefs.game_invitations_enabled),
  6418	            weekly_summary_enabled=bool(prefs.weekly_summary_enabled),
  6419	            email_frequency=prefs.email_frequency,
  6420	            preferred_notification_time=prefs.preferred_notification_time
  6421	        )
  6422	    except Exception as e:
  6423	        logger.error(f"Error updating email preferences for user {current_user.id}: {e}")
  6424	        raise HTTPException(status_code=500, detail=f"Failed to update email preferences: {str(e)}")
  6425	    finally:
  6426	        db.close()
  6427	
  6428	# =============================================================================
  6429	# EMAIL ENDPOINTS
  6430	# =============================================================================
  6431	
  6432	@app.post("/email/send-test")
  6433	async def send_test_email(email_data: dict):
  6434	    """Send a test email to verify email service configuration"""
  6435	    try:
  6436	        email_service = get_email_service()
  6437	        
  6438	        if not email_service.is_configured:
  6439	            raise HTTPException(
  6440	                status_code=503, 
  6441	                detail="Email service not configured. Please set SMTP_USER, SMTP_PASSWORD, and SMTP_HOST environment variables."
  6442	            )
  6443	        
  6444	        to_email = email_data.get('to_email')
  6445	        if not to_email:
  6446	            raise HTTPException(status_code=400, detail="to_email is required")
  6447	            
  6448	        success = email_service.send_signup_confirmation(
  6449	            to_email=to_email,
  6450	            player_name=email_data.get('player_name', 'Test Player'),
  6451	            signup_date=email_data.get('signup_date', 'Tomorrow')
  6452	        )
  6453	        
  6454	        if success:
  6455	            return {"message": "Test email sent successfully", "to_email": to_email}
  6456	        else:
  6457	            raise HTTPException(status_code=500, detail="Failed to send test email")
  6458	            
  6459	    except HTTPException:
  6460	        raise
  6461	    except Exception as e:
  6462	        logger.error(f"Error sending test email: {e}")
  6463	        raise HTTPException(status_code=500, detail=f"Failed to send test email: {str(e)}")
  6464	
  6465	@app.get("/email/status")
  6466	async def get_email_service_status():
  6467	    """Check if email service is properly configured"""
  6468	    try:
  6469	        email_service = get_email_service()
  6470	        
  6471	        return {
  6472	            "configured": email_service.is_configured,
  6473	            "smtp_host": email_service.smtp_config.get('host', 'Not set'),
  6474	            "smtp_port": email_service.smtp_config.get('port', 'Not set'),
  6475	            "from_email": email_service.from_email or 'Not set',
  6476	            "from_name": email_service.from_name or 'Not set',
  6477	            "missing_config": [
  6478	                key for key in ['SMTP_USER', 'SMTP_PASSWORD', 'SMTP_HOST'] 
  6479	                if not os.getenv(key)
  6480	            ]
  6481	        }
  6482	        
  6483	    except Exception as e:
  6484	        logger.error(f"Error checking email service status: {e}")
  6485	        raise HTTPException(status_code=500, detail=f"Failed to check email status: {str(e)}")
  6486	
  6487	@app.post("/email/signup-confirmation")
  6488	async def send_signup_confirmation_email(email_data: dict):
  6489	    """Send signup confirmation email"""
  6490	    try:
  6491	        email_service = get_email_service()
  6492	        
  6493	        if not email_service.is_configured:
  6494	            raise HTTPException(status_code=503, detail="Email service not configured")
  6495	        
  6496	        required_fields = ['to_email', 'player_name', 'signup_date']
  6497	        missing_fields = [field for field in required_fields if not email_data.get(field)]
  6498	        
  6499	        if missing_fields:
  6500	            raise HTTPException(
  6501	                status_code=400, 
  6502	                detail=f"Missing required fields: {', '.join(missing_fields)}"
  6503	            )
  6504	        
  6505	        success = email_service.send_signup_confirmation(
  6506	            to_email=email_data['to_email'],
  6507	            player_name=email_data['player_name'],
  6508	            signup_date=email_data['signup_date']
  6509	        )
  6510	        
  6511	        if success:
  6512	            return {"message": "Signup confirmation email sent", "to_email": email_data['to_email']}
  6513	        else:
  6514	            raise HTTPException(status_code=500, detail="Failed to send signup confirmation email")
  6515	            
  6516	    except HTTPException:
  6517	        raise
  6518	    except Exception as e:
  6519	        logger.error(f"Error sending signup confirmation email: {e}")
  6520	        raise HTTPException(status_code=500, detail=f"Failed to send email: {str(e)}")
  6521	
  6522	@app.post("/email/daily-reminder")
  6523	async def send_daily_reminder_email(email_data: dict):
  6524	    """Send daily signup reminder email"""
  6525	    try:
  6526	        email_service = get_email_service()
  6527	        
  6528	        if not email_service.is_configured:
  6529	            raise HTTPException(status_code=503, detail="Email service not configured")
  6530	        
  6531	        required_fields = ['to_email', 'player_name']
  6532	        missing_fields = [field for field in required_fields if not email_data.get(field)]
  6533	        
  6534	        if missing_fields:
  6535	            raise HTTPException(
  6536	                status_code=400, 
  6537	                detail=f"Missing required fields: {', '.join(missing_fields)}"
  6538	            )
  6539	        
  6540	        success = email_service.send_daily_signup_reminder(
  6541	            to_email=email_data['to_email'],
  6542	            player_name=email_data['player_name'],
  6543	            available_dates=email_data.get('available_dates', [])
  6544	        )
  6545	        
  6546	        if success:
  6547	            return {"message": "Daily reminder email sent", "to_email": email_data['to_email']}
  6548	        else:
  6549	            raise HTTPException(status_code=500, detail="Failed to send daily reminder email")
  6550	            
  6551	    except HTTPException:
  6552	        raise
  6553	    except Exception as e:
  6554	        logger.error(f"Error sending daily reminder email: {e}")
  6555	        raise HTTPException(status_code=500, detail=f"Failed to send email: {str(e)}")
  6556	
  6557	@app.post("/email/weekly-summary")
  6558	async def send_weekly_summary_email(email_data: dict):
  6559	    """Send weekly summary email"""
  6560	    try:
  6561	        email_service = get_email_service()
  6562	        
  6563	        if not email_service.is_configured:
  6564	            raise HTTPException(status_code=503, detail="Email service not configured")
  6565	        
  6566	        required_fields = ['to_email', 'player_name']
  6567	        missing_fields = [field for field in required_fields if not email_data.get(field)]
  6568	        
  6569	        if missing_fields:
  6570	            raise HTTPException(
  6571	                status_code=400, 
  6572	                detail=f"Missing required fields: {', '.join(missing_fields)}"
  6573	            )
  6574	        
  6575	        success = email_service.send_weekly_summary(
  6576	            to_email=email_data['to_email'],
  6577	            player_name=email_data['player_name'],
  6578	            summary_data=email_data.get('summary_data', {})
  6579	        )
  6580	        
  6581	        if success:
  6582	            return {"message": "Weekly summary email sent", "to_email": email_data['to_email']}
  6583	        else:
  6584	            raise HTTPException(status_code=500, detail="Failed to send weekly summary email")
  6585	            
  6586	    except HTTPException:
  6587	        raise
  6588	
  6589	@app.post("/email/initialize-scheduler")
  6590	async def initialize_email_scheduler():
  6591	    """Initialize the email scheduler on demand"""
  6592	    global email_scheduler
  6593	    
  6594	    try:
  6595	        # Check if already initialized
  6596	        if email_scheduler is not None:
  6597	            return {
  6598	                "status": "already_initialized",
  6599	                "message": "Email scheduler is already running"
  6600	            }
  6601	        
  6602	        # Import and initialize the scheduler
  6603	        from .services.email_scheduler import email_scheduler as scheduler_instance
  6604	        email_scheduler = scheduler_instance
  6605	        email_scheduler.start()
  6606	        
  6607	        logger.info("ðŸ“§ Email scheduler initialized on demand")
  6608	        
  6609	        return {
  6610	            "status": "success",
  6611	            "message": "Email scheduler initialized successfully",
  6612	            "scheduled_jobs": ["daily_reminders", "weekly_summaries"]
  6613	        }
  6614	        
  6615	    except Exception as e:
  6616	        logger.error(f"Failed to initialize email scheduler: {str(e)}")
  6617	        raise HTTPException(
  6618	            status_code=500, 
  6619	            detail=f"Failed to initialize email scheduler: {str(e)}"
  6620	        )
  6621	
  6622	@app.get("/email/scheduler-status")
  6623	async def get_email_scheduler_status():
  6624	    """Get the status of the email scheduler"""
  6625	    global email_scheduler
  6626	    
  6627	    return {
  6628	        "initialized": email_scheduler is not None,
  6629	        "running": email_scheduler is not None and hasattr(email_scheduler, '_started') and email_scheduler._started,
  6630	        "message": "Scheduler running" if email_scheduler else "Scheduler not initialized. Call /email/initialize-scheduler to start."
  6631	    }
  6632	
  6633	# Static file serving for React frontend (must be at end after all API routes)
  6634	from pathlib import Path
  6635	
  6636	# Get the path to the built React app
  6637	STATIC_DIR = Path(__file__).parent.parent.parent / "frontend" / "build"
  6638	
  6639	# =============================================================================
  6640	# MATCHMAKING ENDPOINTS
  6641	# =============================================================================
  6642	
  6643	@app.get("/matchmaking/suggestions")
  6644	def get_match_suggestions(
  6645	    min_overlap_hours: float = 2.0,
  6646	    preferred_days: Optional[str] = None
  6647	):
  6648	    """
  6649	    Get matchmaking suggestions based on player availability.
  6650	    
  6651	    Args:
  6652	        min_overlap_hours: Minimum hours of overlap required (default 2)
  6653	        preferred_days: Comma-separated list of preferred days (0=Monday, 6=Sunday)
  6654	    """
  6655	    try:
  6656	        from .services.matchmaking_service import MatchmakingService
  6657	        
  6658	        db = database.SessionLocal()
  6659	        
  6660	        # Get all players' availability (reuse existing endpoint logic)
  6661	        players_with_availability = db.query(models.PlayerProfile).all()
  6662	        
  6663	        all_players_data = []
  6664	        for player in players_with_availability:
  6665	            player_data = {
  6666	                "player_id": player.id,
  6667	                "player_name": player.name,
  6668	                "email": player.email,
  6669	                "availability": []
  6670	            }
  6671	            
  6672	            availability = db.query(models.PlayerAvailability).filter(
  6673	                models.PlayerAvailability.player_profile_id == player.id
  6674	            ).all()
  6675	            
  6676	            for avail in availability:
  6677	                player_data["availability"].append({
  6678	                    "day_of_week": avail.day_of_week,
  6679	                    "is_available": avail.is_available,
  6680	                    "available_from_time": avail.available_from_time,
  6681	                    "available_to_time": avail.available_to_time,
  6682	                    "notes": avail.notes
  6683	                })
  6684	            
  6685	            all_players_data.append(player_data)
  6686	        
  6687	        # Parse preferred days if provided
  6688	        preferred_days_list = None
  6689	        if preferred_days:
  6690	            preferred_days_list = [int(d.strip()) for d in preferred_days.split(",")]
  6691	        
  6692	        # Find matches
  6693	        matches = MatchmakingService.find_matches(
  6694	            all_players_data,
  6695	            min_overlap_hours=min_overlap_hours,
  6696	            preferred_days=preferred_days_list
  6697	        )
  6698	        
  6699	        # Get recent match history to filter out recently matched players
  6700	        recent_matches = db.query(models.MatchSuggestion).filter(
  6701	            models.MatchSuggestion.created_at >= (datetime.now() - timedelta(days=7)).isoformat()
  6702	        ).all()
  6703	        
  6704	        # Convert to format expected by filter function
  6705	        recent_match_history = []
  6706	        for match in recent_matches:
  6707	            match_players = db.query(models.MatchPlayer).filter(
  6708	                models.MatchPlayer.match_suggestion_id == match.id
  6709	            ).all()
  6710	            
  6711	            recent_match_history.append({
  6712	                "created_at": match.created_at,
  6713	                "players": [{"player_id": mp.player_profile_id} for mp in match_players]
  6714	            })
  6715	        
  6716	        # Filter out recently matched players
  6717	        filtered_matches = MatchmakingService.filter_recent_matches(
  6718	            matches, recent_match_history, days_between_matches=3
  6719	        )
  6720	        
  6721	        return {
  6722	            "total_matches_found": len(matches),
  6723	            "filtered_matches": len(filtered_matches),
  6724	            "matches": filtered_matches[:10]  # Return top 10 matches
  6725	        }
  6726	        
  6727	    except Exception as e:
  6728	        logger.error(f"Error finding match suggestions: {e}")
  6729	        raise HTTPException(status_code=500, detail=f"Failed to find matches: {str(e)}")
  6730	    finally:
  6731	        db.close()
  6732	
  6733	@app.post("/matchmaking/create-and-notify")
  6734	async def create_and_notify_matches():
  6735	    """
  6736	    Run the full matchmaking process: find matches and send notifications.
  6737	    This endpoint can be called by a scheduler or manually.
  6738	    """
  6739	    try:
  6740	        # First, find matches
  6741	        matches_response = get_match_suggestions(min_overlap_hours=2.0)
  6742	        
  6743	        if not matches_response["matches"]:
  6744	            return {
  6745	                "message": "No suitable matches found",
  6746	                "matches_checked": matches_response["total_matches_found"]
  6747	            }
  6748	        
  6749	        db = database.SessionLocal()
  6750	        email_service = get_email_service()
  6751	        
  6752	        # Save the top matches to database
  6753	        saved_matches = []
  6754	        notifications_sent = []
  6755	        
  6756	        for match_data in matches_response["matches"][:5]:  # Save top 5 matches
  6757	            try:
  6758	                # Create match suggestion
  6759	                match = models.MatchSuggestion(
  6760	                    day_of_week=match_data["day_of_week"],
  6761	                    overlap_start=match_data["overlap_start"],
  6762	                    overlap_end=match_data["overlap_end"],
  6763	                    suggested_tee_time=match_data["suggested_tee_time"],
  6764	                    match_quality_score=match_data["match_quality"],
  6765	                    status="pending",
  6766	                    created_at=datetime.now().isoformat(),
  6767	                    expires_at=(datetime.now() + timedelta(days=7)).isoformat()
  6768	                )
  6769	                db.add(match)
  6770	                db.commit()
  6771	                db.refresh(match)
  6772	                
  6773	                # Add players to match
  6774	                for player in match_data["players"]:
  6775	                    match_player = models.MatchPlayer(
  6776	                        match_suggestion_id=match.id,
  6777	                        player_profile_id=player["player_id"],
  6778	                        player_name=player["player_name"],
  6779	                        player_email=player["email"],
  6780	                        created_at=datetime.now().isoformat()
  6781	                    )
  6782	                    db.add(match_player)
  6783	                
  6784	                db.commit()
  6785	                saved_matches.append(match.id)
  6786	                
  6787	                # Send notification email
  6788	                from .services.matchmaking_service import MatchmakingService
  6789	                notification = MatchmakingService.create_match_notification(match_data)
  6790	                
  6791	                # Send email to all players
  6792	                try:
  6793	                    for recipient in notification['recipients']:
  6794	                        await email_service.send_email(
  6795	                            to_email=recipient,
  6796	                            subject=notification['subject'],
  6797	                            body=notification['body']
  6798	                        )
  6799	                    
  6800	                    # Mark as sent
  6801	                    match.notification_sent = True
  6802	                    match.notification_sent_at = datetime.now().isoformat()
  6803	                    db.commit()
  6804	                    
  6805	                    notifications_sent.append({
  6806	                        "match_id": match.id,
  6807	                        "players": [p["player_name"] for p in match_data["players"]],
  6808	                        "status": "sent"
  6809	                    })
  6810	                    
  6811	                    logger.info(f"Sent match notification for match {match.id}")
  6812	                    
  6813	                except Exception as e:
  6814	                    logger.error(f"Failed to send notification for match {match.id}: {e}")
  6815	                    notifications_sent.append({
  6816	                        "match_id": match.id,
  6817	                        "players": [p["player_name"] for p in match_data["players"]],
  6818	                        "status": "failed",
  6819	                        "error": str(e)
  6820	                    })
  6821	                    
  6822	            except Exception as e:
  6823	                logger.error(f"Error creating match: {e}")
  6824	                continue
  6825	        
  6826	        return {
  6827	            "matches_found": matches_response["total_matches_found"],
  6828	            "matches_created": len(saved_matches),
  6829	            "notifications_sent": len([n for n in notifications_sent if n["status"] == "sent"]),
  6830	            "notifications_failed": len([n for n in notifications_sent if n["status"] == "failed"]),
  6831	            "match_ids": saved_matches,
  6832	            "details": notifications_sent
  6833	        }
  6834	        
  6835	    except Exception as e:
  6836	        logger.error(f"Error in create and notify matches: {e}")
  6837	        raise HTTPException(status_code=500, detail=f"Failed to create and notify matches: {str(e)}")
  6838	    finally:
  6839	        if 'db' in locals():
  6840	            db.close()
  6841	
  6842	if ENABLE_TEST_ENDPOINTS:
  6843	
  6844	    @app.get("/test-deployment")
  6845	    async def test_deployment(x_admin_email: Optional[str] = Header(None)):
  6846	        """Test that new deployments are working"""
  6847	        require_admin(x_admin_email)
  6848	        return {"message": "Deployment is working", "timestamp": datetime.now().isoformat()}
  6849	
  6850	    @app.get("/debug/paths")
  6851	    async def debug_paths(x_admin_email: Optional[str] = Header(None)):
  6852	        """Debug endpoint to check file paths"""
  6853	        require_admin(x_admin_email)
  6854	        current_file = Path(__file__).resolve()
  6855	        static_dir = STATIC_DIR.resolve()
  6856	        index_file = static_dir / "index.html"
  6857	
  6858	        return {
  6859	            "current_file": str(current_file),
  6860	            "static_dir": str(static_dir),
  6861	            "static_dir_exists": static_dir.exists(),
  6862	            "index_file": str(index_file),
  6863	            "index_file_exists": index_file.exists(),
  6864	            "static_dir_contents": list(static_dir.iterdir()) if static_dir.exists() else []
  6865	        }
  6866	
  6867	# Mount static files if build directory exists
  6868	static_assets_dir = STATIC_DIR / "static"
  6869	
  6870	if STATIC_DIR.exists() and static_assets_dir.exists():
  6871	    app.mount("/static", StaticFiles(directory=str(static_assets_dir)), name="static")
  6872	else:
  6873	    logger.warning(
  6874	        "Frontend static assets not found. Expected %s", static_assets_dir
  6875	    )
  6876	
  6877	
  6878	@app.get("/", response_class=HTMLResponse)
  6879	async def serve_homepage():
  6880	    """Serve the built frontend when available, otherwise render a helpful status page."""
  6881	    index_file = STATIC_DIR / "index.html"
  6882	    if index_file.exists():
  6883	        return FileResponse(str(index_file))
  6884	
  6885	    frontend_url = (
  6886	        os.getenv("PUBLIC_FRONTEND_URL")
  6887	        or os.getenv("FRONTEND_BASE_URL")
  6888	        or "https://wolf-goat-pig.vercel.app"
  6889	    )
  6890	
  6891	    docs_link = ""
  6892	    if app.docs_url:
  6893	        docs_link = f'<li><a href="{app.docs_url}">Interactive API docs</a></li>'
  6894	
  6895	    html = f"""
  6896	    <!DOCTYPE html>
  6897	    <html lang="en">
  6898	      <head>
  6899	        <meta charset="utf-8" />
  6900	        <meta name="viewport" content="width=device-width, initial-scale=1" />
  6901	        <title>Wolf Goat Pig API</title>
  6902	        <style>
  6903	          body {{
  6904	            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  6905	            margin: 0;
  6906	            padding: 0;
  6907	            display: flex;
  6908	            justify-content: center;
  6909	            align-items: center;
  6910	            min-height: 100vh;
  6911	            background: #0f172a;
  6912	            color: #e2e8f0;
  6913	          }}
  6914	          .card {{
  6915	            background: rgba(15, 23, 42, 0.9);
  6916	            border-radius: 16px;
  6917	            padding: 32px;
  6918	            max-width: 520px;
  6919	            box-shadow: 0 20px 45px rgba(15, 23, 42, 0.4);
  6920	            border: 1px solid rgba(148, 163, 184, 0.2);
  6921	          }}
  6922	          h1 {{
  6923	            margin-top: 0;
  6924	            font-size: 1.75rem;
  6925	            letter-spacing: 0.02em;
  6926	          }}
  6927	          p {{
  6928	            line-height: 1.55;
  6929	            margin-bottom: 1.25rem;
  6930	            color: #cbd5f5;
  6931	          }}
  6932	          ul {{
  6933	            padding-left: 1.2rem;
  6934	            margin: 0 0 1.25rem 0;
  6935	          }}
  6936	          a {{
  6937	            color: #38bdf8;
  6938	            text-decoration: none;
  6939	            font-weight: 600;
  6940	          }}
  6941	          a:hover {{
  6942	            text-decoration: underline;
  6943	          }}
  6944	          .meta {{
  6945	            font-size: 0.85rem;
  6946	            color: #94a3b8;
  6947	          }}
  6948	        </style>
  6949	      </head>
  6950	      <body>
  6951	        <main class="card">
  6952	          <h1>Wolf Goat Pig API</h1>
  6953	          <p>
  6954	            The backend is running and healthy. The interactive frontend lives on our
  6955	            Vercel deployment â€” you can reach it here:
  6956	          </p>
  6957	          <ul>
  6958	            <li><a href="{frontend_url}" target="_blank" rel="noopener">Open the production app</a></li>
  6959	            {docs_link}
  6960	          </ul>
  6961	          <p class="meta">Last checked: {datetime.utcnow().isoformat()}Z</p>
  6962	        </main>
  6963	      </body>
  6964	    </html>
  6965	    """
  6966	
  6967	    return HTMLResponse(content=html, status_code=200)
