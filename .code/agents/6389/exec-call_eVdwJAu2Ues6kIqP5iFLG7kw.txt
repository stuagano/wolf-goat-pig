🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
============================= test session starts ==============================
platform darwin -- Python 3.13.3, pytest-8.4.1, pluggy-1.6.0
rootdir: /Users/stuartgano/Documents/wolf-goat-pig
plugins: mock-3.15.1, html-4.1.1, asyncio-1.1.0, metadata-3.1.1, anyio-4.10.0
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 188 items

tests/backend/test_aardvark.py ...                                       [  1%]
tests/backend/test_advanced_rules.py .................F                  [ 11%]
tests/backend/test_analytics.py .                                        [ 11%]
tests/backend/test_api.py ...                                            [ 13%]
tests/backend/test_api_endpoints.py F.FFF.FF.....F.....F                 [ 23%]
tests/backend/test_api_simple.py F.F.....F...                            [ 30%]
tests/backend/test_api_working.py F.....F....                            [ 36%]
tests/backend/test_basic_functionality.py .................              [ 45%]
tests/backend/test_course_data.py .                                      [ 45%]
tests/backend/test_debug.py .                                            [ 46%]
tests/backend/test_debug_api.py .                                        [ 46%]
tests/backend/test_final_implementation.py .                             [ 47%]
tests/backend/test_full_game_flow.py ...FFFFFF                           [ 52%]
tests/backend/test_ghin_local.py F                                       [ 52%]
tests/backend/test_hole_state_mechanics.py .........                     [ 57%]
tests/backend/test_integration_scenarios.py ........                     [ 61%]
tests/backend/test_shot_range_analysis.py .....                          [ 64%]
tests/backend/test_simulation_components.py FF..FFF                      [ 68%]
tests/backend/test_simulation_components_fixed.py FFFFFF.FF.FFF.FF.FFF   [ 78%]
tests/backend/test_simulation_courses.py .                               [ 79%]
tests/backend/test_simulation_state_endpoint.py .FFFFFFFFFFFFFFFFFFFFFF  [ 91%]
tests/backend/test_unified_action_api.py FFFFFFFFFFFFFF                  [ 98%]
tests/backend/test_wgp_direct.py ..                                      [100%]

=================================== FAILURES ===================================
_______________ TestAdvancedWGPRules.test_6_man_goat_restriction _______________

self = <test_advanced_rules.TestAdvancedWGPRules object at 0x10c043750>

    def test_6_man_goat_restriction(self):
        """Test that the goat cannot choose the same position more than twice in a row in a 6-man game"""
        # Create a 6-player simulation
        simulation_6 = WolfGoatPigSimulation(player_count=6)
        players = [WGPPlayer(f"p{i}", f"Player{i}", 10.0) for i in range(1, 7)]
        simulation_6.players = players
    
        # Set the game to the Hoepfinger phase
        simulation_6.current_hole = 13
        simulation_6._initialize_hole(13)
    
        # Get the goat and the current hitting order
        goat = simulation_6._get_goat()
        current_order = simulation_6.hole_states[13].hitting_order
    
        # Set the goat's position history to have the same position twice
        goat.goat_position_history = [1, 1]
    
        # Call the _goat_chooses_position method 10 times to ensure the restriction is enforced
        for _ in range(10):
            new_order = simulation_6._goat_chooses_position(goat, current_order)
            chosen_position = new_order.index(goat.id)
>           assert chosen_position != 1
E           assert 1 != 1

tests/backend/test_advanced_rules.py:311: AssertionError
____________________ TestHealthEndpoints.test_health_check _____________________

self = <test_api_endpoints.TestHealthEndpoints object at 0x10c01f890>
client = <starlette.testclient.TestClient object at 0x10e8f1a70>

    def test_health_check(self, client):
        response = client.get("/health")
        assert response.status_code == 200
>       assert response.json()["status"] == "healthy"
E       AssertionError: assert 'degraded' == 'healthy'
E         
E         - healthy
E         + degraded

tests/backend/test_api_endpoints.py:34: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:506 AI players availability check failed: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT count(*) AS count_1 
FROM (SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.is_ai = ? AND player_profiles.is_active = ?) AS anon_1]
[parameters: (1, 1)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR    app.seed_data:seed_data.py:423 Error verifying seeded data: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT count(*) AS count_1 
FROM (SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.is_ai = ?) AS anon_1]
[parameters: (1,)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
____________________ TestCourseManagement.test_get_courses _____________________

self = <test_api_endpoints.TestCourseManagement object at 0x10e8051d0>
client = <starlette.testclient.TestClient object at 0x10eb02580>

    def test_get_courses(self, client):
        response = client.get("/courses")
        assert response.status_code == 200
        data = response.json()
>       assert isinstance(data, list)
E       AssertionError: assert False
E        +  where False = isinstance({'Championship Links': {'hole_count': 18, 'holes': [{'description': 'Opening hole with wide fairway but challenging ap...e_number': 6, 'par': 4, 'stroke_index': 9, ...}, ...], 'name': 'Wing Point Golf & Country Club', 'total_par': 71, ...}}, list)

tests/backend/test_api_endpoints.py:51: AssertionError
_____________________ TestCourseManagement.test_add_course _____________________

self = <test_api_endpoints.TestCourseManagement object at 0x10e805310>
client = <starlette.testclient.TestClient object at 0x10eb02690>

    def test_add_course(self, client):
        new_course = {
            "name": "Test Golf Club",
            "holes": [
                {"hole": i, "par": 4, "yards": 400, "stroke_index": i}
                for i in range(1, 19)
            ]
        }
    
        response = client.post("/courses", json=new_course)
>       assert response.status_code == 200
E       assert 500 == 200
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

tests/backend/test_api_endpoints.py:65: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:763 Error adding course: Each hole must have hole_number, par, yards, and stroke_index
ERROR    app.main:main.py:200 HTTP exception: 500 - Failed to add course: Each hole must have hole_number, par, yards, and stroke_index
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
___________________ TestCourseManagement.test_update_course ____________________

self = <test_api_endpoints.TestCourseManagement object at 0x10c0f03e0>
client = <starlette.testclient.TestClient object at 0x10eb7cd50>

    def test_update_course(self, client):
        # First add a course
        new_course = {
            "name": "Update Test Club",
            "holes": [
                {"hole": i, "par": 4, "yards": 400, "stroke_index": i}
                for i in range(1, 19)
            ]
        }
        client.post("/courses", json=new_course)
    
        # Update it
        update_data = {
            "holes": [
                {"hole": i, "par": 3 if i % 3 == 0 else 4, "yards": 350, "stroke_index": i}
                for i in range(1, 19)
            ]
        }
    
        response = client.put("/courses/Update Test Club", json=update_data)
>       assert response.status_code == 200
E       assert 500 == 200
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

tests/backend/test_api_endpoints.py:89: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:763 Error adding course: Each hole must have hole_number, par, yards, and stroke_index
ERROR    app.main:main.py:200 HTTP exception: 500 - Failed to add course: Each hole must have hole_number, par, yards, and stroke_index
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
ERROR    app.main:main.py:773 Error updating course: Course 'Update Test Club' not found
ERROR    app.main:main.py:200 HTTP exception: 500 - Failed to update course: Course 'Update Test Club' not found
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
_______________________ TestGameEndpoints.test_get_rules _______________________

self = <test_api_endpoints.TestGameEndpoints object at 0x10e805450>
client = <starlette.testclient.TestClient object at 0x10ec414f0>

    def test_get_rules(self, client):
        response = client.get("/rules")
        assert response.status_code == 200
        rules = response.json()
        assert isinstance(rules, list)
        # Should have seeded rules
>       assert len(rules) > 0
E       assert 0 > 0
E        +  where 0 = len([])

tests/backend/test_api_endpoints.py:118: AssertionError
____________________ TestGameEndpoints.test_get_game_state _____________________

self = <test_api_endpoints.TestGameEndpoints object at 0x10e805590>
client = <starlette.testclient.TestClient object at 0x10ec42120>

    def test_get_game_state(self, client):
        response = client.get("/game/state")
        assert response.status_code == 200
        state = response.json()
        assert "players" in state
        assert "current_hole" in state
>       assert "game_started" in state
E       AssertionError: assert 'game_started' in {'_last_points': {'p1': 0, 'p2': 0, 'p3': 0, 'p4': 0}, 'base_wager': 1, 'betting_state': {'base_wager': 1, 'doubled_status': False, 'game_phase': 'Regular', 'teams': {}}, 'captain_id': 'p1', ...}

tests/backend/test_api_endpoints.py:126: AssertionError
_____________ TestUnifiedActionAPI.test_request_partnership_action _____________

self = <test_api_endpoints.TestUnifiedActionAPI object at 0x10e7f82b0>
client = <starlette.testclient.TestClient object at 0x10ebfa190>

    def test_request_partnership_action(self, client):
        # Initialize game first
        init_action = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": [
                    {"id": "p1", "name": "Alice", "handicap": 10},
                    {"id": "p2", "name": "Bob", "handicap": 15},
                    {"id": "p3", "name": "Charlie", "handicap": 18},
                    {"id": "p4", "name": "David", "handicap": 20}
                ]
            }
        }
        client.post("/wgp/test-game/action", json=init_action)
    
        # Request partnership
        partnership_action = {
            "action_type": "REQUEST_PARTNERSHIP",
            "payload": {"target_player_name": "Bob"}
        }
    
        response = client.post("/wgp/test-game/action", json=partnership_action)
>       assert response.status_code == 200
E       assert 500 == 200
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

tests/backend/test_api_endpoints.py:229: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:1702 Error requesting partnership: Captain cannot partner with themselves
ERROR    app.main:main.py:200 HTTP exception: 500 - Failed to request partnership: Captain cannot partner with themselves
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
________________ TestErrorHandling.test_missing_required_fields ________________

self = <test_api_endpoints.TestErrorHandling object at 0x10e805d10>
client = <starlette.testclient.TestClient object at 0x10ebfbd90>

    def test_missing_required_fields(self, client):
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": [
                    {"id": "p1"},  # Missing name and handicap
                    {"id": "p2", "name": "Bob"},  # Missing handicap
                    {"id": "p3", "name": "Charlie", "handicap": 18},
                    {"id": "p4", "name": "David", "handicap": 20}
                ]
            }
        }
    
        response = client.post("/wgp/test-game/action", json=action_data)
>       assert response.status_code == 400
E       assert 200 == 400
E        +  where 200 = <Response [200 OK]>.status_code

tests/backend/test_api_endpoints.py:325: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1187 Player 1 missing name, using default
WARNING  app.main:main.py:1191 Player Player 1 missing handicap, using default 18.0
WARNING  app.main:main.py:1191 Player Bob missing handicap, using default 18.0
___________________ TestBasicEndpoints.test_health_endpoint ____________________

self = <test_api_simple.TestBasicEndpoints object at 0x10e8060d0>

    def test_health_endpoint(self):
        """Test health check endpoint"""
        with TestClient(app) as client:
            response = client.get("/health")
            assert response.status_code == 200
            data = response.json()
>           assert data["status"] == "healthy"
E           AssertionError: assert 'degraded' == 'healthy'
E             
E             - healthy
E             + degraded

tests/backend/test_api_simple.py:23: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.seed_data:seed_data.py:423 Error verifying seeded data: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT count(*) AS count_1 
FROM (SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.is_ai = ?) AS anon_1]
[parameters: (1,)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR    app.seed_data:seed_data.py:257 Error seeding AI personalities: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.name = ?
 LIMIT ? OFFSET ?]
[parameters: ('Bob', 1, 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR    app.seed_data:seed_data.py:531 Critical error during data seeding: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.name = ?
 LIMIT ? OFFSET ?]
[parameters: ('Bob', 1, 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR    app.main:main.py:371 ❌ Data seeding failed: Seeding failed: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.name = ?
 LIMIT ? OFFSET ?]
[parameters: ('Bob', 1, 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
WARNING  app.main:main.py:372 🔄 Application will continue with fallback data
ERROR    app.main:main.py:506 AI players availability check failed: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT count(*) AS count_1 
FROM (SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.is_ai = ? AND player_profiles.is_active = ?) AS anon_1]
[parameters: (1, 1)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR    app.seed_data:seed_data.py:423 Error verifying seeded data: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT count(*) AS count_1 
FROM (SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.is_ai = ?) AS anon_1]
[parameters: (1,)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
_____________________ TestBasicEndpoints.test_get_courses ______________________

self = <test_api_simple.TestBasicEndpoints object at 0x10e7f8510>

    def test_get_courses(self):
        """Test getting available courses"""
        with TestClient(app) as client:
            response = client.get("/courses")
            assert response.status_code == 200
            courses = response.json()
>           assert isinstance(courses, list)
E           AssertionError: assert False
E            +  where False = isinstance({'Championship Links': {'hole_count': 18, 'holes': [{'description': 'Opening hole with wide fairway but challenging ap...e_number': 6, 'par': 4, 'stroke_index': 9, ...}, ...], 'name': 'Wing Point Golf & Country Club', 'total_par': 71, ...}}, list)

tests/backend/test_api_simple.py:40: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.seed_data:seed_data.py:423 Error verifying seeded data: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT count(*) AS count_1 
FROM (SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.is_ai = ?) AS anon_1]
[parameters: (1,)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR    app.seed_data:seed_data.py:257 Error seeding AI personalities: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.name = ?
 LIMIT ? OFFSET ?]
[parameters: ('Bob', 1, 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR    app.seed_data:seed_data.py:531 Critical error during data seeding: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.name = ?
 LIMIT ? OFFSET ?]
[parameters: ('Bob', 1, 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR    app.main:main.py:371 ❌ Data seeding failed: Seeding failed: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.name = ?
 LIMIT ? OFFSET ?]
[parameters: ('Bob', 1, 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
WARNING  app.main:main.py:372 🔄 Application will continue with fallback data
WARNING  app.main:main.py:321 ⚠️ Email scheduler: Email scheduler is already running
___________________ TestCourseEndpoints.test_add_new_course ____________________

self = <test_api_simple.TestCourseEndpoints object at 0x10e806490>

    def test_add_new_course(self):
        """Test adding a new course"""
        with TestClient(app) as client:
            course_data = {
                "name": "Test Golf Course",
                "holes": [
                    {"hole": i, "par": 4, "yards": 400, "stroke_index": i}
                    for i in range(1, 19)
                ]
            }
    
            response = client.post("/courses", json=course_data)
>           assert response.status_code == 200
E           assert 500 == 200
E            +  where 500 = <Response [500 Internal Server Error]>.status_code

tests/backend/test_api_simple.py:154: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.seed_data:seed_data.py:423 Error verifying seeded data: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT count(*) AS count_1 
FROM (SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.is_ai = ?) AS anon_1]
[parameters: (1,)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR    app.seed_data:seed_data.py:257 Error seeding AI personalities: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.name = ?
 LIMIT ? OFFSET ?]
[parameters: ('Bob', 1, 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR    app.seed_data:seed_data.py:531 Critical error during data seeding: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.name = ?
 LIMIT ? OFFSET ?]
[parameters: ('Bob', 1, 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR    app.main:main.py:371 ❌ Data seeding failed: Seeding failed: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.name = ?
 LIMIT ? OFFSET ?]
[parameters: ('Bob', 1, 0)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
WARNING  app.main:main.py:372 🔄 Application will continue with fallback data
WARNING  app.main:main.py:321 ⚠️ Email scheduler: Email scheduler is already running
ERROR    app.main:main.py:763 Error adding course: Each hole must have hole_number, par, yards, and stroke_index
ERROR    app.main:main.py:200 HTTP exception: 500 - Failed to add course: Each hole must have hole_number, par, yards, and stroke_index
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
__________________ TestWorkingEndpoints.test_health_endpoint ___________________

self = <test_api_working.TestWorkingEndpoints object at 0x10e806c10>

    def test_health_endpoint(self):
        """Test health check endpoint"""
        client = TestClient(app)
        response = client.get("/health")
        assert response.status_code == 200
        data = response.json()
>       assert data["status"] == "healthy"
E       AssertionError: assert 'degraded' == 'healthy'
E         
E         - healthy
E         + degraded

tests/backend/test_api_working.py:25: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:506 AI players availability check failed: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT count(*) AS count_1 
FROM (SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.is_ai = ? AND player_profiles.is_active = ?) AS anon_1]
[parameters: (1, 1)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR    app.seed_data:seed_data.py:423 Error verifying seeded data: (sqlite3.OperationalError) no such column: player_profiles.email
[SQL: SELECT count(*) AS count_1 
FROM (SELECT player_profiles.id AS player_profiles_id, player_profiles.name AS player_profiles_name, player_profiles.email AS player_profiles_email, player_profiles.handicap AS player_profiles_handicap, player_profiles.ghin_id AS player_profiles_ghin_id, player_profiles.ghin_last_updated AS player_profiles_ghin_last_updated, player_profiles.avatar_url AS player_profiles_avatar_url, player_profiles.created_at AS player_profiles_created_at, player_profiles.updated_at AS player_profiles_updated_at, player_profiles.last_played AS player_profiles_last_played, player_profiles.preferences AS player_profiles_preferences, player_profiles.is_active AS player_profiles_is_active, player_profiles.is_ai AS player_profiles_is_ai, player_profiles.playing_style AS player_profiles_playing_style, player_profiles.description AS player_profiles_description, player_profiles.personality_traits AS player_profiles_personality_traits, player_profiles.strengths AS player_profiles_strengths, player_profiles.weaknesses AS player_profiles_weaknesses 
FROM player_profiles 
WHERE player_profiles.is_ai = ?) AS anon_1]
[parameters: (1,)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
________________ TestUnifiedActionAPI.test_invalid_player_count ________________

self = <test_api_working.TestUnifiedActionAPI object at 0x10e806e90>

    def test_invalid_player_count(self):
        """Test that invalid player count is rejected"""
        client = TestClient(app)
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": [
                    {"id": "p1", "name": "Alice", "handicap": 10, "strength": 8}
                ],
                "course_name": "Wing Point Golf & Country Club"
            }
        }
    
        response = client.post("/wgp/test-game/action", json=action_data)
        # The error is wrapped in a 500, but the message should contain the validation
>       assert response.status_code == 500
E       assert 400 == 500
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests/backend/test_api_working.py:107: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:200 HTTP exception: 400 - 4, 5, or 6 players required.
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
___________________ TestMultiHoleGame.test_play_three_holes ____________________

self = <test_full_game_flow.TestMultiHoleGame object at 0x10e86ca50>
client = <starlette.testclient.TestClient object at 0x10ebfb310>
initialized_game = {'available_actions': [{'action_type': 'PLAY_SHOT', 'player_turn': 'Alice', 'prompt': 'Start first hole'}], 'game_stat...: 20.0, 'id': 'p4', 'name': 'David', 'strength': 4}]}, 'id': 'init_1', 'timestamp': '2025-10-20T07:48:05.873636', ...}}

    def test_play_three_holes(self, client, initialized_game):
        """Test playing through three complete holes"""
        game_id = "test-game"
        holes_completed = 0
    
        while holes_completed < 3:
            # Play shots until hole is complete
            shots_in_hole = 0
            hole_complete = False
    
            while shots_in_hole < 30 and not hole_complete:  # Safety limit
                response = client.post(f"/wgp/{game_id}/action", json={
                    "action_type": "PLAY_SHOT"
                })
    
                if response.status_code != 200:
                    # Might need to handle other actions
                    available_actions = response.json().get("available_actions", [])
                    if available_actions:
                        # Take the first available action
                        action = available_actions[0]
                        response = client.post(f"/wgp/{game_id}/action", json={
                            "action_type": action["action_type"],
                            "payload": action.get("payload", {})
                        })
    
                # Check if we can enter scores
                available_actions = response.json().get("available_actions", [])
                score_actions = [a for a in available_actions if a["action_type"] == "ENTER_HOLE_SCORES"]
    
                if score_actions:
                    # Enter scores
                    scores = {"p1": 4, "p2": 5, "p3": 4, "p4": 6}
                    response = client.post(f"/wgp/{game_id}/action", json={
                        "action_type": "ENTER_HOLE_SCORES",
                        "payload": {"scores": scores}
                    })
>                   assert response.status_code == 200
E                   assert 500 == 200
E                    +  where 500 = <Response [500 Internal Server Error]>.status_code

tests/backend/test_full_game_flow.py:197: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:2240 Error entering hole scores: Invalid team type for points calculation: pending
ERROR    app.main:main.py:200 HTTP exception: 500 - Failed to enter hole scores: Invalid team type for points calculation: pending
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
__________________ TestSpecialScenarios.test_hole_18_big_dick __________________

self = <test_full_game_flow.TestSpecialScenarios object at 0x10e86cb90>
client = <starlette.testclient.TestClient object at 0x10eccd390>

    def test_hole_18_big_dick(self, client):
        """Test Big Dick challenge on hole 18"""
        # Initialize game
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": [
                    {"id": "p1", "name": "Alice", "handicap": 10},
                    {"id": "p2", "name": "Bob", "handicap": 15},
                    {"id": "p3", "name": "Charlie", "handicap": 18},
                    {"id": "p4", "name": "David", "handicap": 20}
                ]
            }
        }
    
        response = client.post("/wgp/test-game/action", json=action_data)
        assert response.status_code == 200
    
        # Manually set to hole 18 (would need backend support for this)
        # For now, we'll just test the action endpoints exist
    
        # Test Big Dick offer
        response = client.post("/wgp/test-game/action", json={
            "action_type": "OFFER_BIG_DICK",
            "payload": {"player_id": "p1"}
        })
        # Should fail if not on hole 18, but endpoint should exist
>       assert response.status_code in [200, 400]
E       assert 500 in [200, 400]
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

tests/backend/test_full_game_flow.py:247: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:1999 Error offering Big Dick: Big Dick can only be offered on hole 18
ERROR    app.main:main.py:200 HTTP exception: 500 - Failed to offer Big Dick: Big Dick can only be offered on hole 18
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
________________ TestSpecialScenarios.test_analytics_retrieval _________________

self = <test_full_game_flow.TestSpecialScenarios object at 0x10e86ccd0>
client = <starlette.testclient.TestClient object at 0x10ece17f0>
initialized_game = {'available_actions': [{'action_type': 'PLAY_SHOT', 'player_turn': 'Alice', 'prompt': 'Start first hole'}], 'game_stat...: 20.0, 'id': 'p4', 'name': 'David', 'strength': 4}]}, 'id': 'init_1', 'timestamp': '2025-10-20T07:48:05.909951', ...}}

    def test_analytics_retrieval(self, client, initialized_game):
        """Test getting analytics during game"""
        game_id = "test-game"
    
        # Play some shots first
        for _ in range(5):
            client.post(f"/wgp/{game_id}/action", json={
                "action_type": "PLAY_SHOT"
            })
    
        # Get analytics
        response = client.post(f"/wgp/{game_id}/action", json={
            "action_type": "GET_ADVANCED_ANALYTICS"
        })
        assert response.status_code == 200
    
        analytics = response.json()["game_state"].get("analytics", {})
>       assert "player_performance" in analytics
E       AssertionError: assert 'player_performance' in {'betting_analysis': {'average_wager': 0.0, 'max_wager': 0, 'risk_reward_analysis': {}, 'special_rules_frequency': {},..._points': 0, ...}, 'p4': {'average_per_hole': 0.0, 'best_hole': 0, 'consistency': 0.5, 'current_points': 0, ...}}, ...}

tests/backend/test_full_game_flow.py:266: AssertionError
_________________ TestSpecialScenarios.test_post_hole_analysis _________________

self = <test_full_game_flow.TestSpecialScenarios object at 0x10e7f9a70>
client = <starlette.testclient.TestClient object at 0x10ece0210>
initialized_game = {'available_actions': [{'action_type': 'PLAY_SHOT', 'player_turn': 'Alice', 'prompt': 'Start first hole'}], 'game_stat...: 20.0, 'id': 'p4', 'name': 'David', 'strength': 4}]}, 'id': 'init_1', 'timestamp': '2025-10-20T07:48:05.922310', ...}}

    def test_post_hole_analysis(self, client, initialized_game):
        """Test getting post-hole analysis"""
        game_id = "test-game"
    
        # Play through a hole (simplified)
        for _ in range(10):
            response = client.post(f"/wgp/{game_id}/action", json={
                "action_type": "PLAY_SHOT"
            })
    
            available_actions = response.json().get("available_actions", [])
            if any(a["action_type"] == "ENTER_HOLE_SCORES" for a in available_actions):
                # Enter scores
                client.post(f"/wgp/{game_id}/action", json={
                    "action_type": "ENTER_HOLE_SCORES",
                    "payload": {"scores": {"p1": 4, "p2": 5, "p3": 4, "p4": 6}}
                })
                break
    
        # Get post-hole analysis
        response = client.post(f"/wgp/{game_id}/action", json={
            "action_type": "GET_POST_HOLE_ANALYSIS",
            "payload": {"hole_number": 1}
        })
>       assert response.status_code == 200
E       assert 500 == 200
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

tests/backend/test_full_game_flow.py:294: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:2210 Error getting post-hole analysis: '<' not supported between instances of 'NoneType' and 'NoneType'
ERROR    app.main:main.py:200 HTTP exception: 500 - Failed to get post-hole analysis: '<' not supported between instances of 'NoneType' and 'NoneType'
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
______________ TestErrorRecovery.test_invalid_partnership_request ______________

self = <test_full_game_flow.TestErrorRecovery object at 0x10e86ce10>
client = <starlette.testclient.TestClient object at 0x10ece1470>
initialized_game = {'available_actions': [{'action_type': 'PLAY_SHOT', 'player_turn': 'Alice', 'prompt': 'Start first hole'}], 'game_stat...: 20.0, 'id': 'p4', 'name': 'David', 'strength': 4}]}, 'id': 'init_1', 'timestamp': '2025-10-20T07:48:05.939276', ...}}

    def test_invalid_partnership_request(self, client, initialized_game):
        """Test requesting partnership with invalid player"""
        response = client.post("/wgp/test-game/action", json={
            "action_type": "REQUEST_PARTNERSHIP",
            "payload": {"target_player_name": "NonexistentPlayer"}
        })
>       assert response.status_code == 400
E       assert 500 == 400
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

tests/backend/test_full_game_flow.py:310: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:1702 Error requesting partnership: 400: Player 'NonexistentPlayer' not found
ERROR    app.main:main.py:200 HTTP exception: 500 - Failed to request partnership: 400: Player 'NonexistentPlayer' not found
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
________________ TestErrorRecovery.test_action_out_of_sequence _________________

self = <test_full_game_flow.TestErrorRecovery object at 0x10e86cf50>
client = <starlette.testclient.TestClient object at 0x10ecce970>
initialized_game = {'available_actions': [{'action_type': 'PLAY_SHOT', 'player_turn': 'Alice', 'prompt': 'Start first hole'}], 'game_stat...: 20.0, 'id': 'p4', 'name': 'David', 'strength': 4}]}, 'id': 'init_1', 'timestamp': '2025-10-20T07:48:05.948132', ...}}

    def test_action_out_of_sequence(self, client, initialized_game):
        """Test performing actions out of sequence"""
        # Try to enter scores without playing shots
        response = client.post("/wgp/test-game/action", json={
            "action_type": "ENTER_HOLE_SCORES",
            "payload": {"scores": {"p1": 4, "p2": 5, "p3": 4, "p4": 6}}
        })
        # Should either handle gracefully or return appropriate error
>       assert response.status_code in [200, 400]
E       assert 500 in [200, 400]
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

tests/backend/test_full_game_flow.py:321: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:2240 Error entering hole scores: Invalid team type for points calculation: pending
ERROR    app.main:main.py:200 HTTP exception: 500 - Failed to enter hole scores: Invalid team type for points calculation: pending
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
_____________________________ test_ghin_diagnostic _____________________________

    def test_ghin_diagnostic():
        """Test the GHIN diagnostic function directly"""
        print("🔍 GHIN Diagnostic Test")
        print("=" * 40)
    
        # Call the diagnostic function directly
        result = ghin_diagnostic()
    
        print("📊 Diagnostic Results:")
>       print(f"Status: {result['status']}")
                         ^^^^^^^^^^^^^^^^
E       KeyError: 'status'

tests/backend/test_ghin_local.py:18: KeyError
----------------------------- Captured stdout call -----------------------------
🔍 GHIN Diagnostic Test
========================================
📊 Diagnostic Results:
________ TestComputerPlayer.test_should_accept_partnership_when_behind _________

self = <test_simulation_components.TestComputerPlayer object at 0x10e86efd0>

    def test_should_accept_partnership_when_behind(self):
>       player = ComputerPlayer("comp1", "Alice", 8.0, "balanced")
                 ^^^^^^^^^^^^^^
E       NameError: name 'ComputerPlayer' is not defined

tests/backend/test_simulation_components.py:21: NameError
______________ TestComputerPlayer.test_should_go_solo_when_ahead _______________

self = <test_simulation_components.TestComputerPlayer object at 0x10e86ead0>

    def test_should_go_solo_when_ahead(self):
>       player = ComputerPlayer("comp1", "Alice", 8.0, "aggressive")
                 ^^^^^^^^^^^^^^
E       NameError: name 'ComputerPlayer' is not defined

tests/backend/test_simulation_components.py:34: NameError
_______________ TestShotSimulation.test_approach_shot_simulation _______________

self = <test_simulation_components.TestShotSimulation object at 0x10e86f390>

    def test_approach_shot_simulation(self):
>       from app.services.shot_simulator import ShotSimulator
E       ModuleNotFoundError: No module named 'app.services.shot_simulator'

tests/backend/test_simulation_components.py:94: ModuleNotFoundError
_______ TestPartnershipAdvantage.test_partnership_advantage_calculation ________

self = <test_simulation_components.TestPartnershipAdvantage object at 0x10e86f4d0>

    def test_partnership_advantage_calculation(self):
        engine = WolfGoatPigSimulation()
        game_state = Mock()
    
        # Mock the player_manager.players to be iterable
        mock_captain = Mock()
        mock_captain.id = "captain"
        mock_captain.handicap = 10.0
    
        mock_partner = Mock()
        mock_partner.id = "partner"
        mock_partner.handicap = 12.0
    
        mock_other1 = Mock()
        mock_other1.id = "other1"
        mock_other1.handicap = 15.0
    
        mock_other2 = Mock()
        mock_other2.id = "other2"
        mock_other2.handicap = 18.0
    
        game_state.player_manager.players = [mock_captain, mock_partner, mock_other1, mock_other2]
    
>       advantage = engine._calculate_partnership_advantage("captain", "partner", game_state)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'WolfGoatPigSimulation' object has no attribute '_calculate_partnership_advantage'. Did you mean: '_calculate_partners_points'?

tests/backend/test_simulation_components.py:133: AttributeError
_____________ TestSimulationFlow.test_simulation_with_mocked_shots _____________

args = (<test_simulation_components.TestSimulationFlow object at 0x10e86f610>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.13/3.13.3/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.13/3.13.3/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.13/3.13.3/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1405: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.13/3.13.3/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.13/3.13.3/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1481: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.services.shot_simulator.ShotSimulator'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'app.services' has no attribute 'shot_simulator'

/opt/homebrew/Cellar/python@3.13/3.13.3/Frameworks/Python.framework/Versions/3.13/lib/python3.13/pkgutil.py:528: AttributeError
______________________ TestWGPPlayer.test_player_creation ______________________

self = <test_simulation_components_fixed.TestWGPPlayer object at 0x10e86f9d0>

    def test_player_creation(self):
        player = WGPPlayer("p1", "Alice", 10.0)
        assert player.id == "p1"
        assert player.name == "Alice"
        assert player.handicap == 10.0
>       assert player.is_computer == False
               ^^^^^^^^^^^^^^^^^^
E       AttributeError: 'WGPPlayer' object has no attribute 'is_computer'

tests/backend/test_simulation_components_fixed.py:25: AttributeError
_________________ TestWGPPlayer.test_computer_player_creation __________________

self = <test_simulation_components_fixed.TestWGPPlayer object at 0x10e86fc50>

    def test_computer_player_creation(self):
>       player = WGPPlayer("p2", "Bob", 15.0, is_computer=True, personality="aggressive")
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: WGPPlayer.__init__() got an unexpected keyword argument 'is_computer'

tests/backend/test_simulation_components_fixed.py:29: TypeError
__________________ TestBettingState.test_partnership_request ___________________

self = <test_simulation_components_fixed.TestBettingState object at 0x10e86f750>

    def test_partnership_request(self):
        betting_state = BettingState()
        betting_state.teams = {
            "type": "pending",
            "captain": "captain",
            "pending_request": None
        }
    
        result = betting_state.request_partner("captain", "partner")
>       assert result == True
E       AssertionError: assert 'Partner requested.' == True

tests/backend/test_simulation_components_fixed.py:46: AssertionError
_________________ TestBettingState.test_partnership_acceptance _________________

self = <test_simulation_components_fixed.TestBettingState object at 0x10e86fd90>

    def test_partnership_acceptance(self):
        betting_state = BettingState()
        betting_state.teams = {
            "type": "pending",
            "captain": "captain",
            "pending_request": {"captain": "captain", "requested": "partner"}
        }
    
        # Accept partnership
>       betting_state.accept_partner("partner", ["captain", "partner", "other1", "other2"])

tests/backend/test_simulation_components_fixed.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = BettingState(teams={'type': 'pending', 'captain': 'captain', 'pending_request': {'captain': 'captain', 'requested': 'partner'}}, base_wager=1, doubled_status=False, game_phase='Regular')
partner_id = 'partner', players = ['captain', 'partner', 'other1', 'other2']

    def accept_partner(self, partner_id: str, players: List[Player]) -> str:
        if self.teams.get("type") != "pending" or self.teams.get("requested") != partner_id:
>           raise ValueError("No pending partner request for this player.")
E           ValueError: No pending partner request for this player.

backend/app/state/betting_state.py:32: ValueError
_____________ TestBettingState.test_partnership_decline_goes_solo ______________

self = <test_simulation_components_fixed.TestBettingState object at 0x10e8f02b0>

    def test_partnership_decline_goes_solo(self):
        betting_state = BettingState()
        betting_state.teams = {
            "type": "pending",
            "captain": "captain",
            "pending_request": {"captain": "captain", "requested": "partner"}
        }
    
        # Decline partnership
>       betting_state.decline_partner("partner", ["captain", "partner", "other1", "other2"])

tests/backend/test_simulation_components_fixed.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = BettingState(teams={'type': 'pending', 'captain': 'captain', 'pending_request': {'captain': 'captain', 'requested': 'partner'}}, base_wager=1, doubled_status=False, game_phase='Regular')
partner_id = 'partner', players = ['captain', 'partner', 'other1', 'other2']

    def decline_partner(self, partner_id: str, players: List[Player]) -> str:
        if self.teams.get("type") != "pending" or self.teams.get("requested") != partner_id:
>           raise ValueError("No pending partner request for this player.")
E           ValueError: No pending partner request for this player.

backend/app/state/betting_state.py:40: ValueError
___________ TestWolfGoatPigSimulation.test_simulation_initialization ___________

self = <test_simulation_components_fixed.TestWolfGoatPigSimulation object at 0x10e86fed0>

    def test_simulation_initialization(self):
        sim = WolfGoatPigSimulation(player_count=4)
        assert sim.player_count == 4
        assert len(sim.players) == 4
        assert sim.current_hole == 1
>       assert sim.total_holes == 18
               ^^^^^^^^^^^^^^^
E       AttributeError: 'WolfGoatPigSimulation' object has no attribute 'total_holes'

tests/backend/test_simulation_components_fixed.py:90: AttributeError
_____________ TestWolfGoatPigSimulation.test_set_computer_players ______________

self = <test_simulation_components_fixed.TestWolfGoatPigSimulation object at 0x10e8f03e0>

    def test_set_computer_players(self):
        sim = WolfGoatPigSimulation(player_count=4)
        sim.set_computer_players(["p2", "p3", "p4"])
    
>       assert sim.players[0].is_computer == False
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'WGPPlayer' object has no attribute 'is_computer'

tests/backend/test_simulation_components_fixed.py:107: AttributeError
______________ TestWolfGoatPigSimulation.test_request_partnership ______________

self = <test_simulation_components_fixed.TestWolfGoatPigSimulation object at 0x10e8f0510>

    def test_request_partnership(self):
        sim = WolfGoatPigSimulation(player_count=4)
        sim.hole_states[1].teams.captain = "p1"
    
        result = sim.request_partner("p1", "p2")
>       assert "Partnership requested" in result["message"]
E       AssertionError: assert 'Partnership requested' in 'Partnership request sent to Scott'

tests/backend/test_simulation_components_fixed.py:117: AssertionError
_________________ TestWolfGoatPigSimulation.test_offer_double __________________

self = <test_simulation_components_fixed.TestWolfGoatPigSimulation object at 0x10e7cf350>

    def test_offer_double(self):
        sim = WolfGoatPigSimulation(player_count=4)
        sim.hole_states[1].teams.type = "partners"
        sim.hole_states[1].teams.team1 = ["p1", "p2"]
        sim.hole_states[1].teams.team2 = ["p3", "p4"]
    
        result = sim.offer_double("p1")
>       assert "offers to double" in result["message"]
E       AssertionError: assert 'offers to double' in 'Bob offers a double'

tests/backend/test_simulation_components_fixed.py:135: AssertionError
_________________ TestWolfGoatPigSimulation.test_advance_hole __________________

self = <test_simulation_components_fixed.TestWolfGoatPigSimulation object at 0x10e7cf460>

    def test_advance_hole(self):
        sim = WolfGoatPigSimulation(player_count=4)
        initial_hole = sim.current_hole
    
        result = sim.advance_to_next_hole()
        assert sim.current_hole == initial_hole + 1
>       assert "Advanced to hole" in result["message"]
                                     ^^^^^^^^^^^^^^^^^
E       KeyError: 'message'

tests/backend/test_simulation_components_fixed.py:144: KeyError
________________ TestWolfGoatPigSimulation.test_get_game_state _________________

self = <test_simulation_components_fixed.TestWolfGoatPigSimulation object at 0x10e8a9250>

    def test_get_game_state(self):
        sim = WolfGoatPigSimulation(player_count=4)
        state = sim.get_game_state()
    
        assert "players" in state
        assert "current_hole" in state
>       assert "total_holes" in state
E       AssertionError: assert 'total_holes' in {'current_hole': 1, 'game_phase': 'regular', 'hoepfinger_start': 17, 'hole_description': '', ...}

tests/backend/test_simulation_components_fixed.py:152: AssertionError
_______________ TestWolfGoatPigSimulation.test_enter_hole_scores _______________

self = <test_simulation_components_fixed.TestWolfGoatPigSimulation object at 0x10e7ebb60>

    def test_enter_hole_scores(self):
        sim = WolfGoatPigSimulation(player_count=4)
        sim.hole_states[1].teams.type = "partners"
        sim.hole_states[1].teams.team1 = ["p1", "p2"]
        sim.hole_states[1].teams.team2 = ["p3", "p4"]
    
        scores = {"p1": 4, "p2": 5, "p3": 4, "p4": 6}
        result = sim.enter_hole_scores(scores)
    
>       assert "Teams tied" in result["message"] or "wins" in result["message"]
E       AssertionError: assert ('Teams tied' in 'Hole halved. No points awarded.' or 'wins' in 'Hole halved. No points awarded.')

tests/backend/test_simulation_components_fixed.py:178: AssertionError
___________ TestHoleProgression.test_shot_progression_initialization ___________

self = <test_simulation_components_fixed.TestHoleProgression object at 0x10e904190>

    def test_shot_progression_initialization(self):
        sim = WolfGoatPigSimulation(player_count=4)
        sim.enable_shot_progression()
    
        assert hasattr(sim, 'hole_progression')
        assert sim.hole_progression is not None
>       assert len(sim.hole_progression.timeline) > 0
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'WGPHoleProgression' object has no attribute 'timeline'

tests/backend/test_simulation_components_fixed.py:191: AttributeError
___________________ TestHoleProgression.test_timeline_events ___________________

self = <test_simulation_components_fixed.TestHoleProgression object at 0x10e8f0640>

    def test_timeline_events(self):
        sim = WolfGoatPigSimulation(player_count=4)
        sim.enable_shot_progression()
    
>       initial_timeline_length = len(sim.hole_progression.timeline)
                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'WGPHoleProgression' object has no attribute 'timeline'

tests/backend/test_simulation_components_fixed.py:205: AttributeError
__________________ TestAnalytics.test_get_advanced_analytics ___________________

self = <test_simulation_components_fixed.TestAnalytics object at 0x10e904410>

    def test_get_advanced_analytics(self):
        sim = WolfGoatPigSimulation(player_count=4)
        analytics = sim.get_advanced_analytics()
    
>       assert "player_performance" in analytics
E       AssertionError: assert 'player_performance' in {'betting_analysis': {'average_wager': 0.0, 'max_wager': 0, 'risk_reward_analysis': {}, 'special_rules_frequency': {},..._points': 0, ...}, 'p4': {'average_per_hole': 0.0, 'best_hole': 0, 'consistency': 0.5, 'current_points': 0, ...}}, ...}

tests/backend/test_simulation_components_fixed.py:221: AssertionError
____________________ TestAnalytics.test_post_hole_analysis _____________________

self = <test_simulation_components_fixed.TestAnalytics object at 0x10e904550>

    def test_post_hole_analysis(self):
        sim = WolfGoatPigSimulation(player_count=4)
        sim.hole_states[1].teams.type = "partners"
        sim.hole_states[1].teams.team1 = ["p1", "p2"]
        sim.hole_states[1].teams.team2 = ["p3", "p4"]
        sim.hole_states[1].hole_complete = True
    
>       analysis = sim.get_post_hole_analysis(1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_simulation_components_fixed.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/app/wolf_goat_pig_simulation.py:1195: in get_post_hole_analysis
    "scoring_analysis": self._analyze_scoring(hole_state),
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.wolf_goat_pig_simulation.WolfGoatPigSimulation object at 0x10f40d790>
hole_state = HoleState(hole_number=1, hitting_order=['p1', 'p4', 'p3', 'p2'], teams=TeamFormation(type='partners', captain='p1', se...ots_complete=0, partnership_deadline_passed=False, invitation_windows={'p1': True, 'p2': True, 'p3': True, 'p4': True})

    def _analyze_scoring(self, hole_state: HoleState) -> Dict[str, Any]:
        """Analyze scoring performance and outcomes"""
        if not hole_state.scores:
            return {"scores_entered": False}
    
        scores = hole_state.scores
    
        # Calculate net scores with handicaps
        net_scores = {}
        for player_id, gross_score in scores.items():
            stroke_advantage = hole_state.stroke_advantages.get(player_id, 0)
            if isinstance(stroke_advantage, (int, float)):
                net_scores[player_id] = gross_score - stroke_advantage
            else:
                net_scores[player_id] = gross_score
    
        # Find best performances
>       best_gross = min(scores.values())
                     ^^^^^^^^^^^^^^^^^^^^
E       TypeError: '<' not supported between instances of 'NoneType' and 'NoneType'

backend/app/wolf_goat_pig_simulation.py:1282: TypeError
_______________ test_seed_state_endpoint_updates_ball_positions ________________

    def test_seed_state_endpoint_updates_ball_positions():
        seed_payload = {
            "ball_positions": [
                {
                    "player_id": "captain",
                    "distance_to_pin": 125.5,
                    "lie_type": "fairway",
                    "shot_count": 2,
                },
                {
                    "player_id": "player_two",
                    "distance_to_pin": 140.0,
                    "lie_type": "fairway",
                    "shot_count": 2,
                },
            ],
            "ball_positions_replace": True,
            "line_of_scrimmage": "player_two",
            "current_order_of_play": ["player_two", "captain", "player_three", "player_four"],
            "next_player_to_hit": "player_two",
            "wagering_closed": False,
            "betting": {"current_wager": 2, "doubled": True},
        }
    
        resp = client.post("/simulation/test/seed-state", json=seed_payload)
>       assert resp.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:127: AssertionError
___________________ test_seed_state_team_formation_partners ____________________

    def test_seed_state_team_formation_partners():
>       _seed_state(
            {
                "ball_positions": _default_ball_positions(),
                "team_formation": {
                    "type": "partners",
                    "captain": "captain",
                    "team1": ["captain", "player_two"],
                    "team2": ["player_three", "player_four"],
                },
            }
        )

tests/backend/test_simulation_state_endpoint.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist...captain': 'captain', 'team1': ['captain', 'player_two'], 'team2': ['player_three', 'player_four'], 'type': 'partners'}}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
_____________________ test_seed_state_team_formation_solo ______________________

    def test_seed_state_team_formation_solo():
>       _seed_state(
            {
                "ball_positions": _default_ball_positions(),
                "team_formation": {
                    "type": "solo",
                    "captain": "player_two",
                    "solo_player": "player_two",
                    "opponents": ["captain", "player_three", "player_four"],
                },
            }
        )

tests/backend/test_simulation_state_endpoint.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist...': 'player_two', 'opponents': ['captain', 'player_three', 'player_four'], 'solo_player': 'player_two', 'type': 'solo'}}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
________________ test_seed_state_team_formation_pending_request ________________

    def test_seed_state_team_formation_pending_request():
>       _seed_state(
            {
                "ball_positions": _default_ball_positions(),
                "team_formation": {
                    "type": "pending",
                    "captain": "captain",
                    "pending_request": {
                        "captain": "captain",
                        "requested": "player_three",
                        "status": "pending",
                    },
                },
            }
        )

tests/backend/test_simulation_state_endpoint.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist...tain', 'pending_request': {'captain': 'captain', 'requested': 'player_three', 'status': 'pending'}, 'type': 'pending'}}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
________________ test_seed_state_line_of_scrimmage_and_ordering ________________

    def test_seed_state_line_of_scrimmage_and_ordering():
        seed_payload = {
            "ball_positions": _default_ball_positions(),
            "current_order_of_play": [
                "player_two",
                "captain",
                "player_three",
                "player_four",
            ],
            "line_of_scrimmage": "player_two",
            "shot_order": ["player_two", "player_four", "captain", "player_three"],
            "next_player_to_hit": "player_two",
        }
    
>       _seed_state(seed_payload)

tests/backend/test_simulation_state_endpoint.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist... 'captain', 'player_three', 'player_four'], 'line_of_scrimmage': 'player_two', 'next_player_to_hit': 'player_two', ...}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
___________________ test_seed_state_extended_betting_fields ____________________

    def test_seed_state_extended_betting_fields():
        seed_payload = {
            "ball_positions": _default_ball_positions(),
            "wagering_closed": True,
            "betting": {
                "base_wager": 3,
                "current_wager": 6,
                "doubled": True,
                "ping_pong_count": 2,
                "float_invoked": True,
                "carry_over": True,
            },
        }
    
>       _seed_state(seed_payload)

tests/backend/test_simulation_state_endpoint.py:251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist...], 'betting': {'base_wager': 3, 'carry_over': True, 'current_wager': 6, 'doubled': True, ...}, 'wagering_closed': True}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
____________________ test_seed_state_ball_positions_replace ____________________

    def test_seed_state_ball_positions_replace():
        # Seed with four positions
>       _seed_state({"ball_positions": _default_ball_positions()})

tests/backend/test_simulation_state_endpoint.py:267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist...ee', 'shot_count': 1}, {'distance_to_pin': 170.0, 'lie_type': 'fairway', 'player_id': 'player_four', 'shot_count': 1}]}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
_____________________ test_seed_state_wagering_closed_flag _____________________

    def test_seed_state_wagering_closed_flag():
>       _seed_state(
            {
                "ball_positions": _default_ball_positions(),
                "wagering_closed": True,
            }
        )

tests/backend/test_simulation_state_endpoint.py:300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist...distance_to_pin': 170.0, 'lie_type': 'fairway', 'player_id': 'player_four', 'shot_count': 1}], 'wagering_closed': True}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
____________________ test_seed_state_with_unknown_player_id ____________________

    def test_seed_state_with_unknown_player_id():
        """Test that seeding with unknown player IDs fails with 422 error."""
        seed_payload = {
            "ball_positions": [
                {
                    "player_id": "unknown_player",
                    "distance_to_pin": 150.0,
                    "lie_type": "fairway",
                    "shot_count": 1,
                }
            ]
        }
    
        response = client.post("/simulation/test/seed-state", json=seed_payload)
>       assert response.status_code == 422
E       assert 404 == 422
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:329: AssertionError
_________________________ test_seed_state_before_setup _________________________

    def test_seed_state_before_setup():
        """Test that seeding before simulation setup fails appropriately."""
        # This test needs to run without the autouse fixture
        # Since we can't disable it, we'll test the global state instead
        import app.main as main_module
    
        # Save current simulation state
        original_sim = main_module.wgp_simulation
    
        try:
            # Clear the global simulation
            main_module.wgp_simulation = None
    
            seed_payload = {
                "ball_positions": _default_ball_positions(),
            }
    
            response = client.post("/simulation/test/seed-state", json=seed_payload)
>           assert response.status_code == 400
E           assert 404 == 400
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:351: AssertionError
____________________ test_seed_state_conflicting_shot_order ____________________

    def test_seed_state_conflicting_shot_order():
        """Test that shot order must contain only valid player IDs."""
        seed_payload = {
            "shot_order": ["captain", "player_two", "nonexistent_player", "player_four"],
        }
    
        response = client.post("/simulation/test/seed-state", json=seed_payload)
>       assert response.status_code == 422
E       assert 404 == 422
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:365: AssertionError
__________________ test_seed_state_invalid_line_of_scrimmage ___________________

    def test_seed_state_invalid_line_of_scrimmage():
        """Test that line of scrimmage must be a valid player ID."""
        seed_payload = {
            "line_of_scrimmage": "invalid_player",
        }
    
        response = client.post("/simulation/test/seed-state", json=seed_payload)
>       assert response.status_code == 422
E       assert 404 == 422
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:376: AssertionError
_____________________ test_seed_state_invalid_next_player ______________________

    def test_seed_state_invalid_next_player():
        """Test that next player to hit must be a valid player ID."""
        seed_payload = {
            "next_player_to_hit": "ghost_player",
        }
    
        response = client.post("/simulation/test/seed-state", json=seed_payload)
>       assert response.status_code == 422
E       assert 404 == 422
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:387: AssertionError
________________ test_seed_state_invalid_current_order_of_play _________________

    def test_seed_state_invalid_current_order_of_play():
        """Test that current order of play must contain only valid player IDs."""
        seed_payload = {
            "current_order_of_play": ["captain", "fake_player", "player_three"],
        }
    
        response = client.post("/simulation/test/seed-state", json=seed_payload)
>       assert response.status_code == 422
E       assert 404 == 422
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:398: AssertionError
______________ test_seed_state_betting_line_of_scrimmage_invalid _______________

    def test_seed_state_betting_line_of_scrimmage_invalid():
        """Test that betting line of scrimmage must be a valid player ID."""
        seed_payload = {
            "betting": {
                "line_of_scrimmage": "invalid_player",
            }
        }
    
        response = client.post("/simulation/test/seed-state", json=seed_payload)
>       assert response.status_code == 422
E       assert 404 == 422
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:411: AssertionError
_________________ test_seed_state_double_when_wagering_closed __________________

    def test_seed_state_double_when_wagering_closed():
        """Test behavior when attempting to double after wagering is closed."""
        # First, seed with wagering closed
>       _seed_state(
            {
                "ball_positions": _default_ball_positions(),
                "wagering_closed": True,
                "betting": {
                    "current_wager": 1,
                    "doubled": False,
                },
            }
        )

tests/backend/test_simulation_state_endpoint.py:418: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist...ayer_id': 'player_four', 'shot_count': 1}], 'betting': {'current_wager': 1, 'doubled': False}, 'wagering_closed': True}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
_____________________ test_seed_state_solo_captain_double ______________________

    def test_seed_state_solo_captain_double():
        """Test that a solo captain can double even when wagering is closed."""
>       _seed_state(
            {
                "ball_positions": _default_ball_positions(),
                "team_formation": {
                    "type": "solo",
                    "captain": "captain",
                    "solo_player": "captain",
                    "opponents": ["player_two", "player_three", "player_four"],
                },
                "wagering_closed": True,
                "betting": {
                    "current_wager": 2,
                    "doubled": True,
                },
            }
        )

tests/backend/test_simulation_state_endpoint.py:453: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist...ts': ['player_two', 'player_three', 'player_four'], 'solo_player': 'captain', 'type': 'solo'}, 'wagering_closed': True}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
_____________________ test_seed_state_ping_pong_increment ______________________

    def test_seed_state_ping_pong_increment():
        """Test ping-pong counter increments."""
        # Seed initial state with ping pong count
>       _seed_state(
            {
                "ball_positions": _default_ball_positions(),
                "betting": {
                    "ping_pong_count": 0,
                    "current_wager": 1,
                },
            }
        )

tests/backend/test_simulation_state_endpoint.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist...type': 'fairway', 'player_id': 'player_four', 'shot_count': 1}], 'betting': {'current_wager': 1, 'ping_pong_count': 0}}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
________________ test_seed_state_pending_partnership_acceptance ________________

    def test_seed_state_pending_partnership_acceptance():
        """Test pending partnership request state transitions."""
        # Set up pending partnership request
>       _seed_state(
            {
                "ball_positions": _default_ball_positions(),
                "team_formation": {
                    "type": "pending",
                    "captain": "captain",
                    "pending_request": {
                        "captain": "captain",
                        "requested": "player_three",
                        "status": "pending",
                    },
                },
            }
        )

tests/backend/test_simulation_state_endpoint.py:538: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist...tain', 'pending_request': {'captain': 'captain', 'requested': 'player_three', 'status': 'pending'}, 'type': 'pending'}}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
_________________ test_seed_state_pending_partnership_decline __________________

    def test_seed_state_pending_partnership_decline():
        """Test declining a pending partnership request."""
        # Set up pending partnership request
>       _seed_state(
            {
                "ball_positions": _default_ball_positions(),
                "team_formation": {
                    "type": "pending",
                    "captain": "player_two",
                    "pending_request": {
                        "captain": "player_two",
                        "requested": "player_four",
                        "status": "pending",
                    },
                },
            }
        )

tests/backend/test_simulation_state_endpoint.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist...wo', 'pending_request': {'captain': 'player_two', 'requested': 'player_four', 'status': 'pending'}, 'type': 'pending'}}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
__________________ test_seed_state_multiple_validation_errors __________________

    def test_seed_state_multiple_validation_errors():
        """Test that multiple validation errors are caught."""
        seed_payload = {
            "ball_positions": [
                {
                    "player_id": "invalid1",
                    "distance_to_pin": 100.0,
                    "lie_type": "fairway",
                    "shot_count": 1,
                },
                {
                    "player_id": "invalid2",
                    "distance_to_pin": 120.0,
                    "lie_type": "rough",
                    "shot_count": 1,
                },
            ],
            "line_of_scrimmage": "invalid3",
            "next_player_to_hit": "invalid4",
        }
    
        response = client.post("/simulation/test/seed-state", json=seed_payload)
>       assert response.status_code == 422
E       assert 404 == 422
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:639: AssertionError
____________________ test_seed_state_reset_doubles_history _____________________

    def test_seed_state_reset_doubles_history():
        """Test that doubles history can be reset."""
        # First seed with some betting state
>       _seed_state(
            {
                "ball_positions": _default_ball_positions(),
                "betting": {
                    "current_wager": 2,
                    "doubled": True,
                },
                "reset_doubles_history": False,
            }
        )

tests/backend/test_simulation_state_endpoint.py:647: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

payload = {'ball_positions': [{'distance_to_pin': 150.0, 'lie_type': 'fairway', 'player_id': 'captain', 'shot_count': 1}, {'dist...d': 'player_four', 'shot_count': 1}], 'betting': {'current_wager': 2, 'doubled': True}, 'reset_doubles_history': False}

    def _seed_state(payload: dict) -> dict:
        """Helper to post to the seed endpoint and return the resulting game state."""
    
        response = client.post("/simulation/test/seed-state", json=payload)
>       assert response.status_code == 200, response.text
E       AssertionError: {"detail":"Not Found"}
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/backend/test_simulation_state_endpoint.py:47: AssertionError
__________________ TestUnifiedActionAPI.test_initialize_game ___________________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e905810>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e905810>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
_____________ TestUnifiedActionAPI.test_complete_hole_1_simulation _____________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e904e10>

    def test_complete_hole_1_simulation(self):
        """Test a complete simulation of hole 1 with all actions"""
        # Step 1: Initialize game
>       game_state = self.test_initialize_game()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_unified_action_api.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e904e10>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e904e10>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
_____________ TestUnifiedActionAPI.test_complete_hole_2_simulation _____________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8f09d0>

    def test_complete_hole_2_simulation(self):
        """Test a complete simulation of hole 2 with different scenarios"""
        # Start with hole 1 completed
>       game_state = self.test_complete_hole_1_simulation()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_unified_action_api.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/backend/test_unified_action_api.py:70: in test_complete_hole_1_simulation
    game_state = self.test_initialize_game()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8f09d0>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8f09d0>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
_____________ TestUnifiedActionAPI.test_two_full_holes_simulation ______________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8f0c30>

    def test_two_full_holes_simulation(self):
        """Test complete simulation of two full holes"""
        print("\n=== Starting Two Full Holes Simulation ===")
    
        # Hole 1: Partnership scenario
        print("\n--- Hole 1: Partnership Scenario ---")
>       game_state_1 = self.test_complete_hole_1_simulation()
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_unified_action_api.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/backend/test_unified_action_api.py:70: in test_complete_hole_1_simulation
    game_state = self.test_initialize_game()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8f0c30>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8f0c30>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
----------------------------- Captured stdout call -----------------------------

=== Starting Two Full Holes Simulation ===

--- Hole 1: Partnership Scenario ---
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
______________ TestUnifiedActionAPI.test_timeline_event_structure ______________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e938830>

    def test_timeline_event_structure(self):
        """Test that timeline events have the correct structure"""
        # Initialize game
>       game_state = self.test_initialize_game()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_unified_action_api.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e938830>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e938830>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
___________ TestUnifiedActionAPI.test_available_actions_consistency ____________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e7cff00>

    def test_available_actions_consistency(self):
        """Test that available actions are consistent and logical"""
        # Initialize game
>       game_state = self.test_initialize_game()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_unified_action_api.py:378: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e7cff00>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e7cff00>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
___________________ TestUnifiedActionAPI.test_error_handling ___________________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e940050>

    def test_error_handling(self):
        """Test error handling for invalid actions"""
        # Test invalid action type
        action_data = {
            "action_type": "INVALID_ACTION",
            "payload": None
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
        assert response.status_code == 400
        assert "Unknown action type" in response.json()["detail"]
    
        # Test missing required payload
        action_data = {
            "action_type": "REQUEST_PARTNERSHIP",
            "payload": None  # Missing target_player_name
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
>       assert response.status_code == 400
E       assert 500 == 400
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

tests/backend/test_unified_action_api.py:427: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:200 HTTP exception: 400 - Unknown action type: INVALID_ACTION
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
ERROR    app.main:main.py:1702 Error requesting partnership: 400: target_player_name is required
ERROR    app.main:main.py:200 HTTP exception: 500 - Failed to request partnership: 400: target_player_name is required
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
_______________ TestUnifiedActionAPI.test_game_state_consistency _______________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8a9950>

    def test_game_state_consistency(self):
        """Test that game state remains consistent throughout the simulation"""
        # Initialize game
>       initial_state = self.test_initialize_game()
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_unified_action_api.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8a9950>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8a9950>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
__________________ TestUnifiedActionAPI.test_captain_rotation __________________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8a9a50>

    def test_captain_rotation(self):
        """Test that captain rotation works correctly across holes"""
        print("\n=== Testing Captain Rotation ===")
    
        # Initialize game
>       game_state = self.test_initialize_game()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_unified_action_api.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8a9a50>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8a9a50>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
----------------------------- Captured stdout call -----------------------------

=== Testing Captain Rotation ===
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
_______________ TestUnifiedActionAPI.test_partnership_scenarios ________________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8acc80>

    def test_partnership_scenarios(self):
        """Test various partnership scenarios"""
        print("\n=== Testing Partnership Scenarios ===")
    
        # Initialize game
>       game_state = self.test_initialize_game()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_unified_action_api.py:532: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8acc80>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8acc80>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
----------------------------- Captured stdout call -----------------------------

=== Testing Partnership Scenarios ===
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
___________________ TestUnifiedActionAPI.test_solo_scenarios ___________________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8acd70>

    def test_solo_scenarios(self):
        """Test solo play scenarios"""
        print("\n=== Testing Solo Scenarios ===")
    
        # Initialize game
>       game_state = self.test_initialize_game()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_unified_action_api.py:653: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8acd70>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e8acd70>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
----------------------------- Captured stdout call -----------------------------

=== Testing Solo Scenarios ===
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
_________________ TestUnifiedActionAPI.test_betting_scenarios __________________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e916f90>

    def test_betting_scenarios(self):
        """Test betting scenarios (doubles)"""
        print("\n=== Testing Betting Scenarios ===")
    
        # Initialize game
>       game_state = self.test_initialize_game()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_unified_action_api.py:692: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e916f90>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e916f90>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
----------------------------- Captured stdout call -----------------------------

=== Testing Betting Scenarios ===
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
_____________________ TestUnifiedActionAPI.test_edge_cases _____________________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e917230>

    def test_edge_cases(self):
        """Test edge cases and error conditions"""
        print("\n=== Testing Edge Cases ===")
    
        # Test 1: Invalid game ID
        print("\n--- Test 1: Invalid Game ID ---")
        action_data = {
            "action_type": "PLAY_SHOT",
            "payload": None
        }
        response = client.post("/wgp/invalid-game-id/action", json=action_data)
        # Should still work since we're using a global simulation
    
        # Test 2: Missing payload for actions that need it
        print("\n--- Test 2: Missing Required Payload ---")
    
        # Initialize game first
>       game_state = self.test_initialize_game()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_unified_action_api.py:771: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e917230>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e917230>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
----------------------------- Captured stdout call -----------------------------

=== Testing Edge Cases ===

--- Test 1: Invalid Game ID ---

--- Test 2: Missing Required Payload ---
------------------------------ Captured log call -------------------------------
ERROR    app.main:main.py:1627 Error playing shot: Shot progression mode not enabled
ERROR    app.main:main.py:200 HTTP exception: 500 - Failed to play shot: Shot progression mode not enabled
ERROR    app.main:main.py:202 Request Host header: testserver
ERROR    app.main:main.py:203 Request Client host: testclient
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
_________________ TestUnifiedActionAPI.test_complete_game_flow _________________

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e9341f0>

    def test_complete_game_flow(self):
        """Test a complete game flow with multiple holes and scenarios"""
        print("\n=== Testing Complete Game Flow ===")
    
        # Initialize game
>       game_state = self.test_initialize_game()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/backend/test_unified_action_api.py:815: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e9341f0>

    def test_initialize_game(self):
        """Test game initialization"""
        action_data = {
            "action_type": "INITIALIZE_GAME",
            "payload": {
                "players": self.players,
                "course_name": self.course_name
            }
        }
    
        response = client.post(f"/wgp/{self.game_id}/action", json=action_data)
    
        assert response.status_code == 200
        data = response.json()
    
        # Check response structure
        assert "game_state" in data
        assert "log_message" in data
        assert "available_actions" in data
        assert "timeline_event" in data
    
        # Check timeline event
        timeline_event = data["timeline_event"]
        assert timeline_event["type"] == "game_start"
        assert "Game started with 4 players" in timeline_event["description"]
>       assert timeline_event["details"]["course"] == self.course_name
E       AssertionError: assert 'Wing Point Golf & Country Club' == None
E        +  where None = <test_unified_action_api.TestUnifiedActionAPI object at 0x10e9341f0>.course_name

tests/backend/test_unified_action_api.py:58: AssertionError
----------------------------- Captured stdout call -----------------------------

=== Testing Complete Game Flow ===
------------------------------ Captured log call -------------------------------
WARNING  app.main:main.py:1211 Requested course 'None' not available, using fallback
=============================== warnings summary ===============================
backend/app/database.py:34
  /Users/stuartgano/Documents/wolf-goat-pig/backend/app/database.py:34: MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    Base = declarative_base()

../../../../opt/homebrew/lib/python3.13/site-packages/pydantic/_internal/_config.py:323: 11 warnings
  /opt/homebrew/lib/python3.13/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

backend/app/game_state.py:293
tests/backend/test_basic_functionality.py::TestGameState::test_create_game_state
tests/backend/test_basic_functionality.py::TestGameState::test_setup_players
  /Users/stuartgano/Documents/wolf-goat-pig/backend/app/game_state.py:293: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    obj = session.query(GameStateModel).get(1)

backend/app/main.py:218
  /Users/stuartgano/Documents/wolf-goat-pig/backend/app/main.py:218: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../../opt/homebrew/lib/python3.13/site-packages/fastapi/applications.py:4495
../../../../opt/homebrew/lib/python3.13/site-packages/fastapi/applications.py:4495
  /opt/homebrew/lib/python3.13/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

backend/app/main.py:334
  /Users/stuartgano/Documents/wolf-goat-pig/backend/app/main.py:334: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("shutdown")

backend/app/main.py:2857
  /Users/stuartgano/Documents/wolf-goat-pig/backend/app/main.py:2857: DeprecationWarning: `regex` has been deprecated, please use `pattern` instead
    sort: str = Query("desc", regex="^(asc|desc)$")  # Add sort parameter

tests/backend/test_aardvark.py::test_5_man_aardvark
  /opt/homebrew/lib/python3.13/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/backend/test_aardvark.py::test_5_man_aardvark returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/backend/test_aardvark.py::test_aardvark_solo
  /opt/homebrew/lib/python3.13/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/backend/test_aardvark.py::test_aardvark_solo returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/backend/test_aardvark.py::test_6_man_game
  /opt/homebrew/lib/python3.13/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/backend/test_aardvark.py::test_6_man_game returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/backend/test_analytics.py::test_analytics
  /opt/homebrew/lib/python3.13/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/backend/test_analytics.py::test_analytics returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/backend/test_api.py::test_health_endpoint
  /opt/homebrew/lib/python3.13/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/backend/test_api.py::test_health_endpoint returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/backend/test_api.py::test_ghin_diagnostic
  /opt/homebrew/lib/python3.13/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/backend/test_api.py::test_ghin_diagnostic returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/backend/test_api.py::test_app_structure
  /opt/homebrew/lib/python3.13/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/backend/test_api.py::test_app_structure returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/backend/test_api_endpoints.py::TestCourseManagement::test_add_course
tests/backend/test_api_endpoints.py::TestCourseManagement::test_update_course
tests/backend/test_api_endpoints.py::TestCourseManagement::test_delete_course
tests/backend/test_api_simple.py::TestCourseEndpoints::test_add_new_course
tests/backend/test_api_working.py::TestCourseManagement::test_add_and_delete_course
  /Users/stuartgano/Documents/wolf-goat-pig/backend/app/main.py:760: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    result = game_state.add_course(course.dict())

tests/backend/test_api_endpoints.py::TestCourseManagement::test_update_course
  /Users/stuartgano/Documents/wolf-goat-pig/backend/app/main.py:770: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    result = game_state.update_course(course_name, course_update.dict())

tests/backend/test_api_endpoints.py: 10 warnings
tests/backend/test_api_simple.py: 4 warnings
tests/backend/test_api_working.py: 8 warnings
tests/backend/test_basic_functionality.py: 2 warnings
tests/backend/test_full_game_flow.py: 18 warnings
tests/backend/test_unified_action_api.py: 26 warnings
  /Users/stuartgano/Documents/wolf-goat-pig/backend/app/game_state.py:277: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    obj = session.query(GameStateModel).get(1)

tests/backend/test_debug_api.py::test_debug_health
  /Users/stuartgano/Documents/wolf-goat-pig/backend/app/main.py:6946: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    <p class="meta">Last checked: {datetime.utcnow().isoformat()}Z</p>

tests/backend/test_final_implementation.py::test_shot_by_shot_progression
  /opt/homebrew/lib/python3.13/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/backend/test_final_implementation.py::test_shot_by_shot_progression returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/backend/test_advanced_rules.py::TestAdvancedWGPRules::test_6_man_goat_restriction
FAILED tests/backend/test_api_endpoints.py::TestHealthEndpoints::test_health_check
FAILED tests/backend/test_api_endpoints.py::TestCourseManagement::test_get_courses
FAILED tests/backend/test_api_endpoints.py::TestCourseManagement::test_add_course
FAILED tests/backend/test_api_endpoints.py::TestCourseManagement::test_update_course
FAILED tests/backend/test_api_endpoints.py::TestGameEndpoints::test_get_rules
FAILED tests/backend/test_api_endpoints.py::TestGameEndpoints::test_get_game_state
FAILED tests/backend/test_api_endpoints.py::TestUnifiedActionAPI::test_request_partnership_action
FAILED tests/backend/test_api_endpoints.py::TestErrorHandling::test_missing_required_fields
FAILED tests/backend/test_api_simple.py::TestBasicEndpoints::test_health_endpoint
FAILED tests/backend/test_api_simple.py::TestBasicEndpoints::test_get_courses
FAILED tests/backend/test_api_simple.py::TestCourseEndpoints::test_add_new_course
FAILED tests/backend/test_api_working.py::TestWorkingEndpoints::test_health_endpoint
FAILED tests/backend/test_api_working.py::TestUnifiedActionAPI::test_invalid_player_count
FAILED tests/backend/test_full_game_flow.py::TestMultiHoleGame::test_play_three_holes
FAILED tests/backend/test_full_game_flow.py::TestSpecialScenarios::test_hole_18_big_dick
FAILED tests/backend/test_full_game_flow.py::TestSpecialScenarios::test_analytics_retrieval
FAILED tests/backend/test_full_game_flow.py::TestSpecialScenarios::test_post_hole_analysis
FAILED tests/backend/test_full_game_flow.py::TestErrorRecovery::test_invalid_partnership_request
FAILED tests/backend/test_full_game_flow.py::TestErrorRecovery::test_action_out_of_sequence
FAILED tests/backend/test_ghin_local.py::test_ghin_diagnostic - KeyError: 'st...
FAILED tests/backend/test_simulation_components.py::TestComputerPlayer::test_should_accept_partnership_when_behind
FAILED tests/backend/test_simulation_components.py::TestComputerPlayer::test_should_go_solo_when_ahead
FAILED tests/backend/test_simulation_components.py::TestShotSimulation::test_approach_shot_simulation
FAILED tests/backend/test_simulation_components.py::TestPartnershipAdvantage::test_partnership_advantage_calculation
FAILED tests/backend/test_simulation_components.py::TestSimulationFlow::test_simulation_with_mocked_shots
FAILED tests/backend/test_simulation_components_fixed.py::TestWGPPlayer::test_player_creation
FAILED tests/backend/test_simulation_components_fixed.py::TestWGPPlayer::test_computer_player_creation
FAILED tests/backend/test_simulation_components_fixed.py::TestBettingState::test_partnership_request
FAILED tests/backend/test_simulation_components_fixed.py::TestBettingState::test_partnership_acceptance
FAILED tests/backend/test_simulation_components_fixed.py::TestBettingState::test_partnership_decline_goes_solo
FAILED tests/backend/test_simulation_components_fixed.py::TestWolfGoatPigSimulation::test_simulation_initialization
FAILED tests/backend/test_simulation_components_fixed.py::TestWolfGoatPigSimulation::test_set_computer_players
FAILED tests/backend/test_simulation_components_fixed.py::TestWolfGoatPigSimulation::test_request_partnership
FAILED tests/backend/test_simulation_components_fixed.py::TestWolfGoatPigSimulation::test_offer_double
FAILED tests/backend/test_simulation_components_fixed.py::TestWolfGoatPigSimulation::test_advance_hole
FAILED tests/backend/test_simulation_components_fixed.py::TestWolfGoatPigSimulation::test_get_game_state
FAILED tests/backend/test_simulation_components_fixed.py::TestWolfGoatPigSimulation::test_enter_hole_scores
FAILED tests/backend/test_simulation_components_fixed.py::TestHoleProgression::test_shot_progression_initialization
FAILED tests/backend/test_simulation_components_fixed.py::TestHoleProgression::test_timeline_events
FAILED tests/backend/test_simulation_components_fixed.py::TestAnalytics::test_get_advanced_analytics
FAILED tests/backend/test_simulation_components_fixed.py::TestAnalytics::test_post_hole_analysis
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_endpoint_updates_ball_positions
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_team_formation_partners
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_team_formation_solo
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_team_formation_pending_request
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_line_of_scrimmage_and_ordering
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_extended_betting_fields
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_ball_positions_replace
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_wagering_closed_flag
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_with_unknown_player_id
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_before_setup
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_conflicting_shot_order
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_invalid_line_of_scrimmage
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_invalid_next_player
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_invalid_current_order_of_play
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_betting_line_of_scrimmage_invalid
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_double_when_wagering_closed
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_solo_captain_double
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_ping_pong_increment
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_pending_partnership_acceptance
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_pending_partnership_decline
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_multiple_validation_errors
FAILED tests/backend/test_simulation_state_endpoint.py::test_seed_state_reset_doubles_history
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_initialize_game
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_complete_hole_1_simulation
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_complete_hole_2_simulation
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_two_full_holes_simulation
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_timeline_event_structure
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_available_actions_consistency
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_error_handling
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_game_state_consistency
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_captain_rotation
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_partnership_scenarios
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_solo_scenarios
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_betting_scenarios
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_edge_cases
FAILED tests/backend/test_unified_action_api.py::TestUnifiedActionAPI::test_complete_game_flow
================= 78 failed, 110 passed, 103 warnings in 6.81s =================
