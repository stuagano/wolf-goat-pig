[2025-10-20T16:03:18] OpenAI Codex v0.0.0 (research preview)
--------
workdir: /Users/stuartgano/Documents/wolf-goat-pig
model: gpt-5-codex
provider: openai
approval: never
sandbox: read-only
reasoning effort: medium
reasoning summaries: auto
--------
[2025-10-20T16:03:18] User instructions:
Confirm ENABLE_TEST_ENDPOINTS default behavior, helper removal impact, Sunday seeding behavior, GHIN secrets requirement, Sheets validation gaps, and frontend logging guard TODOs for final report references.

Desired output: Key points confirmation

Files to consider: backend, tests/backend, frontend, reports

[Running in read-only mode - no modifications allowed]
[2025-10-20T16:03:19] OpenAI Codex v0.0.0 (research preview)
--------
workdir: /Users/stuartgano/Documents/wolf-goat-pig
model: gpt-5-codex
provider: openai
approval: never
sandbox: read-only
reasoning effort: medium
reasoning summaries: auto
--------
[2025-10-20T16:03:19] User instructions:
Confirm ENABLE_TEST_ENDPOINTS default behavior, helper removal impact, Sunday seeding behavior, GHIN secrets requirement, Sheets validation gaps, and frontend logging guard TODOs for final report references.

Desired output: Key points confirmation

Files to consider: backend, tests/backend, frontend, reports

[Running in read-only mode - no modifications allowed]

[2025-10-20T16:03:25] thinking

**Outlining multi-point information gathering**
[2025-10-20T16:03:26] exec bash -lc 'rg "ENABLE_TEST_ENDPOINTS"' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:03:27] bash -lc 'rg "ENABLE_TEST_ENDPOINTS"' exited 127 in 681ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status

ERROR
bash: rg: command not found
[2025-10-20T16:03:27] tokens used: 3,044

[2025-10-20T16:03:30] thinking

**Handling missing ripgrep fallback**
[2025-10-20T16:03:31] exec bash -lc 'grep -R "ENABLE_TEST_ENDPOINTS" -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:03:41] tokens used: 3,280

[2025-10-20T16:03:42] thinking

**Waiting for next step**
[2025-10-20T16:03:43] tool wait
{
  "call_id": "call_vuvXph44qYDF0yZZWkr0DYEm",
  "timeout_ms": 1000,
  "for": "grep -R \"ENABLE_TEST_ENDPOINTS\" -n"
}
[2025-10-20T16:03:44] tool wait failed
Background job call_vuvXph44qYDF0yZZWkr0DYEm still running...

Output so far (tail):
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
[2025-10-20T16:03:44] tokens used: 3,590

[2025-10-20T16:03:45] thinking

**Waiting for more information**
[2025-10-20T16:03:46] tool wait
{
  "call_id": "call_vuvXph44qYDF0yZZWkr0DYEm",
  "timeout_ms": 1000,
  "for": "grep -R \"ENABLE_TEST_ENDPOINTS\" -n"
}
[2025-10-20T16:03:47] tool wait failed
Background job call_vuvXph44qYDF0yZZWkr0DYEm still running...

Output so far (tail):
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
[2025-10-20T16:03:47] tokens used: 7,091

[2025-10-20T16:03:49] thinking

**Waiting for repo to load**
[2025-10-20T16:03:49] tool wait
{
  "call_id": "call_vuvXph44qYDF0yZZWkr0DYEm",
  "timeout_ms": 10000,
  "for": "grep -R \"ENABLE_TEST_ENDPOINTS\" -n"
}
[2025-10-20T16:03:59] tool wait failed
Background job call_vuvXph44qYDF0yZZWkr0DYEm still running...

Output so far (tail):
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
[2025-10-20T16:03:59] tokens used: 7,254

[2025-10-20T16:04:04] thinking

**Managing long-running command**
[2025-10-20T16:04:05] tool kill
{
  "call_id": "call_vuvXph44qYDF0yZZWkr0DYEm"
}
[2025-10-20T16:04:05] bash -lc 'grep -R "ENABLE_TEST_ENDPOINTS" -n' exited 130 in 0ms:
ERROR
Cancelled by user.
[2025-10-20T16:04:05] tool kill success
Killed background command: grep -R "ENABLE_TEST_ENDPOINTS" -n
[2025-10-20T16:04:05] tokens used: 7,472

[2025-10-20T16:04:07] thinking

**Narrowing the scope**
[2025-10-20T16:04:08] exec bash -lc 'grep -R "ENABLE_TEST_ENDPOINTS" -n backend' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:04:18] tokens used: 7,673

[2025-10-20T16:04:20] thinking

**Reviewing background details**
[2025-10-20T16:04:21] tool wait
{
  "call_id": "call_cBc7k32ko2PyrnApYKqrvpUK",
  "timeout_ms": 1000,
  "for": "grep -R \"ENABLE_TEST_ENDPOINTS\" -n backend"
}
[2025-10-20T16:04:22] tool wait failed
Background job call_cBc7k32ko2PyrnApYKqrvpUK still running...

Output so far (tail):
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
[2025-10-20T16:04:22] tokens used: 8,550

[2025-10-20T16:04:26] thinking

**Pausing momentarily**
[2025-10-20T16:04:26] tool wait
{
  "call_id": "call_cBc7k32ko2PyrnApYKqrvpUK",
  "timeout_ms": 10000,
  "for": "grep -R \"ENABLE_TEST_ENDPOINTS\" -n backend"
}
[2025-10-20T16:04:27] bash -lc 'grep -R "ENABLE_TEST_ENDPOINTS" -n backend' succeeded in 19.36s:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
Binary file backend/app/__pycache__/main.cpython-313.pyc matches
Binary file backend/app/__pycache__/main.cpython-312.pyc matches
backend/app/main.py:141:ENABLE_TEST_ENDPOINTS = os.getenv("ENABLE_TEST_ENDPOINTS", "true").lower() in {"1", "true", "yes"}
backend/app/main.py:4604:if ENABLE_TEST_ENDPOINTS:
[2025-10-20T16:04:27] tool wait success
{"output":"🎯 ADK auto-sync aliases loaded!\n💡 Use 'sync' to sync with upstream anytime\n💡 Use 'synccheck' to check sync status\nBinary file backend/app/__pycache__/main.cpython-313.pyc matches\nBinary file backend/app/__pycache__/main.cpython-312.pyc matches\nbackend/app/main.py:141:ENABLE_TEST_ENDPOINTS = os.getenv(\"ENABLE_TEST_ENDPOINTS\", \"true\").lower() in {\"1\", \"true\", \"yes\"}\nbackend/app/main.py:4604:if ENABLE_TEST_ENDPOINTS:\n","metadata":{"exit_code":0,"duration_seconds":19.4}}
[2025-10-20T16:04:27] tokens used: 8,782

[2025-10-20T16:04:34] thinking

**Verifying default settings and helper removal**
[2025-10-20T16:04:34] exec bash -lc 'ls reports' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:04:35] bash -lc 'ls reports' succeeded in 939ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
backend_dev.log
backend_unit_tests.html
frontend_dev.log
test_summary.md
test.db
wolf_goat_pig.db
[2025-10-20T16:04:35] tokens used: 9,340

[2025-10-20T16:04:37] thinking

**Checking test_summary.md**
[2025-10-20T16:04:38] exec bash -lc 'cat reports/test_summary.md' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:04:39] bash -lc 'cat reports/test_summary.md' succeeded in 1.10s:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
# Simulation Mode Test Results

## Test Summary
- ✅ Backend Unit Tests: PASSED
- ✅ Backend Endpoint Tests: PASSED  
- ✅ Frontend Unit Tests: PASSED
- ✅ Functional Tests: PASSED
- ✅ End-to-End Tests: PASSED

## Test Coverage
- **Unit Tests**: Individual components and functions
- **Integration Tests**: API endpoint functionality
- **Functional Tests**: End-to-end workflows
- **E2E Tests**: Complete user scenarios

## Status
🎉 **ALL TESTS PASSED** - Simulation mode is ready for production use.
[2025-10-20T16:04:39] tokens used: 9,650

[2025-10-20T16:04:41] thinking

**Searching for key terms in codebase**
[2025-10-20T16:04:42] exec bash -lc 'grep -R "Sunday" -n backend tests' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:04:52] tokens used: 10,621

[2025-10-20T16:04:56] thinking

**Focusing search on backend/app directory**
[2025-10-20T16:04:57] exec bash -lc 'grep -R "Sunday" -n backend/app backend/tests' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:04:58] bash -lc 'grep -R "Sunday" -n backend/app backend/tests' succeeded in 869ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
backend/app/models.py:168:    day_of_week = Column(Integer)  # 0=Monday, 1=Tuesday, ..., 6=Sunday
backend/app/models.py:237:    day_of_week = Column(Integer)  # 0=Monday, 6=Sunday
Binary file backend/app/__pycache__/main.cpython-313.pyc matches
Binary file backend/app/__pycache__/schemas.cpython-313.pyc matches
Binary file backend/app/__pycache__/schemas.cpython-312.pyc matches
Binary file backend/app/__pycache__/main.cpython-312.pyc matches
backend/app/schemas.py:422:            raise ValueError('Day of week must be between 0 (Monday) and 6 (Sunday)')
backend/app/main.py:6156:    num_rotations: int = Query(3, description="Number of Sunday pairing options to generate"),
backend/app/main.py:6159:    """Generate randomized Sunday game pairings with optional deterministic seeding."""
backend/app/main.py:6193:        logger.error(f"Error generating Sunday game pairings for {date}: {e}")
backend/app/main.py:6194:        raise HTTPException(status_code=500, detail=f"Failed to generate Sunday pairings: {str(e)}")
backend/app/main.py:6640:        preferred_days: Comma-separated list of preferred days (0=Monday, 6=Sunday)
backend/app/services/matchmaking_service.py:88:            preferred_days: List of preferred days of week (0=Monday, 6=Sunday)
backend/app/services/matchmaking_service.py:213:                     'Friday', 'Saturday', 'Sunday']
backend/app/services/sunday_game_service.py:1:"""Utility functions for preparing Sunday game pairings with randomness support."""
backend/app/services/sunday_game_service.py:50:    """Generate randomized Sunday pairings and select one rotation when multiple exist."""
backend/app/services/sunday_game_service.py:52:        logger.info("Sunday pairings requested with insufficient players: %s", len(players))
[2025-10-20T16:04:58] tokens used: 13,016

[2025-10-20T16:05:00] thinking

**Checking Sunday seeding logic**
[2025-10-20T16:05:01] exec bash -lc "sed -n '1,200p' backend/app/services/sunday_game_service.py" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:05:02] bash -lc 'grep -R "Sunday" -n backend tests' succeeded in 19.62s:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/spanner.v1.json:4499:"description": "Required. Textual representation of the crontab. User can customize the backup frequency and the backup version time using the cron expression. The version time must be in UTC timezone. The backup will contain an externally consistent copy of the database at the version time. Full backups must be scheduled a minimum of 12 hours apart and incremental backups must be scheduled a minimum of 4 hours apart. Examples of valid cron specifications: * `0 2/12 * * *` : every 12 hours at (2, 14) hours past midnight in UTC. * `0 2,14 * * *` : every 12 hours at (2, 14) hours past midnight in UTC. * `0 */4 * * *` : (incremental backups only) every 4 hours at (0, 4, 8, 12, 16, 20) hours past midnight in UTC. * `0 2 * * *` : once a day at 2 past midnight in UTC. * `0 2 * * 0` : once a week every Sunday at 2 past midnight in UTC. * `0 2 8 * *` : once a month on 8th day at 2 past midnight in UTC.",
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/sheets.v4.json:2788:"Group dates by day of week, for example Sunday. The days of the week will be translated based on the spreadsheet locale.",
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/sheets.v4.json:3719:"Sunday"
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/sheets.v4.json:3905:"Group dates by day of week, for example Sunday. The days of the week will be translated based on the spreadsheet locale.",
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/businessprofileperformance.v1.json:291:"Sunday"
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/businessprofileperformance.v1.json:494:"Sunday"
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/composer.v1.json:1664:"description": "Optional. The maintenance window is the period when Cloud Composer components may undergo maintenance. It is defined so that maintenance is not executed during peak hours or critical time periods. The system will not be under maintenance for every occurrence of this window, but when maintenance is planned, it will be scheduled during the window. The maintenance window period must encompass at least 12 hours per week. This may be split into multiple chunks, each with a size of at least 4 hours. If this value is omitted, the default value for maintenance window is applied. By default, maintenance windows are from 00:00:00 to 04:00:00 (GMT) on Friday, Saturday, and Sunday every week."
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/osconfig.v1beta.json:2433:"description": "Represents one week day in a month. An example is \"the 4th Sunday\".",
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/osconfig.v1beta.json:2456:"Sunday"
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/osconfig.v1beta.json:2497:"Sunday"
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/metastore.v1beta.json:2883:"Sunday"
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/authorizedbuyersmarketplace.v1alpha.json:2037:"Sunday"
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/merchantapi.datasources_v1.json:528:"Sunday"
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/mybusinessbusinessinformation.v1.json:1751:"Sunday"
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/mybusinessbusinessinformation.v1.json:1779:"Sunday"
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/alloydb.v1beta.json:2478:"Sunday"
backend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/alloydb.v1beta.json:3408:"Sunday"
[2025-10-20T16:05:02] grep -R "Sunday" -n backend tests completed in background
[2025-10-20T16:05:02] bash -lc "sed -n '1,200p' backend/app/services/sunday_game_service.py" succeeded in 769ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
"""Utility functions for preparing Sunday game pairings with randomness support."""

import logging
import os
from random import Random, SystemRandom
from typing import Dict, List, Optional

from .team_formation_service import TeamFormationService

logger = logging.getLogger(__name__)

SUNDAY_GAME_SEED_ENV = "SUNDAY_GAME_RANDOM_SEED"


def _resolve_seed(explicit_seed: Optional[int]) -> Optional[int]:
    """Determine the random seed from an explicit value or environment variable."""
    if explicit_seed is not None:
[2025-10-20T16:05:02] tokens used: 13,967

[2025-10-20T16:05:09] thinking

**Examining seeding and helper removal details**
[2025-10-20T16:05:10] exec bash -lc 'grep -R "helper" backend/app -n | head' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:05:11] bash -lc 'grep -R "helper" backend/app -n | head' succeeded in 812ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
Binary file backend/app/__pycache__/main.cpython-313.pyc matches
Binary file backend/app/__pycache__/main.cpython-312.pyc matches
backend/app/main.py:82:    """Testing helper payload for manually positioning a ball."""
backend/app/main.py:94:    """Testing helper payload for adjusting betting metadata."""
backend/app/main.py:4608:        """Testing-only helper for seeding the current simulation state.
backend/app/services/legacy_signup_service.py:181:    # Internal helpers
Binary file backend/app/services/__pycache__/odds_calculator.cpython-313.pyc matches
Binary file backend/app/services/__pycache__/odds_calculator.cpython-312.pyc matches
backend/app/services/odds_calculator.py:878:    Public helper that mirrors the simulation engine's stroke-allocation logic.
[2025-10-20T16:05:11] tokens used: 33,054

[2025-10-20T16:05:13] thinking

**Investigating helper removal context**
[2025-10-20T16:05:14] exec bash -lc "sed -n '4560,4640p' backend/app/main.py" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:05:15] bash -lc "sed -n '4560,4640p' backend/app/main.py" succeeded in 696ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
                    
                shot_response = wgp_simulation.simulate_shot(next_player)
                hole_results.append(shot_response)
                shot_count += 1
                
                game_state_data = wgp_simulation.get_game_state()
                if game_state_data.get("hole_complete", False):
                    break
            
            updated_state = wgp_simulation.get_game_state()
            return {
                "success": True,
                "hole_results": hole_results,
                "game_state": updated_state,
                "shots_played": shot_count
            }
        
[2025-10-20T16:05:15] tokens used: 33,746

[2025-10-20T16:05:20] thinking

**Considering helper removal consequences**
[2025-10-20T16:05:21] exec bash -lc 'grep -R "helper" reports -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:05:22] bash -lc 'grep -R "helper" reports -n' exited 1 in 870ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status

ERROR
[2025-10-20T16:05:22] tokens used: 35,352

[2025-10-20T16:05:26] thinking

**Searching for logging guard references**
[2025-10-20T16:05:27] exec bash -lc 'grep -R "logging" frontend/src -n | head' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:05:27] bash -lc 'grep -R "logging" frontend/src -n | head' succeeded in 844ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
[2025-10-20T16:05:27] tokens used: 35,653

[2025-10-20T16:05:29] thinking

**Trying alternative search term**
[2025-10-20T16:05:30] exec bash -lc 'grep -R "TODO" frontend/src -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:05:31] bash -lc 'grep -R "TODO" frontend/src -n' succeeded in 750ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
frontend/src/components/simulation/SimulationMode.js:886:  const useEnhancedLayout = true; // TODO: Make this a user preference
[2025-10-20T16:05:31] tokens used: 36,598

[2025-10-20T16:05:34] thinking

**Rechecking TODO items with expanded search**
[2025-10-20T16:05:35] exec bash -lc 'grep -R "TODO" frontend -n | head' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:05:36] bash -lc 'grep -R "TODO" frontend -n | head' succeeded in 1.69s:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
frontend/node_modules/jest-runtime/build/index.js:1345:          res // TODO: will this work on windows? It might be better if `shouldInstrument` deals with it anyways
frontend/node_modules/jest-runtime/build/index.js:2025:      // TODO: consider warning somehow that this does nothing. We should support deletions, anyways
frontend/node_modules/workbox-strategies/StrategyHandler.js:307:            // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
frontend/node_modules/workbox-strategies/StrategyHandler.js:400:            // TODO(philipwalton): not sure why `any` is needed. It seems like
frontend/node_modules/workbox-strategies/StrategyHandler.js:420:                    // TODO(philipwalton): not sure why `any` is needed. It seems like
frontend/node_modules/workbox-strategies/build/workbox-strategies.dev.js:342:        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams_js.cacheMatchIgnoreParams( // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
frontend/node_modules/workbox-strategies/build/workbox-strategies.dev.js:449:          // TODO(philipwalton): not sure why `any` is needed. It seems like
frontend/node_modules/workbox-strategies/build/workbox-strategies.dev.js:473:              }); // TODO(philipwalton): not sure why `any` is needed. It seems like
frontend/node_modules/workbox-strategies/build/workbox-strategies.dev.js.map:1:{"version":3,"file":"workbox-strategies.dev.js","sources":["../_version.js","../StrategyHandler.js","../Strategy.js","../utils/messages.js","../CacheFirst.js","../CacheOnly.js","../plugins/cacheOkAndOpaquePlugin.js","../NetworkFirst.js","../NetworkOnly.js","../StaleWhileRevalidate.js"],"sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:strategies:6.5.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n    return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * {@link workbox-strategies.Strategy~handle} or\n * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof workbox-strategies\n */\nclass StrategyHandler {\n    /**\n     * Creates a new instance associated with the passed strategy and event\n     * that's handling the request.\n     *\n     * The constructor also initializes the state that will be passed to each of\n     * the plugins handling this request.\n     *\n     * @param {workbox-strategies.Strategy} strategy\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params] The return value from the\n     *     {@link workbox-routing~matchCallback} (if applicable).\n     */\n    constructor(strategy, options) {\n        this._cacheKeys = {};\n        /**\n         * The request the strategy is performing (passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * @name request\n         * @instance\n         * @type {Request}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * The event associated with this request.\n         * @name event\n         * @instance\n         * @type {ExtendableEvent}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `URL` instance of `request.url` (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `url` param will be present if the strategy was invoked\n         * from a workbox `Route` object.\n         * @name url\n         * @instance\n         * @type {URL|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `param` value (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `param` param will be present if the strategy was invoked\n         * from a workbox `Route` object and the\n         * {@link workbox-routing~matchCallback} returned\n         * a truthy value (it will be that value).\n         * @name params\n         * @instance\n         * @type {*|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(options.event, ExtendableEvent, {\n                moduleName: 'workbox-strategies',\n                className: 'StrategyHandler',\n                funcName: 'constructor',\n                paramName: 'options.event',\n            });\n        }\n        Object.assign(this, options);\n        this.event = options.event;\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        // Copy the plugins list (since it's mutable on the strategy),\n        // so any mutations don't affect this handler instance.\n        this._plugins = [...strategy.plugins];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins) {\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    /**\n     * Fetches a given request (and invokes any applicable plugin callback\n     * methods) using the `fetchOptions` (for non-navigation requests) and\n     * `plugins` defined on the `Strategy` object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - `requestWillFetch()`\n     * - `fetchDidSucceed()`\n     * - `fetchDidFail()`\n     *\n     * @param {Request|string} input The URL or request to fetch.\n     * @return {Promise<Response>}\n     */\n    async fetch(input) {\n        const { event } = this;\n        let request = toRequest(input);\n        if (request.mode === 'navigate' &&\n            event instanceof FetchEvent &&\n            event.preloadResponse) {\n            const possiblePreloadResponse = (await event.preloadResponse);\n            if (possiblePreloadResponse) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log(`Using a preloaded navigation response for ` +\n                        `'${getFriendlyURL(request.url)}'`);\n                }\n                return possiblePreloadResponse;\n            }\n        }\n        // If there is a fetchDidFail plugin, we need to save a clone of the\n        // original request before it's either modified by a requestWillFetch\n        // plugin or before the original request's body is consumed via fetch().\n        const originalRequest = this.hasCallback('fetchDidFail')\n            ? request.clone()\n            : null;\n        try {\n            for (const cb of this.iterateCallbacks('requestWillFetch')) {\n                request = await cb({ request: request.clone(), event });\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                throw new WorkboxError('plugin-error-request-will-fetch', {\n                    thrownErrorMessage: err.message,\n                });\n            }\n        }\n        // The request can be altered by plugins with `requestWillFetch` making\n        // the original request (most likely from a `fetch` event) different\n        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n        const pluginFilteredRequest = request.clone();\n        try {\n            let fetchResponse;\n            // See https://github.com/GoogleChrome/workbox/issues/1796\n            fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' returned a response with ` +\n                    `status '${fetchResponse.status}'.`);\n            }\n            for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n                fetchResponse = await callback({\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse,\n                });\n            }\n            return fetchResponse;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.log(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' threw an error.`, error);\n            }\n            // `originalRequest` will only exist if a `fetchDidFail` callback\n            // is being used (see above).\n            if (originalRequest) {\n                await this.runCallbacks('fetchDidFail', {\n                    error: error,\n                    event,\n                    originalRequest: originalRequest.clone(),\n                    request: pluginFilteredRequest.clone(),\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n     * the response generated by `this.fetch()`.\n     *\n     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n     * so you do not have to manually call `waitUntil()` on the event.\n     *\n     * @param {Request|string} input The request or URL to fetch and cache.\n     * @return {Promise<Response>}\n     */\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    /**\n     * Matches a request from the cache (and invokes any applicable plugin\n     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n     * defined on the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cachedResponseWillByUsed()\n     *\n     * @param {Request|string} key The Request or URL to use as the cache key.\n     * @return {Promise<Response|undefined>} A matching response, if found.\n     */\n    async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const { cacheName, matchOptions } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, 'read');\n        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), { cacheName });\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        if (process.env.NODE_ENV !== 'production') {\n            if (cachedResponse) {\n                logger.debug(`Found a cached response in '${cacheName}'.`);\n            }\n            else {\n                logger.debug(`No cached response found in '${cacheName}'.`);\n            }\n        }\n        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n            cachedResponse =\n                (await callback({\n                    cacheName,\n                    matchOptions,\n                    cachedResponse,\n                    request: effectiveRequest,\n                    event: this.event,\n                })) || undefined;\n        }\n        return cachedResponse;\n    }\n    /**\n     * Puts a request/response pair in the cache (and invokes any applicable\n     * plugin callback methods) using the `cacheName` and `plugins` defined on\n     * the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cacheWillUpdate()\n     * - cacheDidUpdate()\n     *\n     * @param {Request|string} key The request or URL to use as the cache key.\n     * @param {Response} response The response to cache.\n     * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n     * not be cached, and `true` otherwise.\n     */\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        // Run in the next task to avoid blocking other cache reads.\n        // https://github.com/w3c/ServiceWorker/issues/1397\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, 'write');\n        if (process.env.NODE_ENV !== 'production') {\n            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n                throw new WorkboxError('attempt-to-cache-non-get-request', {\n                    url: getFriendlyURL(effectiveRequest.url),\n                    method: effectiveRequest.method,\n                });\n            }\n            // See https://github.com/GoogleChrome/workbox/issues/2818\n            const vary = response.headers.get('Vary');\n            if (vary) {\n                logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` +\n                    `has a 'Vary: ${vary}' header. ` +\n                    `Consider setting the {ignoreVary: true} option on your strategy ` +\n                    `to ensure cache matching and deletion works as expected.`);\n            }\n        }\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(`Cannot cache non-existent response for ` +\n                    `'${getFriendlyURL(effectiveRequest.url)}'.`);\n            }\n            throw new WorkboxError('cache-put-with-no-response', {\n                url: getFriendlyURL(effectiveRequest.url),\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +\n                    `will not be cached.`, responseToCache);\n            }\n            return false;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n        const oldResponse = hasCacheUpdateCallback\n            ? await cacheMatchIgnoreParams(\n            // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n            // feature. Consider into ways to only add this behavior if using\n            // precaching.\n            cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions)\n            : null;\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +\n                `for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n                if (error.name === 'QuotaExceededError') {\n                    await executeQuotaErrorCallbacks();\n                }\n                throw error;\n            }\n        }\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event,\n            });\n        }\n        return true;\n    }\n    /**\n     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n     * executes any of those callbacks found in sequence. The final `Request`\n     * object returned by the last plugin is treated as the cache key for cache\n     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n     * been registered, the passed request is returned unmodified\n     *\n     * @param {Request} request\n     * @param {string} mode\n     * @return {Promise<Request>}\n     */\n    async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    // params has a type any can't change right now.\n                    params: this.params, // eslint-disable-line\n                }));\n            }\n            this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n    }\n    /**\n     * Returns true if the strategy has at least one plugin with the given\n     * callback.\n     *\n     * @param {string} name The name of the callback to check for.\n     * @return {boolean}\n     */\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Runs all plugin callbacks matching the given name, in order, passing the\n     * given param object (merged ith the current plugin state) as the only\n     * argument.\n     *\n     * Note: since this method runs all plugins, it's not suitable for cases\n     * where the return value of a callback needs to be applied prior to calling\n     * the next callback. See\n     * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n     * below for how to handle that case.\n     *\n     * @param {string} name The name of the callback to run within each plugin.\n     * @param {Object} param The object to pass as the first (and only) param\n     *     when executing each callback. This object will be merged with the\n     *     current plugin state prior to callback execution.\n     */\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)) {\n            // TODO(philipwalton): not sure why `any` is needed. It seems like\n            // this should work with `as WorkboxPluginCallbackParam[C]`.\n            await callback(param);\n        }\n    }\n    /**\n     * Accepts a callback and returns an iterable of matching plugin callbacks,\n     * where each callback is wrapped with the current handler state (i.e. when\n     * you call each callback, whatever object parameter you pass it will\n     * be merged with the plugin's current state).\n     *\n     * @param {string} name The name fo the callback to run\n     * @return {Array<Function>}\n     */\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (typeof plugin[name] === 'function') {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param) => {\n                    const statefulParam = Object.assign(Object.assign({}, param), { state });\n                    // TODO(philipwalton): not sure why `any` is needed. It seems like\n                    // this should work with `as WorkboxPluginCallbackParam[C]`.\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    /**\n     * Adds a promise to the\n     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n     * of the event event associated with the request being handled (usually a\n     * `FetchEvent`).\n     *\n     * Note: you can await\n     * {@link workbox-strategies.StrategyHandler~doneWaiting}\n     * to know when all added promises have settled.\n     *\n     * @param {Promise} promise A promise to add to the extend lifetime promises\n     *     of the event that triggered the request.\n     */\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    /**\n     * Returns a promise that resolves once all promises passed to\n     * {@link workbox-strategies.StrategyHandler~waitUntil}\n     * have settled.\n     *\n     * Note: any work done after `doneWaiting()` settles should be manually\n     * passed to an event's `waitUntil()` method (not this handler's\n     * `waitUntil()` method), otherwise the service worker thread my be killed\n     * prior to your work completing.\n     */\n    async doneWaiting() {\n        let promise;\n        while ((promise = this._extendLifetimePromises.shift())) {\n            await promise;\n        }\n    }\n    /**\n     * Stops running the strategy and immediately resolves any pending\n     * `waitUntil()` promises.\n     */\n    destroy() {\n        this._handlerDeferred.resolve(null);\n    }\n    /**\n     * This method will call cacheWillUpdate on the available plugins (or use\n     * status === 200) to determine if the Response is safe and valid to cache.\n     *\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @return {Promise<Response|undefined>}\n     *\n     * @private\n     */\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n            responseToCache =\n                (await callback({\n                    request: this.request,\n                    response: responseToCache,\n                    event: this.event,\n                })) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                responseToCache = undefined;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    if (responseToCache.status !== 200) {\n                        if (responseToCache.status === 0) {\n                            logger.warn(`The response for '${this.request.url}' ` +\n                                `is an opaque response. The caching strategy that you're ` +\n                                `using will not cache opaque responses by default.`);\n                        }\n                        else {\n                            logger.debug(`The response for '${this.request.url}' ` +\n                                `returned a status code of '${response.status}' and won't ` +\n                                `be cached as a result.`);\n                        }\n                    }\n                }\n            }\n        }\n        return responseToCache;\n    }\n}\nexport { StrategyHandler };\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\nclass Strategy {\n    /**\n     * Creates a new instance of the strategy and sets all documented option\n     * properties as public instance properties.\n     *\n     * Note: if a custom strategy class extends the base Strategy class and does\n     * not need more than these properties, it does not need to define its own\n     * constructor.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     */\n    constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * {@link workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n    }\n    /**\n     * Perform a request strategy and returns a `Promise` that will resolve with\n     * a `Response`, invoking all relevant plugin callbacks.\n     *\n     * When a strategy instance is registered with a Workbox\n     * {@link workbox-routing.Route}, this method is automatically\n     * called when the route matches.\n     *\n     * Alternatively, this method can be used in a standalone `FetchEvent`\n     * listener by passing it to `event.respondWith()`.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     */\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    /**\n     * Similar to {@link workbox-strategies.Strategy~handle}, but\n     * instead of just returning a `Promise` that resolves to a `Response` it\n     * it will return an tuple of `[response, done]` promises, where the former\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\n     * Promise that will resolve once any promises that were added to\n     * `event.waitUntil()` as part of performing the strategy have completed.\n     *\n     * You can await the `done` promise to ensure any extra work performed by\n     * the strategy (usually caching responses) completes successfully.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     * @return {Array<Promise>} A tuple of [response, done]\n     *     promises that can be used to determine when the response resolves as\n     *     well as when the handler has completed all its work.\n     */\n    handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request,\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string'\n            ? new Request(options.request)\n            : options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, { event, request, params });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', { event, request });\n        let response = undefined;\n        try {\n            response = await this._handle(request, handler);\n            // The \"official\" Strategy subclasses all throw this error automatically,\n            // but in case a third-party Strategy doesn't, ensure that we have a\n            // consistent failure when there's no response or an error response.\n            if (!response || response.type === 'error') {\n                throw new WorkboxError('no-response', { url: request.url });\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                for (const callback of handler.iterateCallbacks('handlerDidError')) {\n                    response = await callback({ error, event, request });\n                    if (response) {\n                        break;\n                    }\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +\n                    `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` +\n                    `a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n            response = await callback({ event, request, response });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n            response = await responseDone;\n        }\n        catch (error) {\n            // Ignore errors, as response errors should be caught via the `response`\n            // promise above. The `done` promise will only throw for errors in\n            // promises passed to `handler.waitUntil()`.\n        }\n        try {\n            await handler.runCallbacks('handlerDidRespond', {\n                event,\n                request,\n                response,\n            });\n            await handler.doneWaiting();\n        }\n        catch (waitUntilError) {\n            if (waitUntilError instanceof Error) {\n                error = waitUntilError;\n            }\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n            event,\n            request,\n            response,\n            error: error,\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport '../_version.js';\nexport const messages = {\n    strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,\n    printFinalResponse: (response) => {\n        if (response) {\n            logger.groupCollapsed(`View the final response here.`);\n            logger.log(response || '[No response returned]');\n            logger.groupEnd();\n        }\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-first-falling-back-to-network)\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass CacheFirst extends Strategy {\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        let response = await handler.cacheMatch(request);\n        let error = undefined;\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this.cacheName}' cache. ` +\n                    `Will respond with a network request.`);\n            }\n            try {\n                response = await handler.fetchAndCachePut(request);\n            }\n            catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Got response from network.`);\n                }\n                else {\n                    logs.push(`Unable to get a response from the network.`);\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { CacheFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-only)\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass CacheOnly extends Strategy {\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        const response = await handler.cacheMatch(request);\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                logger.log(`Found a cached response in the '${this.cacheName}' ` + `cache.`);\n                messages.printFinalResponse(response);\n            }\n            else {\n                logger.log(`No response found in the '${this.cacheName}' cache.`);\n            }\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n}\nexport { CacheOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nexport const cacheOkAndOpaquePlugin = {\n    /**\n     * Returns a valid response (to allow caching) if the status is 200 (OK) or\n     * 0 (opaque).\n     *\n     * @param {Object} options\n     * @param {Response} options.response\n     * @return {Response|null}\n     *\n     * @private\n     */\n    cacheWillUpdate: async ({ response }) => {\n        if (response.status === 200 || response.status === 0) {\n            return response;\n        }\n        return null;\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-first-falling-back-to-cache)\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS](https://enable-cors.org/).\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass NetworkFirst extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */\n    constructor(options = {}) {\n        super(options);\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n        if (!this.plugins.some((p) => 'cacheWillUpdate' in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._networkTimeoutSeconds) {\n                assert.isType(this._networkTimeoutSeconds, 'number', {\n                    moduleName: 'workbox-strategies',\n                    className: this.constructor.name,\n                    funcName: 'constructor',\n                    paramName: 'networkTimeoutSeconds',\n                });\n            }\n        }\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'handle',\n                paramName: 'makeRequest',\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({ request, logs, handler });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({\n            timeoutId,\n            request,\n            logs,\n            handler,\n        });\n        promises.push(networkPromise);\n        const response = await handler.waitUntil((async () => {\n            // Promise.race() will resolve as soon as the first promise resolves.\n            return ((await handler.waitUntil(Promise.race(promises))) ||\n                // If Promise.race() resolved with null, it might be due to a network\n                // timeout + a cache miss. If that were to happen, we'd rather wait until\n                // the networkPromise resolves instead of returning null.\n                // Note that it's fine to await an already-resolved promise, so we don't\n                // have to check to see if it's still \"in flight\".\n                (await networkPromise));\n        })());\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} options.event\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    _getTimeoutPromise({ request, logs, handler, }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve) => {\n            const onNetworkTimeout = async () => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logs.push(`Timing out the network response at ` +\n                        `${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await handler.cacheMatch(request));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId,\n        };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} options.event\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getNetworkPromise({ timeoutId, request, logs, handler, }) {\n        let error;\n        let response;\n        try {\n            response = await handler.fetchAndCachePut(request);\n        }\n        catch (fetchError) {\n            if (fetchError instanceof Error) {\n                error = fetchError;\n            }\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (response) {\n                logs.push(`Got response from network.`);\n            }\n            else {\n                logs.push(`Unable to get a response from the network. Will respond ` +\n                    `with a cached response.`);\n            }\n        }\n        if (error || !response) {\n            response = await handler.cacheMatch(request);\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this.cacheName}'` + ` cache.`);\n                }\n                else {\n                    logs.push(`No response found in the '${this.cacheName}' cache.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { NetworkFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-only)\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass NetworkOnly extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n     * that fail to respond within the timeout will result in a network error.\n     */\n    constructor(options = {}) {\n        super(options);\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: '_handle',\n                paramName: 'request',\n            });\n        }\n        let error = undefined;\n        let response;\n        try {\n            const promises = [\n                handler.fetch(request),\n            ];\n            if (this._networkTimeoutSeconds) {\n                const timeoutPromise = timeout(this._networkTimeoutSeconds * 1000);\n                promises.push(timeoutPromise);\n            }\n            response = await Promise.race(promises);\n            if (!response) {\n                throw new Error(`Timed out the network response after ` +\n                    `${this._networkTimeoutSeconds} seconds.`);\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                error = err;\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                logger.log(`Got response from network.`);\n            }\n            else {\n                logger.log(`Unable to get a response from the network.`);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { NetworkOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [stale-while-revalidate](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate)\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).\n * Opaque responses are cross-origin requests where the response doesn't\n * support [CORS](https://enable-cors.org/).\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass StaleWhileRevalidate extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        super(options);\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n        if (!this.plugins.some((p) => 'cacheWillUpdate' in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'handle',\n                paramName: 'request',\n            });\n        }\n        const fetchAndCachePromise = handler.fetchAndCachePut(request).catch(() => {\n            // Swallow this error because a 'no-response' error will be thrown in\n            // main handler return flow. This will be in the `waitUntil()` flow.\n        });\n        void handler.waitUntil(fetchAndCachePromise);\n        let response = await handler.cacheMatch(request);\n        let error;\n        if (response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this.cacheName}'` +\n                    ` cache. Will update with the network response in the background.`);\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this.cacheName}' cache. ` +\n                    `Will wait for the network response.`);\n            }\n            try {\n                // NOTE(philipwalton): Really annoying that we have to type cast here.\n                // https://github.com/microsoft/TypeScript/issues/20006\n                response = (await fetchAndCachePromise);\n            }\n            catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { StaleWhileRevalidate };\n"],"names":["self","_","e","toRequest","input","Request","StrategyHandler","constructor","strategy","options","_cacheKeys","assert","isInstance","event","ExtendableEvent","moduleName","className","funcName","paramName","Object","assign","_strategy","_handlerDeferred","Deferred","_extendLifetimePromises","_plugins","plugins","_pluginStateMap","Map","plugin","set","waitUntil","promise","fetch","request","mode","FetchEvent","preloadResponse","possiblePreloadResponse","logger","log","getFriendlyURL","url","originalRequest","hasCallback","clone","cb","iterateCallbacks","err","Error","WorkboxError","thrownErrorMessage","message","pluginFilteredRequest","fetchResponse","undefined","fetchOptions","process","debug","status","callback","response","error","runCallbacks","fetchAndCachePut","responseClone","cachePut","cacheMatch","key","cachedResponse","cacheName","matchOptions","effectiveRequest","getCacheKey","multiMatchOptions","caches","match","timeout","method","vary","headers","get","responseToCache","_ensureResponseSafeToCache","cache","open","hasCacheUpdateCallback","oldResponse","cacheMatchIgnoreParams","put","name","executeQuotaErrorCallbacks","newResponse","params","param","state","statefulCallback","statefulParam","push","doneWaiting","shift","destroy","resolve","pluginsUsed","warn","Strategy","cacheNames","getRuntimeName","handle","responseDone","handleAll","handler","_getResponse","handlerDone","_awaitComplete","_handle","type","toString","waitUntilError","messages","strategyStart","strategyName","printFinalResponse","groupCollapsed","groupEnd","CacheFirst","logs","CacheOnly","cacheOkAndOpaquePlugin","cacheWillUpdate","NetworkFirst","some","p","unshift","_networkTimeoutSeconds","networkTimeoutSeconds","isType","promises","timeoutId","id","_getTimeoutPromise","networkPromise","_getNetworkPromise","Promise","race","timeoutPromise","onNetworkTimeout","setTimeout","fetchError","clearTimeout","NetworkOnly","StaleWhileRevalidate","fetchAndCachePromise","catch"],"mappings":"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"}
frontend/node_modules/workbox-strategies/build/workbox-strategies.prod.js.map:1:{"version":3,"file":"workbox-strategies.prod.js","sources":["../_version.js","../StrategyHandler.js","../Strategy.js","../plugins/cacheOkAndOpaquePlugin.js","../CacheFirst.js","../CacheOnly.js","../NetworkFirst.js","../NetworkOnly.js","../StaleWhileRevalidate.js"],"sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:strategies:6.5.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n    return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * {@link workbox-strategies.Strategy~handle} or\n * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof workbox-strategies\n */\nclass StrategyHandler {\n    /**\n     * Creates a new instance associated with the passed strategy and event\n     * that's handling the request.\n     *\n     * The constructor also initializes the state that will be passed to each of\n     * the plugins handling this request.\n     *\n     * @param {workbox-strategies.Strategy} strategy\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params] The return value from the\n     *     {@link workbox-routing~matchCallback} (if applicable).\n     */\n    constructor(strategy, options) {\n        this._cacheKeys = {};\n        /**\n         * The request the strategy is performing (passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * @name request\n         * @instance\n         * @type {Request}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * The event associated with this request.\n         * @name event\n         * @instance\n         * @type {ExtendableEvent}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `URL` instance of `request.url` (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `url` param will be present if the strategy was invoked\n         * from a workbox `Route` object.\n         * @name url\n         * @instance\n         * @type {URL|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `param` value (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `param` param will be present if the strategy was invoked\n         * from a workbox `Route` object and the\n         * {@link workbox-routing~matchCallback} returned\n         * a truthy value (it will be that value).\n         * @name params\n         * @instance\n         * @type {*|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(options.event, ExtendableEvent, {\n                moduleName: 'workbox-strategies',\n                className: 'StrategyHandler',\n                funcName: 'constructor',\n                paramName: 'options.event',\n            });\n        }\n        Object.assign(this, options);\n        this.event = options.event;\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        // Copy the plugins list (since it's mutable on the strategy),\n        // so any mutations don't affect this handler instance.\n        this._plugins = [...strategy.plugins];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins) {\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    /**\n     * Fetches a given request (and invokes any applicable plugin callback\n     * methods) using the `fetchOptions` (for non-navigation requests) and\n     * `plugins` defined on the `Strategy` object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - `requestWillFetch()`\n     * - `fetchDidSucceed()`\n     * - `fetchDidFail()`\n     *\n     * @param {Request|string} input The URL or request to fetch.\n     * @return {Promise<Response>}\n     */\n    async fetch(input) {\n        const { event } = this;\n        let request = toRequest(input);\n        if (request.mode === 'navigate' &&\n            event instanceof FetchEvent &&\n            event.preloadResponse) {\n            const possiblePreloadResponse = (await event.preloadResponse);\n            if (possiblePreloadResponse) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log(`Using a preloaded navigation response for ` +\n                        `'${getFriendlyURL(request.url)}'`);\n                }\n                return possiblePreloadResponse;\n            }\n        }\n        // If there is a fetchDidFail plugin, we need to save a clone of the\n        // original request before it's either modified by a requestWillFetch\n        // plugin or before the original request's body is consumed via fetch().\n        const originalRequest = this.hasCallback('fetchDidFail')\n            ? request.clone()\n            : null;\n        try {\n            for (const cb of this.iterateCallbacks('requestWillFetch')) {\n                request = await cb({ request: request.clone(), event });\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                throw new WorkboxError('plugin-error-request-will-fetch', {\n                    thrownErrorMessage: err.message,\n                });\n            }\n        }\n        // The request can be altered by plugins with `requestWillFetch` making\n        // the original request (most likely from a `fetch` event) different\n        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n        const pluginFilteredRequest = request.clone();\n        try {\n            let fetchResponse;\n            // See https://github.com/GoogleChrome/workbox/issues/1796\n            fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' returned a response with ` +\n                    `status '${fetchResponse.status}'.`);\n            }\n            for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n                fetchResponse = await callback({\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse,\n                });\n            }\n            return fetchResponse;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.log(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' threw an error.`, error);\n            }\n            // `originalRequest` will only exist if a `fetchDidFail` callback\n            // is being used (see above).\n            if (originalRequest) {\n                await this.runCallbacks('fetchDidFail', {\n                    error: error,\n                    event,\n                    originalRequest: originalRequest.clone(),\n                    request: pluginFilteredRequest.clone(),\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n     * the response generated by `this.fetch()`.\n     *\n     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n     * so you do not have to manually call `waitUntil()` on the event.\n     *\n     * @param {Request|string} input The request or URL to fetch and cache.\n     * @return {Promise<Response>}\n     */\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    /**\n     * Matches a request from the cache (and invokes any applicable plugin\n     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n     * defined on the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cachedResponseWillByUsed()\n     *\n     * @param {Request|string} key The Request or URL to use as the cache key.\n     * @return {Promise<Response|undefined>} A matching response, if found.\n     */\n    async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const { cacheName, matchOptions } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, 'read');\n        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), { cacheName });\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        if (process.env.NODE_ENV !== 'production') {\n            if (cachedResponse) {\n                logger.debug(`Found a cached response in '${cacheName}'.`);\n            }\n            else {\n                logger.debug(`No cached response found in '${cacheName}'.`);\n            }\n        }\n        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n            cachedResponse =\n                (await callback({\n                    cacheName,\n                    matchOptions,\n                    cachedResponse,\n                    request: effectiveRequest,\n                    event: this.event,\n                })) || undefined;\n        }\n        return cachedResponse;\n    }\n    /**\n     * Puts a request/response pair in the cache (and invokes any applicable\n     * plugin callback methods) using the `cacheName` and `plugins` defined on\n     * the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cacheWillUpdate()\n     * - cacheDidUpdate()\n     *\n     * @param {Request|string} key The request or URL to use as the cache key.\n     * @param {Response} response The response to cache.\n     * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n     * not be cached, and `true` otherwise.\n     */\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        // Run in the next task to avoid blocking other cache reads.\n        // https://github.com/w3c/ServiceWorker/issues/1397\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, 'write');\n        if (process.env.NODE_ENV !== 'production') {\n            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n                throw new WorkboxError('attempt-to-cache-non-get-request', {\n                    url: getFriendlyURL(effectiveRequest.url),\n                    method: effectiveRequest.method,\n                });\n            }\n            // See https://github.com/GoogleChrome/workbox/issues/2818\n            const vary = response.headers.get('Vary');\n            if (vary) {\n                logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` +\n                    `has a 'Vary: ${vary}' header. ` +\n                    `Consider setting the {ignoreVary: true} option on your strategy ` +\n                    `to ensure cache matching and deletion works as expected.`);\n            }\n        }\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(`Cannot cache non-existent response for ` +\n                    `'${getFriendlyURL(effectiveRequest.url)}'.`);\n            }\n            throw new WorkboxError('cache-put-with-no-response', {\n                url: getFriendlyURL(effectiveRequest.url),\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +\n                    `will not be cached.`, responseToCache);\n            }\n            return false;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n        const oldResponse = hasCacheUpdateCallback\n            ? await cacheMatchIgnoreParams(\n            // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n            // feature. Consider into ways to only add this behavior if using\n            // precaching.\n            cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions)\n            : null;\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +\n                `for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n                if (error.name === 'QuotaExceededError') {\n                    await executeQuotaErrorCallbacks();\n                }\n                throw error;\n            }\n        }\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event,\n            });\n        }\n        return true;\n    }\n    /**\n     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n     * executes any of those callbacks found in sequence. The final `Request`\n     * object returned by the last plugin is treated as the cache key for cache\n     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n     * been registered, the passed request is returned unmodified\n     *\n     * @param {Request} request\n     * @param {string} mode\n     * @return {Promise<Request>}\n     */\n    async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    // params has a type any can't change right now.\n                    params: this.params, // eslint-disable-line\n                }));\n            }\n            this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n    }\n    /**\n     * Returns true if the strategy has at least one plugin with the given\n     * callback.\n     *\n     * @param {string} name The name of the callback to check for.\n     * @return {boolean}\n     */\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Runs all plugin callbacks matching the given name, in order, passing the\n     * given param object (merged ith the current plugin state) as the only\n     * argument.\n     *\n     * Note: since this method runs all plugins, it's not suitable for cases\n     * where the return value of a callback needs to be applied prior to calling\n     * the next callback. See\n     * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n     * below for how to handle that case.\n     *\n     * @param {string} name The name of the callback to run within each plugin.\n     * @param {Object} param The object to pass as the first (and only) param\n     *     when executing each callback. This object will be merged with the\n     *     current plugin state prior to callback execution.\n     */\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)) {\n            // TODO(philipwalton): not sure why `any` is needed. It seems like\n            // this should work with `as WorkboxPluginCallbackParam[C]`.\n            await callback(param);\n        }\n    }\n    /**\n     * Accepts a callback and returns an iterable of matching plugin callbacks,\n     * where each callback is wrapped with the current handler state (i.e. when\n     * you call each callback, whatever object parameter you pass it will\n     * be merged with the plugin's current state).\n     *\n     * @param {string} name The name fo the callback to run\n     * @return {Array<Function>}\n     */\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (typeof plugin[name] === 'function') {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param) => {\n                    const statefulParam = Object.assign(Object.assign({}, param), { state });\n                    // TODO(philipwalton): not sure why `any` is needed. It seems like\n                    // this should work with `as WorkboxPluginCallbackParam[C]`.\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    /**\n     * Adds a promise to the\n     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n     * of the event event associated with the request being handled (usually a\n     * `FetchEvent`).\n     *\n     * Note: you can await\n     * {@link workbox-strategies.StrategyHandler~doneWaiting}\n     * to know when all added promises have settled.\n     *\n     * @param {Promise} promise A promise to add to the extend lifetime promises\n     *     of the event that triggered the request.\n     */\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    /**\n     * Returns a promise that resolves once all promises passed to\n     * {@link workbox-strategies.StrategyHandler~waitUntil}\n     * have settled.\n     *\n     * Note: any work done after `doneWaiting()` settles should be manually\n     * passed to an event's `waitUntil()` method (not this handler's\n     * `waitUntil()` method), otherwise the service worker thread my be killed\n     * prior to your work completing.\n     */\n    async doneWaiting() {\n        let promise;\n        while ((promise = this._extendLifetimePromises.shift())) {\n            await promise;\n        }\n    }\n    /**\n     * Stops running the strategy and immediately resolves any pending\n     * `waitUntil()` promises.\n     */\n    destroy() {\n        this._handlerDeferred.resolve(null);\n    }\n    /**\n     * This method will call cacheWillUpdate on the available plugins (or use\n     * status === 200) to determine if the Response is safe and valid to cache.\n     *\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @return {Promise<Response|undefined>}\n     *\n     * @private\n     */\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n            responseToCache =\n                (await callback({\n                    request: this.request,\n                    response: responseToCache,\n                    event: this.event,\n                })) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                responseToCache = undefined;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    if (responseToCache.status !== 200) {\n                        if (responseToCache.status === 0) {\n                            logger.warn(`The response for '${this.request.url}' ` +\n                                `is an opaque response. The caching strategy that you're ` +\n                                `using will not cache opaque responses by default.`);\n                        }\n                        else {\n                            logger.debug(`The response for '${this.request.url}' ` +\n                                `returned a status code of '${response.status}' and won't ` +\n                                `be cached as a result.`);\n                        }\n                    }\n                }\n            }\n        }\n        return responseToCache;\n    }\n}\nexport { StrategyHandler };\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\nclass Strategy {\n    /**\n     * Creates a new instance of the strategy and sets all documented option\n     * properties as public instance properties.\n     *\n     * Note: if a custom strategy class extends the base Strategy class and does\n     * not need more than these properties, it does not need to define its own\n     * constructor.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     */\n    constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * {@link workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n    }\n    /**\n     * Perform a request strategy and returns a `Promise` that will resolve with\n     * a `Response`, invoking all relevant plugin callbacks.\n     *\n     * When a strategy instance is registered with a Workbox\n     * {@link workbox-routing.Route}, this method is automatically\n     * called when the route matches.\n     *\n     * Alternatively, this method can be used in a standalone `FetchEvent`\n     * listener by passing it to `event.respondWith()`.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     */\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    /**\n     * Similar to {@link workbox-strategies.Strategy~handle}, but\n     * instead of just returning a `Promise` that resolves to a `Response` it\n     * it will return an tuple of `[response, done]` promises, where the former\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\n     * Promise that will resolve once any promises that were added to\n     * `event.waitUntil()` as part of performing the strategy have completed.\n     *\n     * You can await the `done` promise to ensure any extra work performed by\n     * the strategy (usually caching responses) completes successfully.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     * @return {Array<Promise>} A tuple of [response, done]\n     *     promises that can be used to determine when the response resolves as\n     *     well as when the handler has completed all its work.\n     */\n    handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request,\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string'\n            ? new Request(options.request)\n            : options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, { event, request, params });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', { event, request });\n        let response = undefined;\n        try {\n            response = await this._handle(request, handler);\n            // The \"official\" Strategy subclasses all throw this error automatically,\n            // but in case a third-party Strategy doesn't, ensure that we have a\n            // consistent failure when there's no response or an error response.\n            if (!response || response.type === 'error') {\n                throw new WorkboxError('no-response', { url: request.url });\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                for (const callback of handler.iterateCallbacks('handlerDidError')) {\n                    response = await callback({ error, event, request });\n                    if (response) {\n                        break;\n                    }\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +\n                    `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` +\n                    `a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n            response = await callback({ event, request, response });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n            response = await responseDone;\n        }\n        catch (error) {\n            // Ignore errors, as response errors should be caught via the `response`\n            // promise above. The `done` promise will only throw for errors in\n            // promises passed to `handler.waitUntil()`.\n        }\n        try {\n            await handler.runCallbacks('handlerDidRespond', {\n                event,\n                request,\n                response,\n            });\n            await handler.doneWaiting();\n        }\n        catch (waitUntilError) {\n            if (waitUntilError instanceof Error) {\n                error = waitUntilError;\n            }\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n            event,\n            request,\n            response,\n            error: error,\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nexport const cacheOkAndOpaquePlugin = {\n    /**\n     * Returns a valid response (to allow caching) if the status is 200 (OK) or\n     * 0 (opaque).\n     *\n     * @param {Object} options\n     * @param {Response} options.response\n     * @return {Response|null}\n     *\n     * @private\n     */\n    cacheWillUpdate: async ({ response }) => {\n        if (response.status === 200 || response.status === 0) {\n            return response;\n        }\n        return null;\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-first-falling-back-to-network)\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass CacheFirst extends Strategy {\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        let response = await handler.cacheMatch(request);\n        let error = undefined;\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this.cacheName}' cache. ` +\n                    `Will respond with a network request.`);\n            }\n            try {\n                response = await handler.fetchAndCachePut(request);\n            }\n            catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Got response from network.`);\n                }\n                else {\n                    logs.push(`Unable to get a response from the network.`);\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { CacheFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-only)\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass CacheOnly extends Strategy {\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        const response = await handler.cacheMatch(request);\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                logger.log(`Found a cached response in the '${this.cacheName}' ` + `cache.`);\n                messages.printFinalResponse(response);\n            }\n            else {\n                logger.log(`No response found in the '${this.cacheName}' cache.`);\n            }\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n}\nexport { CacheOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-first-falling-back-to-cache)\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS](https://enable-cors.org/).\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass NetworkFirst extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */\n    constructor(options = {}) {\n        super(options);\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n        if (!this.plugins.some((p) => 'cacheWillUpdate' in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._networkTimeoutSeconds) {\n                assert.isType(this._networkTimeoutSeconds, 'number', {\n                    moduleName: 'workbox-strategies',\n                    className: this.constructor.name,\n                    funcName: 'constructor',\n                    paramName: 'networkTimeoutSeconds',\n                });\n            }\n        }\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'handle',\n                paramName: 'makeRequest',\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({ request, logs, handler });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({\n            timeoutId,\n            request,\n            logs,\n            handler,\n        });\n        promises.push(networkPromise);\n        const response = await handler.waitUntil((async () => {\n            // Promise.race() will resolve as soon as the first promise resolves.\n            return ((await handler.waitUntil(Promise.race(promises))) ||\n                // If Promise.race() resolved with null, it might be due to a network\n                // timeout + a cache miss. If that were to happen, we'd rather wait until\n                // the networkPromise resolves instead of returning null.\n                // Note that it's fine to await an already-resolved promise, so we don't\n                // have to check to see if it's still \"in flight\".\n                (await networkPromise));\n        })());\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} options.event\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    _getTimeoutPromise({ request, logs, handler, }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve) => {\n            const onNetworkTimeout = async () => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logs.push(`Timing out the network response at ` +\n                        `${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await handler.cacheMatch(request));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId,\n        };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} options.event\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getNetworkPromise({ timeoutId, request, logs, handler, }) {\n        let error;\n        let response;\n        try {\n            response = await handler.fetchAndCachePut(request);\n        }\n        catch (fetchError) {\n            if (fetchError instanceof Error) {\n                error = fetchError;\n            }\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (response) {\n                logs.push(`Got response from network.`);\n            }\n            else {\n                logs.push(`Unable to get a response from the network. Will respond ` +\n                    `with a cached response.`);\n            }\n        }\n        if (error || !response) {\n            response = await handler.cacheMatch(request);\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this.cacheName}'` + ` cache.`);\n                }\n                else {\n                    logs.push(`No response found in the '${this.cacheName}' cache.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { NetworkFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-only)\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass NetworkOnly extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n     * that fail to respond within the timeout will result in a network error.\n     */\n    constructor(options = {}) {\n        super(options);\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: '_handle',\n                paramName: 'request',\n            });\n        }\n        let error = undefined;\n        let response;\n        try {\n            const promises = [\n                handler.fetch(request),\n            ];\n            if (this._networkTimeoutSeconds) {\n                const timeoutPromise = timeout(this._networkTimeoutSeconds * 1000);\n                promises.push(timeoutPromise);\n            }\n            response = await Promise.race(promises);\n            if (!response) {\n                throw new Error(`Timed out the network response after ` +\n                    `${this._networkTimeoutSeconds} seconds.`);\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                error = err;\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                logger.log(`Got response from network.`);\n            }\n            else {\n                logger.log(`Unable to get a response from the network.`);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { NetworkOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [stale-while-revalidate](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate)\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).\n * Opaque responses are cross-origin requests where the response doesn't\n * support [CORS](https://enable-cors.org/).\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass StaleWhileRevalidate extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        super(options);\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n        if (!this.plugins.some((p) => 'cacheWillUpdate' in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'handle',\n                paramName: 'request',\n            });\n        }\n        const fetchAndCachePromise = handler.fetchAndCachePut(request).catch(() => {\n            // Swallow this error because a 'no-response' error will be thrown in\n            // main handler return flow. This will be in the `waitUntil()` flow.\n        });\n        void handler.waitUntil(fetchAndCachePromise);\n        let response = await handler.cacheMatch(request);\n        let error;\n        if (response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this.cacheName}'` +\n                    ` cache. Will update with the network response in the background.`);\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this.cacheName}' cache. ` +\n                    `Will wait for the network response.`);\n            }\n            try {\n                // NOTE(philipwalton): Really annoying that we have to type cast here.\n                // https://github.com/microsoft/TypeScript/issues/20006\n                response = (await fetchAndCachePromise);\n            }\n            catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { StaleWhileRevalidate };\n"],"names":["self","_","e","toRequest","input","Request","StrategyHandler","constructor","strategy","options","_cacheKeys","Object","assign","this","event","_strategy","_handlerDeferred","Deferred","_extendLifetimePromises","_plugins","plugins","_pluginStateMap","Map","plugin","set","waitUntil","promise","request","mode","FetchEvent","preloadResponse","possiblePreloadResponse","originalRequest","hasCallback","clone","cb","iterateCallbacks","err","Error","WorkboxError","thrownErrorMessage","message","pluginFilteredRequest","fetchResponse","fetch","undefined","fetchOptions","callback","response","error","runCallbacks","responseClone","cachePut","key","cachedResponse","cacheName","matchOptions","effectiveRequest","getCacheKey","multiMatchOptions","caches","match","timeout","url","getFriendlyURL","responseToCache","_ensureResponseSafeToCache","cache","open","hasCacheUpdateCallback","oldResponse","cacheMatchIgnoreParams","put","name","executeQuotaErrorCallbacks","newResponse","params","param","state","get","statefulCallback","statefulParam","push","shift","destroy","resolve","pluginsUsed","status","Strategy","cacheNames","getRuntimeName","handle","responseDone","handleAll","handler","_getResponse","_awaitComplete","_handle","type","doneWaiting","waitUntilError","cacheOkAndOpaquePlugin","cacheWillUpdate","async","cacheMatch","fetchAndCachePut","some","p","unshift","_networkTimeoutSeconds","networkTimeoutSeconds","logs","promises","timeoutId","id","_getTimeoutPromise","networkPromise","_getNetworkPromise","Promise","race","setTimeout","fetchError","clearTimeout","timeoutPromise","fetchAndCachePromise","catch"],"mappings":"+FAEA,IACIA,KAAK,6BAA+BC,GACvC,CACD,MAAOC,ICWP,SAASC,EAAUC,SACS,iBAAVA,EAAqB,IAAIC,QAAQD,GAASA,CAC3D,CAUD,MAAME,EAiBFC,YAAYC,EAAUC,QACbC,GAAa,GA8ClBC,OAAOC,OAAOC,KAAMJ,QACfK,MAAQL,EAAQK,WAChBC,GAAYP,OACZQ,GAAmB,IAAIC,gBACvBC,GAA0B,QAG1BC,GAAW,IAAIX,EAASY,cACxBC,GAAkB,IAAIC,QACtB,MAAMC,KAAUV,KAAKM,QACjBE,GAAgBG,IAAID,EAAQ,SAEhCT,MAAMW,UAAUZ,KAAKG,GAAiBU,qBAenCtB,SACFU,MAAEA,GAAUD,SACdc,EAAUxB,EAAUC,MACH,aAAjBuB,EAAQC,MACRd,aAAiBe,YACjBf,EAAMgB,gBAAiB,OACjBC,QAAiCjB,EAAMgB,mBACzCC,SAKOA,QAMTC,EAAkBnB,KAAKoB,YAAY,gBACnCN,EAAQO,QACR,aAEG,MAAMC,KAAMtB,KAAKuB,iBAAiB,oBACnCT,QAAgBQ,EAAG,CAAER,QAASA,EAAQO,QAASpB,UAGvD,MAAOuB,MACCA,aAAeC,YACT,IAAIC,eAAa,kCAAmC,CACtDC,mBAAoBH,EAAII,gBAO9BC,EAAwBf,EAAQO,gBAE9BS,EAEJA,QAAsBC,MAAMjB,EAA0B,aAAjBA,EAAQC,UAAsBiB,EAAYhC,KAAKE,GAAU+B,kBAMzF,MAAMC,KAAYlC,KAAKuB,iBAAiB,mBACzCO,QAAsBI,EAAS,CAC3BjC,QACAa,QAASe,EACTM,SAAUL,WAGXA,EAEX,MAAOM,SAOCjB,SACMnB,KAAKqC,aAAa,eAAgB,CACpCD,MAAOA,EACPnC,QACAkB,gBAAiBA,EAAgBE,QACjCP,QAASe,EAAsBR,UAGjCe,0BAaS7C,SACb4C,QAAiBnC,KAAK+B,MAAMxC,GAC5B+C,EAAgBH,EAASd,eAC1BrB,KAAKY,UAAUZ,KAAKuC,SAAShD,EAAO+C,IAClCH,mBAcMK,SACP1B,EAAUxB,EAAUkD,OACtBC,QACEC,UAAEA,EAAFC,aAAaA,GAAiB3C,KAAKE,GACnC0C,QAAyB5C,KAAK6C,YAAY/B,EAAS,QACnDgC,EAAoBhD,OAAOC,OAAOD,OAAOC,OAAO,GAAI4C,GAAe,CAAED,cAC3ED,QAAuBM,OAAOC,MAAMJ,EAAkBE,OASjD,MAAMZ,KAAYlC,KAAKuB,iBAAiB,4BACzCkB,QACWP,EAAS,CACZQ,YACAC,eACAF,iBACA3B,QAAS8B,EACT3C,MAAOD,KAAKC,cACT+B,SAERS,iBAiBID,EAAKL,SACVrB,EAAUxB,EAAUkD,SAGpBS,UAAQ,SACRL,QAAyB5C,KAAK6C,YAAY/B,EAAS,aAiBpDqB,QAKK,IAAIT,eAAa,6BAA8B,CACjDwB,IAAKC,iBAAeP,EAAiBM,aAGvCE,QAAwBpD,KAAKqD,GAA2BlB,OACzDiB,SAKM,QAELV,UAAEA,EAAFC,aAAaA,GAAiB3C,KAAKE,GACnCoD,QAAcnE,KAAK4D,OAAOQ,KAAKb,GAC/Bc,EAAyBxD,KAAKoB,YAAY,kBAC1CqC,EAAcD,QACRE,yBAIRJ,EAAOV,EAAiBvB,QAAS,CAAC,mBAAoBsB,GACpD,eAMIW,EAAMK,IAAIf,EAAkBY,EAAyBJ,EAAgB/B,QAAU+B,GAEzF,MAAOhB,MACCA,aAAiBX,WAEE,uBAAfW,EAAMwB,YACAC,+BAEJzB,MAGT,MAAMF,KAAYlC,KAAKuB,iBAAiB,wBACnCW,EAAS,CACXQ,YACAe,cACAK,YAAaV,EAAgB/B,QAC7BP,QAAS8B,EACT3C,MAAOD,KAAKC,eAGb,oBAaOa,EAASC,SACjByB,EAAO,GAAE1B,EAAQoC,SAASnC,QAC3Bf,KAAKH,GAAW2C,GAAM,KACnBI,EAAmB9B,MAClB,MAAMoB,KAAYlC,KAAKuB,iBAAiB,sBACzCqB,EAAmBtD,QAAgB4C,EAAS,CACxCnB,OACAD,QAAS8B,EACT3C,MAAOD,KAAKC,MAEZ8D,OAAQ/D,KAAK+D,eAGhBlE,GAAW2C,GAAOI,SAEpB5C,KAAKH,GAAW2C,GAS3BpB,YAAYwC,OACH,MAAMlD,KAAUV,KAAKE,GAAUK,WAC5BqD,KAAQlD,SACD,SAGR,qBAkBQkD,EAAMI,OAChB,MAAM9B,KAAYlC,KAAKuB,iBAAiBqC,SAGnC1B,EAAS8B,qBAYLJ,OACT,MAAMlD,KAAUV,KAAKE,GAAUK,WACJ,mBAAjBG,EAAOkD,GAAsB,OAC9BK,EAAQjE,KAAKQ,GAAgB0D,IAAIxD,GACjCyD,EAAoBH,UAChBI,EAAgBtE,OAAOC,OAAOD,OAAOC,OAAO,GAAIiE,GAAQ,CAAEC,iBAGzDvD,EAAOkD,GAAMQ,EAApB,QAEED,GAiBlBvD,UAAUC,eACDR,GAAwBgE,KAAKxD,GAC3BA,0BAaHA,OACIA,EAAUb,KAAKK,GAAwBiE,eACrCzD,EAOd0D,eACSpE,GAAiBqE,QAAQ,eAYDrC,OACzBiB,EAAkBjB,EAClBsC,GAAc,MACb,MAAMvC,KAAYlC,KAAKuB,iBAAiB,sBACzC6B,QACWlB,EAAS,CACZpB,QAASd,KAAKc,QACdqB,SAAUiB,EACVnD,MAAOD,KAAKC,cACT+B,EACXyC,GAAc,GACTrB,eAIJqB,GACGrB,GAA8C,MAA3BA,EAAgBsB,SACnCtB,OAAkBpB,GAmBnBoB,GC/ef,MAAMuB,EAuBFjF,YAAYE,EAAU,SAQb8C,UAAYkC,aAAWC,eAAejF,EAAQ8C,gBAQ9CnC,QAAUX,EAAQW,SAAW,QAQ7B0B,aAAerC,EAAQqC,kBAQvBU,aAAe/C,EAAQ+C,aAqBhCmC,OAAOlF,SACImF,GAAgB/E,KAAKgF,UAAUpF,UAC/BmF,EAwBXC,UAAUpF,GAEFA,aAAmBoB,aACnBpB,EAAU,CACNK,MAAOL,EACPkB,QAASlB,EAAQkB,gBAGnBb,EAAQL,EAAQK,MAChBa,EAAqC,iBAApBlB,EAAQkB,QACzB,IAAItB,QAAQI,EAAQkB,SACpBlB,EAAQkB,QACRiD,EAAS,WAAYnE,EAAUA,EAAQmE,YAAS/B,EAChDiD,EAAU,IAAIxF,EAAgBO,KAAM,CAAEC,QAAOa,UAASiD,WACtDgB,EAAe/E,KAAKkF,GAAaD,EAASnE,EAASb,SAGlD,CAAC8E,EAFY/E,KAAKmF,GAAeJ,EAAcE,EAASnE,EAASb,aAIzDgF,EAASnE,EAASb,OAE7BkC,QADE8C,EAAQ5C,aAAa,mBAAoB,CAAEpC,QAAOa,mBAGpDqB,QAAiBnC,KAAKoF,QAAQtE,EAASmE,IAIlC9C,GAA8B,UAAlBA,EAASkD,WAChB,IAAI3D,eAAa,cAAe,CAAEwB,IAAKpC,EAAQoC,MAG7D,MAAOd,MACCA,aAAiBX,UACZ,MAAMS,KAAY+C,EAAQ1D,iBAAiB,sBAC5CY,QAAiBD,EAAS,CAAEE,QAAOnC,QAAOa,YACtCqB,YAKPA,QACKC,MAQT,MAAMF,KAAY+C,EAAQ1D,iBAAiB,sBAC5CY,QAAiBD,EAAS,CAAEjC,QAAOa,UAASqB,oBAEzCA,WAEU4C,EAAcE,EAASnE,EAASb,OAC7CkC,EACAC,MAEAD,QAAiB4C,EAErB,MAAO3C,cAMG6C,EAAQ5C,aAAa,oBAAqB,CAC5CpC,QACAa,UACAqB,mBAEE8C,EAAQK,cAElB,MAAOC,GACCA,aAA0B9D,QAC1BW,EAAQmD,YAGVN,EAAQ5C,aAAa,qBAAsB,CAC7CpC,QACAa,UACAqB,WACAC,MAAOA,IAEX6C,EAAQV,UACJnC,QACMA,GCtMX,MAAMoD,EAAyB,CAWlCC,gBAAiBC,OAASvD,cACE,MAApBA,EAASuC,QAAsC,IAApBvC,EAASuC,OAC7BvC,EAEJ,0BCIf,cAAyBwC,gBAQP7D,EAASmE,OAWf7C,EADAD,QAAiB8C,EAAQU,WAAW7E,OAEnCqB,MAMGA,QAAiB8C,EAAQW,iBAAiB9E,GAE9C,MAAOU,GACCA,aAAeC,QACfW,EAAQZ,OAyBfW,QACK,IAAIT,eAAa,cAAe,CAAEwB,IAAKpC,EAAQoC,IAAKd,iBAEvDD,gBC5Df,cAAwBwC,gBAQN7D,EAASmE,SASb9C,QAAiB8C,EAAQU,WAAW7E,OAYrCqB,QACK,IAAIT,eAAa,cAAe,CAAEwB,IAAKpC,EAAQoC,aAElDf,mBC3Bf,cAA2BwC,EAoBvBjF,YAAYE,EAAU,UACZA,GAGDI,KAAKO,QAAQsF,MAAMC,GAAM,oBAAqBA,UAC1CvF,QAAQwF,QAAQP,QAEpBQ,GAAyBpG,EAAQqG,uBAAyB,gBAmBrDnF,EAASmE,SACbiB,EAAO,GASPC,EAAW,OACbC,KACApG,KAAKgG,GAAwB,OACvBK,GAAEA,EAAFxF,QAAMA,GAAYb,KAAKsG,GAAmB,CAAExF,UAASoF,OAAMjB,YACjEmB,EAAYC,EACZF,EAAS9B,KAAKxD,SAEZ0F,EAAiBvG,KAAKwG,GAAmB,CAC3CJ,YACAtF,UACAoF,OACAjB,YAEJkB,EAAS9B,KAAKkC,SACRpE,QAAiB8C,EAAQrE,UAAU,gBAEtBqE,EAAQrE,UAAU6F,QAAQC,KAAKP,WAMnCI,EAR0B,QAkBpCpE,QACK,IAAIT,eAAa,cAAe,CAAEwB,IAAKpC,EAAQoC,aAElDf,EAWXmE,IAAmBxF,QAAEA,EAAFoF,KAAWA,EAAXjB,QAAiBA,QAC5BmB,QAWG,CACHvF,QAXmB,IAAI4F,SAASjC,IAQhC4B,EAAYO,YAPajB,UAKrBlB,QAAcS,EAAQU,WAAW7E,GAAjC,GAEmE,IAA9Bd,KAAKgG,GAA9C,IAIAK,GAAID,aAaaA,UAAEA,EAAFtF,QAAaA,EAAboF,KAAsBA,EAAtBjB,QAA4BA,QAC7C7C,EACAD,MAEAA,QAAiB8C,EAAQW,iBAAiB9E,GAE9C,MAAO8F,GACCA,aAAsBnF,QACtBW,EAAQwE,UAGZR,GACAS,aAAaT,IAWbhE,GAAUD,IACVA,QAAiB8C,EAAQU,WAAW7E,IAUjCqB,kBCtKf,cAA0BwC,EAYtBjF,YAAYE,EAAU,UACZA,QACDoG,GAAyBpG,EAAQqG,uBAAyB,gBASrDnF,EAASmE,OASf7C,EACAD,YAEMgE,EAAW,CACblB,EAAQlD,MAAMjB,OAEdd,KAAKgG,GAAwB,OACvBc,EAAiB7D,UAAsC,IAA9BjD,KAAKgG,IACpCG,EAAS9B,KAAKyC,MAElB3E,QAAiBsE,QAAQC,KAAKP,IACzBhE,QACK,IAAIV,MACL,wCAAEzB,KAAKgG,eAGpB,MAAOxE,GACCA,aAAeC,QACfW,EAAQZ,OAcXW,QACK,IAAIT,eAAa,cAAe,CAAEwB,IAAKpC,EAAQoC,IAAKd,iBAEvDD,2BC3Df,cAAmCwC,EAc/BjF,YAAYE,EAAU,UACZA,GAGDI,KAAKO,QAAQsF,MAAMC,GAAM,oBAAqBA,UAC1CvF,QAAQwF,QAAQP,iBAUf1E,EAASmE,SAUb8B,EAAuB9B,EAAQW,iBAAiB9E,GAASkG,OAAM,SAIhE/B,EAAQrE,UAAUmG,OAEnB3E,EADAD,QAAiB8C,EAAQU,WAAW7E,MAEpCqB,YAcIA,QAAkB4E,EAEtB,MAAOvF,GACCA,aAAeC,QACfW,EAAQZ,OAYfW,QACK,IAAIT,eAAa,cAAe,CAAEwB,IAAKpC,EAAQoC,IAAKd,iBAEvDD"}
[2025-10-20T16:05:36] tokens used: 37,709

[2025-10-20T16:05:40] thinking

**Searching for logging guard references**
[2025-10-20T16:05:40] exec bash -lc 'grep -R "logging guard" -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:05:50] tokens used: 38,401

[2025-10-20T16:05:52] thinking

**Pausing for next step**
[2025-10-20T16:05:53] tool wait
{
  "call_id": "call_wo9V6XxdaotY1iQ6atknTC0c",
  "timeout_ms": 1000,
  "for": "grep -R \"logging guard\" -n"
}
[2025-10-20T16:05:54] tool wait failed
Background job call_wo9V6XxdaotY1iQ6atknTC0c still running...

Output so far (tail):
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
[2025-10-20T16:05:54] tokens used: 39,269

[2025-10-20T16:05:56] thinking

**Waiting for more input**
[2025-10-20T16:05:56] tool wait
{
  "call_id": "call_wo9V6XxdaotY1iQ6atknTC0c",
  "timeout_ms": 10000,
  "for": "grep -R \"logging guard\" -n"
}
[2025-10-20T16:06:06] tool wait failed
Background job call_wo9V6XxdaotY1iQ6atknTC0c still running...

Output so far (tail):
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
[2025-10-20T16:06:06] tokens used: 39,492

[2025-10-20T16:06:09] thinking

**Considering search scope to avoid overload**
[2025-10-20T16:06:10] tool kill
{
  "call_id": "call_wo9V6XxdaotY1iQ6atknTC0c"
}
[2025-10-20T16:06:10] bash -lc 'grep -R "logging guard" -n' exited 130 in 0ms:
ERROR
Cancelled by user.
[2025-10-20T16:06:10] tool kill success
Killed background command: grep -R "logging guard" -n
[2025-10-20T16:06:10] tokens used: 39,703

[2025-10-20T16:06:13] thinking

**Searching for relevant TODOs in frontend**
[2025-10-20T16:06:14] exec bash -lc 'find frontend/src -maxdepth 2 -type d' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:06:15] bash -lc 'find frontend/src -maxdepth 2 -type d' succeeded in 708ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
frontend/src
frontend/src/__mocks__
frontend/src/context
frontend/src/context/__tests__
frontend/src/config
frontend/src/utils
frontend/src/utils/__tests__
frontend/src/components
frontend/src/components/ui
frontend/src/components/tutorial
frontend/src/components/auth
frontend/src/components/signup
frontend/src/components/simulation
frontend/src/components/game
frontend/src/components/__tests__
frontend/src/components/practice
frontend/src/components/email
[2025-10-20T16:06:15] tokens used: 39,882

[2025-10-20T16:06:17] thinking

**Searching for logging guard**
[2025-10-20T16:06:18] exec bash -lc 'ls frontend/src/utils' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:06:19] bash -lc 'ls frontend/src/utils' succeeded in 774ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
__tests__
api.js
[2025-10-20T16:06:19] tokens used: 40,488

[2025-10-20T16:06:21] thinking

**Checking for logger files**
[2025-10-20T16:06:22] exec bash -lc "find frontend/src -name '*log*' -maxdepth 3" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:06:23] bash -lc "find frontend/src -name '*log*' -maxdepth 3" succeeded in 750ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
[2025-10-20T16:06:23] tokens used: 40,728

[2025-10-20T16:06:26] thinking

**Searching for guard files in frontend/src**
[2025-10-20T16:06:27] exec bash -lc 'grep -R "guard" frontend/src -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:06:27] bash -lc 'grep -R "guard" frontend/src -n' succeeded in 834ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
frontend/src/components/tutorial/modules/PracticeGameModule.js:150:        description: 'Straight par 4 with bunkers guarding the green',
[2025-10-20T16:06:27] tokens used: 40,975

[2025-10-20T16:06:39] thinking

**Investigating logging guard and helper impacts**
[2025-10-20T16:06:40] exec bash -lc 'grep -R "seed-state" -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:06:50] tokens used: 41,661

[2025-10-20T16:06:52] thinking

**Pausing briefly**
[2025-10-20T16:06:53] tool wait
{
  "call_id": "call_yfIZTusgwvkCDttJFLR281Y6",
  "timeout_ms": 10000,
  "for": "grep -R \"seed-state\" -n"
}
[2025-10-20T16:07:03] tool wait failed
Background job call_yfIZTusgwvkCDttJFLR281Y6 still running...

Output so far (tail):
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
[2025-10-20T16:07:03] tokens used: 42,283

[2025-10-20T16:07:05] thinking

**Refining search scope**
[2025-10-20T16:07:06] tool kill
{
  "call_id": "call_yfIZTusgwvkCDttJFLR281Y6"
}
[2025-10-20T16:07:06] bash -lc 'grep -R "seed-state" -n' exited 130 in 0ms:
ERROR
Cancelled by user.
[2025-10-20T16:07:06] tool kill success
Killed background command: grep -R "seed-state" -n
[2025-10-20T16:07:06] tokens used: 42,500

[2025-10-20T16:07:08] thinking

**Running targeted tests**
[2025-10-20T16:07:09] exec bash -lc 'grep -R "seed-state" -n backend' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:07:19] tokens used: 42,683

[2025-10-20T16:07:21] thinking

**Pausing briefly**
[2025-10-20T16:07:22] tool wait
{
  "call_id": "call_9n4LWVJvKOPXiIVmbvXj0WZa",
  "timeout_ms": 1000,
  "for": "grep -R \"seed-state\" -n backend"
}
[2025-10-20T16:07:23] tool wait failed
Background job call_9n4LWVJvKOPXiIVmbvXj0WZa still running...

Output so far (tail):
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
[2025-10-20T16:07:23] tokens used: 42,911

[2025-10-20T16:07:26] thinking

**Pausing briefly**
[2025-10-20T16:07:26] tool wait
{
  "call_id": "call_9n4LWVJvKOPXiIVmbvXj0WZa",
  "timeout_ms": 10000,
  "for": "grep -R \"seed-state\" -n backend"
}
[2025-10-20T16:07:31] bash -lc 'grep -R "seed-state" -n backend' succeeded in 21.43s:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
Binary file backend/app/__pycache__/main.cpython-313.pyc matches
Binary file backend/app/__pycache__/main.cpython-312.pyc matches
backend/app/main.py:4606:    @app.post("/simulation/test/seed-state")
[2025-10-20T16:07:31] tool wait success
{"output":"🎯 ADK auto-sync aliases loaded!\n💡 Use 'sync' to sync with upstream anytime\n💡 Use 'synccheck' to check sync status\nBinary file backend/app/__pycache__/main.cpython-313.pyc matches\nBinary file backend/app/__pycache__/main.cpython-312.pyc matches\nbackend/app/main.py:4606:    @app.post(\"/simulation/test/seed-state\")\n","metadata":{"exit_code":0,"duration_seconds":21.4}}
[2025-10-20T16:07:31] tokens used: 43,134

[2025-10-20T16:07:34] thinking

**Searching for GHIN references**
[2025-10-20T16:07:34] exec bash -lc 'grep -R "GHIN" -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:07:44] tokens used: 43,466

[2025-10-20T16:07:47] thinking

**Reviewing secret requirements in backend**
[2025-10-20T16:07:48] exec bash -lc "nl -ba backend/app/main.py | sed -n '820,940p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:07:49] bash -lc "nl -ba backend/app/main.py | sed -n '820,940p'" succeeded in 783ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
   820	                    "name": "USGA Course Database",
   821	                    "description": "Official USGA course database with ratings and slopes",
   822	                    "endpoint": "/courses/import/search"
   823	                },
   824	                {
   825	                    "name": "JSON File Upload",
   826	                    "description": "Upload custom course data in JSON format",
   827	                    "endpoint": "/courses/import/file"
   828	                }
   829	            ]
   830	        }
   831	    except Exception as e:
   832	        logger.error(f"Error getting import sources: {e}")
   833	        raise HTTPException(status_code=500, detail="Failed to get import sources")
   834	
   835	@app.post("/courses/import/preview")
   836	async def preview_course_import(request: CourseImportRequest):
[2025-10-20T16:07:49] tokens used: 46,753

[2025-10-20T16:07:51] thinking

**Verifying environment variable usage**
[2025-10-20T16:07:52] exec bash -lc "nl -ba backend/app/services/ghin_service.py | sed -n '1,200p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:07:52] bash -lc "nl -ba backend/app/services/ghin_service.py | sed -n '1,200p'" succeeded in 740ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
     1	"""
     2	GHIN Service for integrating with Golf Handicap Information Network
     3	
     4	This service handles:
     5	- Syncing player handicaps from GHIN
     6	- Fetching recent scores 
     7	- Updating local database with GHIN data
     8	- Joining GHIN data with existing player statistics
     9	"""
    10	
    11	from typing import List, Dict, Optional, Any
    12	from sqlalchemy.orm import Session
    13	from sqlalchemy import and_, desc
    14	from datetime import datetime, timedelta
    15	import logging
    16	import os
    17	import httpx # Added httpx for API calls
[2025-10-20T16:07:52] tokens used: 48,936

[2025-10-20T16:07:56] thinking

**Analyzing GHIN environment variables**
[2025-10-20T16:07:57] exec bash -lc "nl -ba backend/.env.example | sed -n '60,120p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:07:58] bash -lc "nl -ba backend/.env.example | sed -n '60,120p'" succeeded in 889ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
    60	# Leave empty for development to allow all origins
    61	ALLOWED_ORIGINS=
    62	
    63	# JWT secret key (for future authentication features)
    64	# Generate with: python -c "import secrets; print(secrets.token_urlsafe(32))"
    65	JWT_SECRET_KEY=
    66	
    67	# =============================================================================
    68	# PERFORMANCE SETTINGS
    69	# =============================================================================
    70	
    71	# Database connection pool settings
    72	DB_POOL_SIZE=5
    73	DB_POOL_OVERFLOW=10
    74	DB_POOL_RECYCLE=300
    75	
    76	# Monte Carlo simulation settings
[2025-10-20T16:07:58] tokens used: 52,025

[2025-10-20T16:08:00] thinking

**Checking earlier parts for GHIN**
[2025-10-20T16:08:01] exec bash -lc "nl -ba backend/.env.example | sed -n '1,60p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:08:02] bash -lc "nl -ba backend/.env.example | sed -n '1,60p'" succeeded in 725ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
     1	# Wolf-Goat-Pig Application Environment Configuration
     2	# Copy this file to .env and customize for your deployment
     3	
     4	# =============================================================================
     5	# ENVIRONMENT SETTINGS
     6	# =============================================================================
     7	
     8	# Environment type: development, production, testing
     9	ENVIRONMENT=development
    10	
    11	# Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
    12	LOG_LEVEL=INFO
    13	
    14	# =============================================================================
    15	# SERVER CONFIGURATION
    16	# =============================================================================
    17	
[2025-10-20T16:08:02] tokens used: 52,893

[2025-10-20T16:08:08] thinking

**Verifying GHIN secrets consistency**
[2025-10-20T16:08:09] exec bash -lc "nl -ba backend/app/services/sheet_integration_service.py | sed -n '1,200p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:08:09] bash -lc "nl -ba backend/app/services/sheet_integration_service.py | sed -n '1,200p'" succeeded in 788ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
     1	"""
     2	Sheet Integration Service
     3	
     4	This service provides functionality to integrate with Google Sheets data
     5	and create a read replica of spreadsheet-based metrics and leaderboards.
     6	
     7	Features:
     8	- Data mapping from sheet structure to database models
     9	- Batch data import/sync utilities
    10	- Custom metric calculation for sheet compatibility
    11	- Export functionality for migration validation
    12	"""
    13	
    14	from typing import List, Dict, Any, Optional
    15	from sqlalchemy.orm import Session
    16	from sqlalchemy import func, desc, asc
    17	from datetime import datetime
[2025-10-20T16:08:09] tokens used: 53,931

[2025-10-20T16:08:12] thinking

**Searching for validation gaps**
[2025-10-20T16:08:13] exec bash -lc "nl -ba backend/app/services/sheet_integration_service.py | sed -n '200,400p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:08:13] bash -lc "nl -ba backend/app/services/sheet_integration_service.py | sed -n '200,400p'" succeeded in 790ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
   200	        )
   201	    
   202	    def create_leaderboard_from_sheet_data(self, sheet_data: List[Dict[str, Any]], 
   203	                                         mappings: List[SheetColumnMapping]) -> List[Dict[str, Any]]:
   204	        """Create a leaderboard from sheet data."""
   205	        validated_rows = []
   206	        
   207	        for row in sheet_data:
   208	            validated_row = self.validate_sheet_row(row, mappings)
   209	            if not validated_row.validation_errors:
   210	                validated_rows.append(validated_row.mapped_data)
   211	            else:
   212	                logger.warning(f"Row validation errors: {validated_row.validation_errors}")
   213	        
   214	        # Sort by total earnings (or primary metric)
   215	        if validated_rows and "total_earnings" in validated_rows[0]:
   216	            validated_rows.sort(key=lambda x: x.get("total_earnings", 0), reverse=True)
[2025-10-20T16:08:13] tokens used: 57,308

[2025-10-20T16:08:18] thinking

**Analyzing validation coverage for sheets**
[2025-10-20T16:08:19] exec bash -lc 'grep -R "Sheet" backend/tests -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:08:20] bash -lc 'grep -R "Sheet" backend/tests -n' exited 1 in 954ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status

ERROR
[2025-10-20T16:08:20] tokens used: 60,982
[2025-10-20T16:08:20] bash -lc 'grep -R "GHIN" -n' succeeded in 45.51s:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:14878:      3 | class GHINService {
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:14921:      3 | class GHINService {
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:18396:                  [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:18463:                  [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:18530:                  [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:18597:                  [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:18751:                  [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:18818:                  [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:18885:                  [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:18952:                  [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:19113:                  [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:19180:                  [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:19247:                  [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:19314:                  [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:19479:                    [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:19546:                    [0mGHIN Lookup[0m
./.code/agents/1837/exec-call_gr8KZervnORc9VEnJE7nw8fw.txt:19613:                    [0mGHIN Lookup[0m
[2025-10-20T16:08:20] grep -R "GHIN" -n completed in background

[2025-10-20T16:08:33] thinking

**Checking for logging guard references**
[2025-10-20T16:08:34] exec bash -lc 'grep -R "loggingGuard" -n frontend/src' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:08:35] bash -lc 'grep -R "loggingGuard" -n frontend/src' exited 1 in 829ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status

ERROR
[2025-10-20T16:08:35] tokens used: 61,358

[2025-10-20T16:08:41] thinking

**Gathering info on sheets validation and logging guard**
[2025-10-20T16:08:41] exec bash -lc "nl -ba frontend/src/components/GHINIntegration.js | sed -n '1,200p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:08:42] bash -lc "nl -ba frontend/src/components/GHINIntegration.js | sed -n '1,200p'" succeeded in 772ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
     1	import React, { useState, useEffect } from 'react';
     2	import { useTheme } from '../theme/Provider';
     3	
     4	const API_URL = process.env.REACT_APP_API_URL || "";
     5	
     6	const GHINIntegration = () => {
     7	  const theme = useTheme();
     8	  const [players, setPlayers] = useState([]);
     9	  const [selectedPlayer, setSelectedPlayer] = useState('');
    10	  const [ghinId, setGhinId] = useState('');
    11	  const [loading, setLoading] = useState(false);
    12	  const [message, setMessage] = useState('');
    13	  const [messageType, setMessageType] = useState('');
    14	  const [ghinStatus, setGhinStatus] = useState(null);
    15	  const [leaderboard, setLeaderboard] = useState([]);
    16	
    17	  // Load initial data
[2025-10-20T16:08:42] tokens used: 82,374

[2025-10-20T16:08:45] thinking

**Searching for logger references**
[2025-10-20T16:08:46] exec bash -lc "find frontend/src -name '*logger*'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:08:47] bash -lc "find frontend/src -name '*logger*'" succeeded in 745ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
[2025-10-20T16:08:47] tokens used: 85,396

[2025-10-20T16:08:50] thinking

**Checking frontend services directory**
[2025-10-20T16:08:50] exec bash -lc 'ls frontend/src/services' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:08:51] bash -lc 'ls frontend/src/services' succeeded in 747ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
ghinService.js
[2025-10-20T16:08:51] tokens used: 85,605

[2025-10-20T16:08:55] thinking

**Searching for guard references in frontend/src**
[2025-10-20T16:08:55] exec bash -lc 'grep -Ri "logging" frontend/src' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:08:56] bash -lc 'grep -Ri "logging" frontend/src' exited 1 in 796ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status

ERROR
[2025-10-20T16:08:56] tokens used: 85,887

[2025-10-20T16:09:00] thinking

**Checking frontend logging setup**
[2025-10-20T16:09:01] exec bash -lc "nl -ba frontend/src/index.js | sed -n '1,200p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:09:02] bash -lc "nl -ba frontend/src/index.js | sed -n '1,200p'" succeeded in 947ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
     1	import React from "react";
     2	import ReactDOM from "react-dom/client";
     3	import App from "./App";
     4	import { BrowserRouter } from "react-router-dom";
     5	
     6	const root = ReactDOM.createRoot(document.getElementById("root"));
     7	root.render(
     8	  <React.StrictMode>
     9	    <BrowserRouter>
    10	      <App />
    11	    </BrowserRouter>
    12	  </React.StrictMode>
    13	); 
[2025-10-20T16:09:02] tokens used: 86,059

[2025-10-20T16:09:04] thinking

**Checking for frontend entry point**
[2025-10-20T16:09:05] exec bash -lc "nl -ba frontend/src/App.js | sed -n '1,200p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:09:06] bash -lc "nl -ba frontend/src/App.js | sed -n '1,200p'" succeeded in 913ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
     1	import React, { useState } from "react";
     2	import { Routes, Route, useNavigate, Navigate, useLocation } from "react-router-dom";
     3	import { useAuth0 } from "@auth0/auth0-react";
     4	import { UnifiedGameInterface } from "./components/game";
     5	import { SimulationMode, MonteCarloSimulation } from "./components/simulation";
     6	import FeedAnalyzer from "./components/simulation/FeedAnalyzer";
     7	import ShotRangeAnalyzer from "./components/ShotRangeAnalyzer";
     8	import ColdStartHandler from "./components/ColdStartHandler";
     9	import TutorialSystem from "./components/tutorial/TutorialSystem";
    10	import WGPAnalyticsDashboard from "./components/WGPAnalyticsDashboard";
    11	import SheetIntegrationDashboard from "./components/SheetIntegrationDashboard";
    12	import GoogleSheetsLiveSync from "./components/GoogleSheetsLiveSync";
    13	import Leaderboard from "./components/Leaderboard";
    14	import { ThemeProvider, useTheme } from "./theme/Provider";
    15	import { GameProvider, SheetSyncProvider } from "./context";
    16	import { MockAuthProvider } from "./context/MockAuthContext";
    17	import { AuthProvider } from "./context/AuthContext";
[2025-10-20T16:09:06] tokens used: 86,466

[2025-10-20T16:09:09] thinking

**Searching for logging guard TODO**
[2025-10-20T16:09:10] exec bash -lc 'grep -R "console" frontend/src -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:09:11] bash -lc 'grep -R "console" frontend/src -n' succeeded in 780ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
frontend/src/context/AuthContext.js:27:    console.debug('🔧 Auth0 Configuration:', {
frontend/src/context/AuthContext.js:58:    console.error('Auth0Provider initialization failed:', error);
frontend/src/context/SheetSyncContext.js:22:      console.error('extractSheetId: URL is not a string:', url, typeof url);
frontend/src/context/SheetSyncContext.js:36:    console.error('extractSheetId: No pattern matched for URL:', url);
frontend/src/context/SheetSyncContext.js:77:      console.debug('performLiveSync called with:', { manualSheetUrl, sheetUrl, currentSheetUrl });
frontend/src/context/SheetSyncContext.js:81:      console.error('No sheet URL available for sync');
frontend/src/context/SheetSyncContext.js:92:        console.error('Failed to parse Google Sheets URL:', currentSheetUrl);
frontend/src/context/SheetSyncContext.js:172:      console.error('Google Sheets sync error:', err);
frontend/src/context/__tests__/GameProvider.test.js:112:      // Mock console.error to avoid noise in tests
frontend/src/context/__tests__/GameProvider.test.js:113:      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
frontend/src/context/__tests__/GameProvider.test.js:119:      consoleSpy.mockRestore();
frontend/src/context/GameProvider.js:371:        console.warn('setShotProbabilities expected a plain object or null. Received:', resolvedProbabilities);
frontend/src/components/GHINIntegration.js:32:      console.error('Error loading players:', error);
frontend/src/components/GHINIntegration.js:44:      console.error('Error checking GHIN status:', error);
frontend/src/components/GHINIntegration.js:56:      console.error('Error loading enhanced leaderboard:', error);
frontend/src/components/PlayerProfileManager.js:50:            console.error('Error loading profiles:', err);
frontend/src/components/PlayerProfileManager.js:82:            console.error('Error creating profile:', err);
[2025-10-20T16:09:11] tokens used: 89,429

[2025-10-20T16:09:15] thinking

**Searching for logging guard TODOs**
[2025-10-20T16:09:16] exec bash -lc "nl -ba frontend/src/context/AuthContext.js | sed -n '1,200p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:09:17] bash -lc "nl -ba frontend/src/context/AuthContext.js | sed -n '1,200p'" succeeded in 865ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
     1	import React, { createContext, useContext } from 'react';
     2	import { Auth0Provider } from '@auth0/auth0-react';
     3	
     4	// Auth0 integration for Wolf Goat Pig authentication
     5	const AuthContext = createContext();
     6	
     7	export const useAuth = () => {
     8	  const context = useContext(AuthContext);
     9	  if (!context) {
    10	    throw new Error('useAuth must be used within an AuthProvider');
    11	  }
    12	  return context;
    13	};
    14	
    15	export const AuthProvider = ({ children }) => {
    16	  // Support both React and Vite environment variable formats
    17	  const domain = process.env.REACT_APP_AUTH0_DOMAIN || process.env.VITE_AUTH0_DOMAIN;
[2025-10-20T16:09:17] tokens used: 93,240

[2025-10-20T16:09:22] thinking

**Searching for logging guard TODOs**
[2025-10-20T16:09:23] exec bash -lc 'grep -R "logging guard" reports -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:09:24] bash -lc 'grep -R "logging guard" reports -n' exited 1 in 1.10s:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status

ERROR
[2025-10-20T16:09:24] tokens used: 94,498

[2025-10-20T16:09:30] thinking

**Searching for logging documentation**
[2025-10-20T16:09:31] exec bash -lc 'grep -Ri "logging guard" docs' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:09:32] bash -lc 'grep -Ri "logging guard" docs' exited 1 in 792ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status

ERROR
[2025-10-20T16:09:32] tokens used: 94,777

[2025-10-20T16:09:37] thinking

**Searching for logging TODO comments**
[2025-10-20T16:09:38] exec bash -lc "nl -ba frontend/src/components/simulation/SimulationMode.js | sed -n '820,920p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:09:39] bash -lc "nl -ba frontend/src/components/simulation/SimulationMode.js | sed -n '820,920p'" succeeded in 751ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
   820	        errorMessage += "Network error - check your connection";
   821	      } else {
   822	        errorMessage += error.message;
   823	      }
   824	      
   825	      addFeedback(`❌ ${errorMessage}`);
   826	    } finally {
   827	      setLoading(false);
   828	    }
   829	  };
   830	  
   831	  const resetSimulation = () => {
   832	    setGameState(null);
   833	    endGame();  // Use endGame directly instead of setIsGameActive
   834	    clearFeedback();
   835	    setHoleDecisions({
   836	      action: null,
[2025-10-20T16:09:39] tokens used: 95,022

[2025-10-20T16:09:51] thinking

**Searching TODO comments**
[2025-10-20T16:09:52] exec bash -lc 'grep -R "TODO" frontend/src --exclude-dir=node_modules -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:09:53] bash -lc 'grep -R "TODO" frontend/src --exclude-dir=node_modules -n' succeeded in 1.02s:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
frontend/src/components/simulation/SimulationMode.js:886:  const useEnhancedLayout = true; // TODO: Make this a user preference
[2025-10-20T16:09:53] tokens used: 96,546

[2025-10-20T16:09:57] thinking

**Checking for TODO mentions in logs**
[2025-10-20T16:09:58] exec bash -lc 'head -n 40 reports/frontend_dev.log' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:09:59] bash -lc 'head -n 40 reports/frontend_dev.log' succeeded in 851ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status

> wgp-frontend@0.1.1 start
> react-scripts start

(node:29425) [DEP_WEBPACK_DEV_SERVER_ON_AFTER_SETUP_MIDDLEWARE] DeprecationWarning: 'onAfterSetupMiddleware' option is deprecated. Please use the 'setupMiddlewares' option.
(Use `node --trace-deprecation ...` to show where the warning was created)
(node:29425) [DEP_WEBPACK_DEV_SERVER_ON_BEFORE_SETUP_MIDDLEWARE] DeprecationWarning: 'onBeforeSetupMiddleware' option is deprecated. Please use the 'setupMiddlewares' option.
Starting the development server...

Compiled successfully!

You can now view wgp-frontend in the browser.

  Local:            http://localhost:3001
  On Your Network:  http://192.168.1.44:3001

Note that the development build is not optimized.
[2025-10-20T16:09:59] tokens used: 96,881

[2025-10-20T16:10:01] thinking

**Considering log file location**
[2025-10-20T16:10:02] exec bash -lc 'head -n 40 reports/backend_dev.log' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:10:03] bash -lc 'head -n 40 reports/backend_dev.log' succeeded in 741ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
INFO:     Will watch for changes in these directories: ['/Users/stuartgano/Documents/wolf-goat-pig/backend']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [93231] using WatchFiles
WARNING:app.services.email_service:Email service is not fully configured. Check environment variables: SMTP_USER, SMTP_PASSWORD, SMTP_HOST
WARNING:app.main:Frontend static assets not found. Expected /Users/stuartgano/Documents/wolf-goat-pig/frontend/build/static
INFO:     Started server process [93233]
INFO:     Waiting for application startup.
INFO:app.main:🐺 Wolf Goat Pig API starting up...
INFO:app.main:ENVIRONMENT: None
INFO:app.database:Database initialized successfully
INFO:app.database:Database connection test successful
INFO:app.main:Database initialized successfully
INFO:app.main:game_state table verified
INFO:app.main:📧 Email scheduler will be initialized on-demand
INFO:app.main:🔍 Checking existing data status...
INFO:app.seed_data:Checking seeding status...
INFO:app.main:✅ All required data already present, skipping seeding
[2025-10-20T16:10:03] tokens used: 98,247

[2025-10-20T16:10:06] thinking

**Checking frontend utils for logging guard**
[2025-10-20T16:10:07] exec bash -lc "nl -ba frontend/src/utils/api.js | sed -n '1,200p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:10:08] bash -lc "nl -ba frontend/src/utils/api.js | sed -n '1,200p'" succeeded in 839ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
     1	/**
     2	 * API Utility with Cold Start Handling
     3	 * Handles Render's free tier cold start delays gracefully
     4	 */
     5	
     6	import { useState } from 'react';
     7	
     8	const API_URL = process.env.REACT_APP_API_URL || "";
     9	
    10	class ApiError extends Error {
    11	  constructor(message, status, isColdStart = false) {
    12	    super(message);
    13	    this.name = 'ApiError';
    14	    this.status = status;
    15	    this.isColdStart = isColdStart;
    16	  }
    17	}
[2025-10-20T16:10:08] tokens used: 99,616

[2025-10-20T16:10:10] thinking

**Checking for TODO comments in ghinService.js**
[2025-10-20T16:10:11] exec bash -lc 'grep -n "TODO" frontend/src/services/ghinService.js' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:10:12] bash -lc 'grep -n "TODO" frontend/src/services/ghinService.js' exited 1 in 720ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status

ERROR
[2025-10-20T16:10:12] tokens used: 102,028

[2025-10-20T16:10:20] thinking

**Searching for logging guard TODOs**
[2025-10-20T16:10:21] exec bash -lc "find . -maxdepth 2 -name '*TODO*'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:10:22] bash -lc "find . -maxdepth 2 -name '*TODO*'" succeeded in 724ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
./docs/TODO.md
./.history/TODO_20250724084043.md
./.history/REFACTORING_TODO_20250725181724.md
./.history/REFACTORING_TODO_20250725065651.md
./.history/REFACTORING_TODO_20250725065952.md
./.history/REFACTORING_TODO_20250724224838.md
./.history/REFACTORING_TODO_20250725181714.md
./.history/REFACTORING_TODO_20250724224849.md
./.history/REFACTORING_TODO_20250724161403.md
./.history/REFACTORING_TODO_20250725065943.md
./.history/REFACTORING_TODO_20250724222926.md
./.history/REFACTORING_TODO_20250724162329.md
./.history/REFACTORING_TODO_20250724164611.md
./.history/REFACTORING_TODO_20250724162402.md
./.history/REFACTORING_TODO_20250724180532.md
./.history/REFACTORING_TODO_20250724171814.md
./.history/TODO_20250724084038.md
[2025-10-20T16:10:22] tokens used: 102,535

[2025-10-20T16:10:24] thinking

**Checking TODO documentation**
[2025-10-20T16:10:25] exec bash -lc "sed -n '1,200p' docs/TODO.md" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:10:26] bash -lc "sed -n '1,200p' docs/TODO.md" succeeded in 762ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
# Wolf Goat Pig Golf Simulation - TODO List (BMad Method)

This TODO list is structured based on the BMad Method, organized by epics and user stories.

---

## ✅ In Progress / Ready for Development

### Epic: Technical Debt & Code Quality
- **[WGP-001]** [Story-001](stories/story-001-fix-typescript-errors.md): Resolve TypeScript and ESLint errors in frontend components.

### Epic: Enhanced Gameplay Features
- **[WGP-002]** [Story-002](stories/story-002-shot-range-integration.md): Complete integration of ShotRangeAnalyzer with game flow.
- **[WGP-003]** [Story-003](stories/story-003-betting-odds-calculations.md): Implement real-time betting odds calculations and display.

### Epic: Player Management & Analytics
- **[WGP-004]** [Story-004](stories/story-004-player-profiles.md): Add player profile persistence and statistics tracking.
[2025-10-20T16:10:26] tokens used: 103,256

[2025-10-20T16:10:37] thinking

**Reviewing test endpoint flag and helpers**
[2025-10-20T16:10:38] exec bash -lc "nl -ba backend/app/main.py | sed -n '100,220p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:10:39] bash -lc "nl -ba backend/app/main.py | sed -n '100,220p'" succeeded in 1.19s:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
   100	    carry_over: Optional[bool] = None
   101	    float_invoked: Optional[bool] = None
   102	    option_invoked: Optional[bool] = None
   103	    duncan_invoked: Optional[bool] = None
   104	    tunkarri_invoked: Optional[bool] = None
   105	    big_dick_invoked: Optional[bool] = None
   106	    joes_special_value: Optional[int] = None
   107	    line_of_scrimmage: Optional[str] = None
   108	    ping_pong_count: Optional[int] = Field(None, ge=0)
   109	
   110	
   111	class SimulationSeedRequest(BaseModel):
   112	    """Parameters accepted by the test seeding endpoint."""
   113	
   114	    current_hole: Optional[int] = Field(
   115	        None, description="Hole number to switch the active simulation to"
   116	    )
[2025-10-20T16:10:39] tokens used: 104,975

[2025-10-20T16:10:44] thinking

**Investigating test endpoint removal**
[2025-10-20T16:10:46] exec bash -lc 'grep -n "/simulation/test" backend/app/main.py' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:10:47] bash -lc 'grep -n "/simulation/test" backend/app/main.py' succeeded in 858ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
4606:    @app.post("/simulation/test/seed-state")
[2025-10-20T16:10:47] tokens used: 107,055

[2025-10-20T16:10:50] thinking

**Checking for additional routes**
[2025-10-20T16:10:51] exec bash -lc "nl -ba backend/app/main.py | sed -n '4600,4780p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:10:52] bash -lc "nl -ba backend/app/main.py | sed -n '4600,4780p'" succeeded in 758ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
  4600	        logger.error(f"Hole simulation failed: {e}")
  4601	        raise HTTPException(status_code=500, detail=f"Failed to simulate hole: {str(e)}")
  4602	
  4603	
  4604	if ENABLE_TEST_ENDPOINTS:
  4605	
  4606	    @app.post("/simulation/test/seed-state")
  4607	    def seed_simulation_state(payload: SimulationSeedRequest):
  4608	        """Testing-only helper for seeding the current simulation state.
  4609	
  4610	        Allows BDD and backend tests to manipulate the in-memory simulation using
  4611	        the public HTTP API instead of reaching into the global simulation object.
  4612	        """
  4613	
  4614	        global wgp_simulation
  4615	
  4616	        if not wgp_simulation:
[2025-10-20T16:10:52] tokens used: 108,039

[2025-10-20T16:11:05] thinking

**Verifying endpoint indentation and flag impact**
[2025-10-20T16:11:06] exec bash -lc 'grep -R "seed-state" tests/backend -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:11:07] bash -lc 'grep -R "seed-state" tests/backend -n' succeeded in 812ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
tests/backend/test_simulation_state_endpoint.py:46:    response = client.post("/simulation/test/seed-state", json=payload)
tests/backend/test_simulation_state_endpoint.py:126:    resp = client.post("/simulation/test/seed-state", json=seed_payload)
tests/backend/test_simulation_state_endpoint.py:328:    response = client.post("/simulation/test/seed-state", json=seed_payload)
tests/backend/test_simulation_state_endpoint.py:350:        response = client.post("/simulation/test/seed-state", json=seed_payload)
tests/backend/test_simulation_state_endpoint.py:364:    response = client.post("/simulation/test/seed-state", json=seed_payload)
tests/backend/test_simulation_state_endpoint.py:375:    response = client.post("/simulation/test/seed-state", json=seed_payload)
tests/backend/test_simulation_state_endpoint.py:386:    response = client.post("/simulation/test/seed-state", json=seed_payload)
tests/backend/test_simulation_state_endpoint.py:397:    response = client.post("/simulation/test/seed-state", json=seed_payload)
tests/backend/test_simulation_state_endpoint.py:410:    response = client.post("/simulation/test/seed-state", json=seed_payload)
tests/backend/test_simulation_state_endpoint.py:638:    response = client.post("/simulation/test/seed-state", json=seed_payload)
Binary file tests/backend/__pycache__/test_simulation_state_endpoint.cpython-313-pytest-8.4.1.pyc matches
Binary file tests/backend/__pycache__/test_simulation_state_endpoint.cpython-313-pytest-8.4.2.pyc matches
[2025-10-20T16:11:07] tokens used: 111,621

[2025-10-20T16:11:11] thinking

**Reviewing test file impact**
[2025-10-20T16:11:12] exec bash -lc "nl -ba tests/backend/test_simulation_state_endpoint.py | sed -n '40,120p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:11:13] bash -lc "nl -ba tests/backend/test_simulation_state_endpoint.py | sed -n '40,120p'" succeeded in 931ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
    40	    yield
    41	
    42	
    43	def _seed_state(payload: dict) -> dict:
    44	    """Helper to post to the seed endpoint and return the resulting game state."""
    45	
    46	    response = client.post("/simulation/test/seed-state", json=payload)
    47	    assert response.status_code == 200, response.text
    48	    return response.json()["game_state"]
    49	
    50	
    51	def _get_state() -> dict:
    52	    """Helper to fetch the current simulation state."""
    53	
    54	    response = client.get("/simulation/state")
    55	    assert response.status_code == 200
    56	    return response.json()
[2025-10-20T16:11:13] tokens used: 112,232

[2025-10-20T16:11:22] thinking

**Examining test dependencies and seeding behavior**
[2025-10-20T16:11:22] exec bash -lc "nl -ba backend/app/main.py | sed -n '6120,6205p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:11:23] bash -lc "nl -ba backend/app/main.py | sed -n '6120,6205p'" succeeded in 733ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
  6120	            raise HTTPException(
  6121	                status_code=400,
  6122	                detail=f"Not enough players signed up for {date}. Need at least 4 players, found {len(signups)}"
  6123	            )
  6124	        
  6125	        # Convert signups to player dictionaries
  6126	        players = _build_player_payload(signups)
  6127	        
  6128	        # Generate team rotations
  6129	        rotations = TeamFormationService.create_team_pairings_with_rotations(
  6130	            players=players,
  6131	            num_rotations=num_rotations,
  6132	            seed=seed
  6133	        )
  6134	        
  6135	        logger.info(f"Generated {len(rotations)} team rotations for date {date}")
  6136	        
[2025-10-20T16:11:23] tokens used: 113,613

[2025-10-20T16:11:28] thinking

**Confirming GHIN secrets requirements**
[2025-10-20T16:11:30] exec bash -lc "nl -ba scripts/development/deployment_test.py | sed -n '60,100p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:11:30] bash -lc "nl -ba scripts/development/deployment_test.py | sed -n '60,100p'" succeeded in 772ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
    60	    
    61	    # Check if we're in the right place
    62	    if not os.path.exists("app/main.py"):
    63	        print("❌ app/main.py not found - wrong directory?")
    64	        return False
    65	    
    66	    print("✅ app/main.py found")
    67	    
    68	    # Check environment variables
    69	    ghin_user = os.environ.get("GHIN_API_USER")
    70	    ghin_pass = os.environ.get("GHIN_API_PASS")
    71	    
    72	    print(f"✅ GHIN_API_USER: {'SET' if ghin_user else 'MISSING'}")
    73	    print(f"✅ GHIN_API_PASS: {'SET' if ghin_pass else 'MISSING'}")
    74	    
    75	    return True
    76	
[2025-10-20T16:11:30] tokens used: 115,212

[2025-10-20T16:11:36] thinking

**Verifying environment variables and test coverage**
[2025-10-20T16:11:37] exec bash -lc 'grep -R "SheetIntegration" tests/backend -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:11:38] bash -lc 'grep -R "SheetIntegration" tests/backend -n' exited 1 in 808ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status

ERROR
[2025-10-20T16:11:38] tokens used: 116,085

[2025-10-20T16:11:42] thinking

**Checking for test coverage gaps**
[2025-10-20T16:11:43] exec bash -lc "nl -ba scripts/diagnostics/test_sync_endpoints.py | sed -n '1,200p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:11:44] bash -lc "nl -ba scripts/diagnostics/test_sync_endpoints.py | sed -n '1,200p'" succeeded in 728ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
     1	#!/usr/bin/env python3
     2	"""
     3	Simple test script to verify sync endpoints are working correctly.
     4	"""
     5	import asyncio
     6	import httpx
     7	import json
     8	
     9	# Test the endpoints with a mock CSV URL
    10	TEST_CSV_URL = "https://docs.google.com/spreadsheets/d/1PWhi5rJ4ZGhTwySZh-D_9lo_GKJcHb1Q5MEkNasHLgM/export?format=csv&gid=0"
    11	API_BASE_URL = "http://localhost:8000"
    12	
    13	async def test_fetch_google_sheet():
    14	    """Test the fetch-google-sheet endpoint"""
    15	    print("Testing fetch-google-sheet endpoint...")
    16	    
    17	    async with httpx.AsyncClient() as client:
[2025-10-20T16:11:44] tokens used: 116,421

[2025-10-20T16:11:50] thinking

**Examining validation and logging gaps**
[2025-10-20T16:11:51] exec bash -lc 'grep -R "logging guard" .history -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:11:53] bash -lc 'grep -R "logging guard" .history -n' exited 1 in 2.16s:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status

ERROR
[2025-10-20T16:11:53] tokens used: 118,670

[2025-10-20T16:11:57] thinking

**Investigating frontend logging guards**
[2025-10-20T16:11:58] exec bash -lc "nl -ba frontend/src/context/SheetSyncContext.js | sed -n '1,220p'" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:11:59] bash -lc "nl -ba frontend/src/context/SheetSyncContext.js | sed -n '1,220p'" succeeded in 755ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
     1	import React, { createContext, useState, useEffect, useCallback, useContext } from 'react';
     2	
     3	const SheetSyncContext = createContext();
     4	
     5	export const useSheetSync = () => {
     6	  return useContext(SheetSyncContext);
     7	};
     8	
     9	export const SheetSyncProvider = ({ children }) => {
    10	  // Hardcode the Wolf-Goat-Pig Google Sheets URL
    11	  const [sheetUrl, setSheetUrl] = useState('https://docs.google.com/spreadsheets/d/1PWhi5rJ4ZGhTwySZh-D_9lo_GKJcHb1Q5MEkNasHLgM/edit?pli=1&gid=0#gid=0');
    12	  const [syncStatus, setSyncStatus] = useState('idle'); // idle, connecting, syncing, error, success
    13	  const [lastSync, setLastSync] = useState(null);
    14	  const [syncInterval, setSyncInterval] = useState(30); // seconds
    15	  const [autoSync, setAutoSync] = useState(true); // Enable auto sync by default
    16	  const [syncData, setSyncData] = useState([]);
    17	  const [error, setError] = useState(null);
[2025-10-20T16:11:59] tokens used: 118,983

[2025-10-20T16:12:06] thinking

**Checking for frontend logging guards**
[2025-10-20T16:12:07] exec bash -lc 'grep -Ri "logging" docs' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:12:07] bash -lc 'grep -Ri "logging" docs' succeeded in 815ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
docs/prd.md:- Event logging for all player actions
docs/prd.md:- ✅ Monitoring and logging
docs/architecture.md:- **Timeline Tracker**: Chronological event logging with rich context
docs/architecture.md:- **Error Tracking**: Comprehensive logging and alerting
docs/architecture.md:- **Log Aggregation**: Structured logging with retention
docs/architecture.md:### Logging and Debugging
docs/architecture.md:#### Structured Logging
docs/architecture.md:- **Exception Logging**: Full stack traces with context
docs/architecture.md:- **Audit Trail**: Complete game action logging
docs/archive/agent-guides/claude-guidelines.md:- Always add appropriate error handling and logging
docs/archive/agent-guides/crush.md:- Business logic in services; error handling and logging always.
docs/archive/bmad-core/tasks/nfr-assess.md:  - Logging
docs/archive/bmad-core/tasks/document-project.md:- **Debug Mode**: Set `DEBUG=app:*` for verbose logging
docs/archive/bmad-core/tasks/correct-course.md:  - **If the approved edits sufficiently address the change and can be implemented directly or organized by a PO/SM:** State that the "Correct Course Task" is complete regarding analysis and change proposal, and the user can now proceed with implementing or logging these changes (e.g., updating actual project documents, backlog items). Suggest handoff to a PO/SM agent for backlog organization if appropriate.
docs/archive/bmad-core/checklists/architect-checklist.md:- [ ] Cross-cutting concerns (logging, auth, etc.) are properly addressed
docs/archive/bmad-core/checklists/architect-checklist.md:- [ ] Logging strategy is defined
docs/archive/bmad-core/templates/architecture-tmpl.yaml:      2. Define logging standards and tools
[2025-10-20T16:12:07] tokens used: 122,665

[2025-10-20T16:12:12] thinking

**Searching for logging guard in agents folder**
[2025-10-20T16:12:13] exec bash -lc 'grep -R "logging guard" .code/agents -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:12:15] bash -lc 'grep -R "logging guard" .code/agents -n' exited 1 in 1.51s:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status

ERROR
[2025-10-20T16:12:15] tokens used: 123,737

[2025-10-20T16:12:22] thinking

**Investigating TODOs for frontend logging guards**
[2025-10-20T16:12:23] exec bash -lc 'grep -Ri "guard" docs -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:12:24] bash -lc 'grep -Ri "guard" docs -n' succeeded in 829ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
docs/archive/bmad-core/agents/po.md:44:    - Guardian of Quality & Completeness - Ensure all artifacts are comprehensive and consistent
docs/archive/bmad-core/templates/fullstack-architecture-tmpl.yaml:497:            title: Middleware/Guards
docs/archive/bmad-core/templates/front-end-architecture-tmpl.yaml:160:        instruction: Provide routing configuration appropriate for the chosen framework. Include protected route patterns, lazy loading where applicable, and authentication guards/middleware.
docs/archive/bmad-core/data/test-levels-framework.md:118:## Duplicate Coverage Guard
[2025-10-20T16:12:24] tokens used: 124,099

[2025-10-20T16:12:34] thinking

**Searching for logging-related TODOs**
[2025-10-20T16:12:34] exec bash -lc 'grep -R "TODO" -n | head' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:12:35] bash -lc 'grep -R "TODO" -n | head' succeeded in 939ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
./.code/agents/a3d53bee-3b33-4267-bc35-c10f9c88ae31/result.txt:27:- TODO at line 12: "Make enhanced layout a user preference"
./.code/agents/8df086aa-eba9-4bb3-bc27-01e33a732c5f/result.txt:48:- No TODO/FIXME/BUG comments in production code
./.code/agents/8686/exec-call_XoxG4oyhZyliLxun4Q9epDVL.txt:17:Agent: Map backend product modes: Simulation, Signup/Matchmaking, Sunday Game, GHIN/Sheets sync, Analytics, Legacy Signup. For each, list main FastAPI/CLI entry points, services, and database seeds. Identify corresponding pytest suites or scripts. Note any TODOs, feature flags (like ENABLE_TEST_ENDPOINTS), or risks referenced in code/docs.
./.code/agents/8686/exec-call_XoxG4oyhZyliLxun4Q9epDVL.txt:37:Agent: Map backend product modes: Simulation, Signup/Matchmaking, Sunday Game, GHIN/Sheets sync, Analytics, Legacy Signup. For each, list main FastAPI/CLI entry points, services, and database seeds. Identify corresponding pytest suites or scripts. Note any TODOs, feature flags (like ENABLE_TEST_ENDPOINTS), or risks referenced in code/docs.
./.code/agents/8686/exec-call_XoxG4oyhZyliLxun4Q9epDVL.txt:63:[2025-10-20T15:13:38] tool sequential-thinking.sequentialthinking({"thought":"Outline plan: 1) list directories (backend/app...). 2) search docs for modes. 3) For each mode, identify entrypoints: FastAPI routers, CLI scripts. 4) find seeds. 5) tests referencing these modes. 6) collect flags/TODOs/risks. Will adjust as needed.","nextThoughtNeeded":true,"thoughtNumber":2,"totalThoughts":6,"isRevision":false,"revisesThought":0,"branchId":"","branchFromThought":0,"needsMoreThoughts":false})
./.code/agents/8686/exec-call_XoxG4oyhZyliLxun4Q9epDVL.txt:64:[2025-10-20T15:13:38] sequential-thinking.sequentialthinking({"thought":"Outline plan: 1) list directories (backend/app...). 2) search docs for modes. 3) For each mode, identify entrypoints: FastAPI routers, CLI scripts. 4) find seeds. 5) tests referencing these modes. 6) collect flags/TODOs/risks. Will adjust as needed.","nextThoughtNeeded":true,"thoughtNumber":2,"totalThoughts":6,"isRevision":false,"revisesThought":0,"branchId":"","branchFromThought":0,"needsMoreThoughts":false}) success in 0ms:
./.code/agents/8686/exec-call_XoxG4oyhZyliLxun4Q9epDVL.txt:136:{"output":"🎯 ADK auto-sync aliases loaded!\n💡 Use 'sync' to sync with upstream anytime\n💡 Use 'synccheck' to check sync status\ndocs/prd.md:# Wolf Goat Pig Golf Simulation - Product Requirements Document (PRD)\ndocs/prd.md:Wolf Goat Pig Golf Simulation is a comprehensive digital implementation of the classic golf betting game from Wing Point Golf & Country Club. The product transforms the complex, paper-based golf betting experience into an interactive, real-time simulation that combines authentic golf physics, strategic betting mechanics, and educational gameplay analysis.\ndocs/prd.md:- **Shot Simulation**: <50ms per shot calculation\ndocs/prd.md:### Epic 2: Enhanced Simulation Features\ndocs/architecture.md:- **Project**: BMad - Wolf Goat Pig Golf Simulation\ndocs/architecture.md:│ - State Mgmt    │    │ - Simulation    │    │ - Course Data   │\ndocs/architecture.md:- **Simulation Engine**: Monte Carlo analysis with realistic golf physics\ndocs/architecture.md:- **Simulation Results**: Statistical analysis and result caching\ndocs/architecture.md:│   │   ├── MonteCarloSimulation.js # Simulation interface\ndocs/architecture.md:│   │   ├── SimulationMode.js       # Simulation controls\ndocs/architecture.md:│   │   └── GameSetup.js           # Simulation setup\ndocs/architecture.md:│   └── useSimulationApi.js        # Simulation API integration\ndocs/architecture.md:- Simulation Tests: Monte Carlo validation\ndocs/architecture.md:Feature: Monte Carlo Simulation\ndocs/architecture.md:- **Shot Simulation**: <50ms per shot calculation\ndocs/requirements.txt:# Wolf Goat Pig Golf Simulation - Production Dependencies\ndocs/archive/agent-guides/crush.md:### Interactive Simulation Flow (CRITICAL)\ndocs/WOLF_GOAT_PIG_README.md:# 🐺🐐🐷 Wolf Goat Pig Golf Game Simulation\ndocs/WOLF_GOAT_PIG_README.md:- **`WolfGoatPigSimulation`**: Main game engine\ndocs/TODO.md:# Wolf Goat Pig Golf Simulation - TODO List (BMad Method)\ndocs/TODO.md:### Epic: AI & Simulation Enhancements\ndocs/product/gameplay-user-journey.md:**User Action:** Navigate to Simulation Mode\ndocs/product/gameplay-user-journey.md:- Click \"Start Simulation\"\ndocs/product/integration-summary.md:# Wolf-Goat-Pig Simulation Mode - Complete Integration Summary\ndocs/product/integration-summary.md:- ✅ **EnhancedSimulationLayout** - New layout combining timeline and poker betting\ndocs/product/integration-summary.md:### **Simulation Setup**\ndocs/product/integration-summary.md:- `SimulationMode.js` - Added timeline and poker state management\ndocs/product/integration-summary.md:- `EnhancedSimulationLayout.js` - New layout integrating all components\ndocs/README.md:- [Simulation fixes](./guides/simulation-fixes.md) - Simulation component fixes\ndocs/stories/story-006-simulation-mode.md:- SimulationMode.js - Turn-based game orchestrator\ndocs/architecture/source-tree.md:- `test_simulation_components.py` - Simulation testing\ndocs/architecture/source-tree.md:- `simulation/` - Simulation components\ndocs/architecture/source-tree.md:  - `SimulationMode.js` - Simulation interface\ndocs/architecture/source-tree.md:  - `MonteCarloSimulation.js` - Monte Carlo engine\ndocs/architecture/source-tree.md:- `useSimulationApi.js` - Simulation API\ndocs/architecture/source-tree.md:├── test_simulation.py        # Simulation tests\ndocs/project-brief.md:- ✅ **Monte Carlo Simulation**: Advanced statistical analysis engine\ndocs/guides/production-setup.md:| **Core Game Logic** | ✅ 95% | Simulation working, all rules implemented |\ndocs/guides/local-development.md:## Testing the Simulation Flow\ndocs/guides/local-development.md:2. Click \"Start Simulation\" or navigate to simulation mode\ndocs/guides/local-development.md:- **Simulation Logic**: `backend/app/wolf_goat_pig_simulation.py`\ndocs/guides/browser-testing.md:# 🧪 Browser Testing Guide for Wolf-Goat-Pig Simulation\ndocs/guides/browser-testing.md:### 3. Test the Simulation Flow\ndocs/guides/browser-testing.md:#### Step 1: Navigate to Simulation Mode\ndocs/guides/browser-testing.md:- Click on \"Start Simulation\" or navigate to the simulation section\ndocs/guides/browser-testing.md:4. Click \"Start Simulation\"\ndocs/guides/browser-testing.md:- Game header showing \"Simulation - Hole 1\"\ndocs/guides/browser-testing.md:| Setup Simulation | ✅ Fixed |\ndocs/guides/simulation-fixes.md:# Wolf Goat Pig Simulation Startup Fixes\ndocs/guides/simulation-fixes.md:- Simulation creation\ndocs/ENHANCED_WGP_FEATURES.md:## 🏌️ Shot Simulation Features\ndocs/SYSTEM_DEMONSTRATION_RESULTS.md:## 🎲 Monte Carlo Simulation Successfully Running!\ndocs/SYSTEM_DEMONSTRATION_RESULTS.md:- ✅ Simulation parameter controls\ndocs/SYSTEM_DEMONSTRATION_RESULTS.md:1. ✅ **Realistic Golf Simulation**: Authentic handicap-based scoring and outcomes\ndocs/DEPLOYMENT_CHECKLIST.md:- `GET /simulation/run` - Simulation endpoint\nbackend/smoke_tests.py:from app.wolf_goat_pig_simulation import WolfGoatPigSimulation, WGPPlayer\nbackend/smoke_tests.py:    sim = WolfGoatPigSimulation(player_count=4, players=players)\nbackend/smoke_tests.py:    print(\"   ✓ Simulation created with 4 players\")\nbackend/smoke_tests.py:    sim = WolfGoatPigSimulation(player_count=4, players=players)\nbackend/smoke_tests.py:    sim = WolfGoatPigSimulation(player_count=4, players=players)\nbackend/smoke_tests.py:    sim = WolfGoatPigSimulation(player_count=4, players=players)\nbackend/smoke_tests.py:    sim = WolfGoatPigSimulation(player_count=4, players=players)\nbackend/smoke_tests.py:    sim = WolfGoatPigSimulation(player_count=4, players=players)\nbackend/smoke_tests.py:    sim = WolfGoatPigSimulation(player_count=4, players=players)\nbackend/smoke_tests.py:    runner.run_test(\"Basic Simulation Creation\", test_basic_simulation_creation)\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/securitycenter.v1.json:\"$ref\": \"Simulation\"\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/securitycenter.v1.json:\"Simulation\": {\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/securitycenter.v1.json:\"id\": \"Simulation\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/securitycenter.v1.json:\"description\": \"Full resource name of the Simulation: `organizations/123/simulations/456`\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/orgpolicy.v2.json:\"supportsSimulation\": {\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1.json:\"accessPolicySimulations\": {\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1.json:\"flatPath\": \"v1/folders/{foldersId}/locations/{locationsId}/accessPolicySimulations/{accessPolicySimulationsId}/operations/{operationsId}\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1.json:\"id\": \"policysimulator.folders.locations.accessPolicySimulations.operations.get\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1.json:\"pattern\": \"^folders/[^/]+/locations/[^/]+/accessPolicySimulations/[^/]+/operations/.*$\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1.json:\"accessPolicySimulations\": {\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1.json:\"flatPath\": \"v1/organizations/{organizationsId}/locations/{locationsId}/accessPolicySimulations/{accessPolicySimulationsId}/operations/{operationsId}\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1.json:\"id\": \"policysimulator.organizations.locations.accessPolicySimulations.operations.get\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1.json:\"pattern\": \"^organizations/[^/]+/locations/[^/]+/accessPolicySimulations/[^/]+/operations/.*$\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1.json:\"accessPolicySimulations\": {\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1.json:\"flatPath\": \"v1/projects/{projectsId}/locations/{locationsId}/accessPolicySimulations/{accessPolicySimulationsId}/operations/{operationsId}\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1.json:\"id\": \"policysimulator.projects.locations.accessPolicySimulations.operations.get\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1.json:\"pattern\": \"^projects/[^/]+/locations/[^/]+/accessPolicySimulations/[^/]+/operations/.*$\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1alpha.json:\"accessPolicySimulations\": {\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1alpha.json:\"flatPath\": \"v1alpha/folders/{foldersId}/locations/{locationsId}/accessPolicySimulations/{accessPolicySimulationsId}/operations/{operationsId}\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1alpha.json:\"id\": \"policysimulator.folders.locations.accessPolicySimulations.operations.get\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1alpha.json:\"pattern\": \"^folders/[^/]+/locations/[^/]+/accessPolicySimulations/[^/]+/operations/.*$\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1alpha.json:\"accessPolicySimulations\": {\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1alpha.json:\"flatPath\": \"v1alpha/organizations/{organizationsId}/locations/{locationsId}/accessPolicySimulations/{accessPolicySimulationsId}/operations/{operationsId}\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1alpha.json:\"id\": \"policysimulator.organizations.locations.accessPolicySimulations.operations.get\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1alpha.json:\"pattern\": \"^organizations/[^/]+/locations/[^/]+/accessPolicySimulations/[^/]+/operations/.*$\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1alpha.json:\"accessPolicySimulations\": {\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1alpha.json:\"flatPath\": \"v1alpha/projects/{projectsId}/locations/{locationsId}/accessPolicySimulations/{accessPolicySimulationsId}/operations/{operationsId}\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1alpha.json:\"id\": \"policysimulator.projects.locations.accessPolicySimulations.operations.get\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1alpha.json:\"pattern\": \"^projects/[^/]+/locations/[^/]+/accessPolicySimulations/[^/]+/operations/.*$\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1beta.json:\"accessPolicySimulations\": {\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1beta.json:\"flatPath\": \"v1beta/folders/{foldersId}/locations/{locationsId}/accessPolicySimulations/{accessPolicySimulationsId}/operations/{operationsId}\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1beta.json:\"id\": \"policysimulator.folders.locations.accessPolicySimulations.operations.get\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1beta.json:\"pattern\": \"^folders/[^/]+/locations/[^/]+/accessPolicySimulations/[^/]+/operations/.*$\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1beta.json:\"accessPolicySimulations\": {\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1beta.json:\"flatPath\": \"v1beta/organizations/{organizationsId}/locations/{locationsId}/accessPolicySimulations/{accessPolicySimulationsId}/operations/{operationsId}\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1beta.json:\"id\": \"policysimulator.organizations.locations.accessPolicySimulations.operations.get\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1beta.json:\"pattern\": \"^organizations/[^/]+/locations/[^/]+/accessPolicySimulations/[^/]+/operations/.*$\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1beta.json:\"accessPolicySimulations\": {\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1beta.json:\"flatPath\": \"v1beta/projects/{projectsId}/locations/{locationsId}/accessPolicySimulations/{accessPolicySimulationsId}/operations/{operationsId}\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1beta.json:\"id\": \"policysimulator.projects.locations.accessPolicySimulations.operations.get\",\nbackend/.venv-prod/lib/python3.13/site-packages/googleapiclient/discovery_cache/documents/policysimulator.v1beta.json:\"pattern\": \"^projects/[^/]+/locations/[^/]+/accessPolicySimulations/[^/]+/operations/.*$\",\nbackend/.venv-prod/lib/python3.13/site-packages/pygments/lexers/hdl.py:                # Simulation control tasks (20.2)\nbackend/.venv-prod/lib/python3.13/site-packages/pygments/lexers/hdl.py:                # Simulation time functions (20.3)\nbackend/.venv-prod/lib/python3.13/site-packages/pygments/lexers/_scilab_builtins.py:    'xcosSimulationStarted',\nBinary file backend/.venv-prod/lib/python3.13/site-packages/pygments/lexers/__pycache__/_scilab_builtins.cpython-313.pyc matches\nBinary file backend/.venv-prod/lib/python3.13/site-packages/numpy/random/_generator.cpython-313-darwin.so matches\nBinary file backend/.venv-prod/lib/python3.13/site-packages/numpy/random/mtrand.cpython-313-darwin.so matches\nbackend/backend.log:INFO:app.main:✅ Simulation initialization verified\nbackend/startup.py:        from app.wolf_goat_pig_simulation import WolfGoatPigSimulation\nbackend/startup.py:        # 3. Simulation engine\nbackend/startup.py:            test_sim = WolfGoatPigSimulation(player_count=4)\nbackend/startup.py:            logging.info(\"✅ Simulation engine health check passed\")\nbackend/startup.py:            logging.error(f\"❌ Simulation engine health check failed: {e}\")\nbackend/startup.py:            from app.wolf_goat_pig_simulation import WolfGoatPigSimulation\nbackend/startup.py:        # 3. Simulation engine check\nbackend/startup.py:            test_sim = WolfGoatPigSimulation(player_count=4)\nbackend/startup.py:            logger.info(\"✅ Simulation engine verified\")\nbackend/startup.py:            health_status[\"warnings\"].append(\"Simulation engine check failed\")\nbackend/startup.py:            logger.warning(f\"⚠️ Simulation engine check failed: {e}\")\nbackend/app/wolf_goat_pig_simulation.py:class WolfGoatPigSimulation:\nbackend/app/wolf_goat_pig_simulation.py:        new_sim = WolfGoatPigSimulation(player_count=len(wgp_players), players=wgp_players)\nbackend/app/models.py:class SimulationResult(Base):\nBinary file backend/app/__pycache__/main.cpython-313.pyc matches\nBinary file backend/app/__pycache__/schemas.cpython-313.pyc matches\nBinary file backend/app/__pycache__/schemas.cpython-312.pyc matches\nBinary file backend/app/__pycache__/main.cpython-312.pyc matches\nBinary file backend/app/__pycache__/wolf_goat_pig_simulation.cpython-312.pyc matches\nBinary file backend/app/__pycache__/wolf_goat_pig_simulation.cpython-313.pyc matches\nBinary file backend/app/__pycache__/models.cpython-312.pyc matches\n…truncated…\nBinary file backend/app/__pycache__/simulation.cpython-312.pyc matches\nbackend/app/schemas.py:class SimulationCourseData(BaseModel):\nbackend/app/schemas.py:# Game Setup and Simulation Schemas\nbackend/app/simulation_timeline_enhancements.py:class SimulationTimelineManager:\nbackend/app/simulation_timeline_enhancements.py:        simulation.timeline_manager = SimulationTimelineManager()\nbackend/app/main.py:from .wolf_goat_pig_simulation import WolfGoatPigSimulation, WGPPlayer, BallPosition, TeamFormation\nbackend/app/main.py:# Initialize Wolf Goat Pig Simulation (will be replaced when game starts)\nbackend/app/main.py:wgp_simulation = WolfGoatPigSimulation(player_count=4)\nbackend/app/main.py:class SimulationSeedRequest(BaseModel):\nbackend/app/main.py:    title=\"Wolf Goat Pig Golf Simulation API\",\nbackend/app/main.py:            test_simulation = WolfGoatPigSimulation(player_count=4)\nbackend/app/main.py:            logger.info(\"✅ Simulation initialization verified\")\nbackend/app/main.py:            logger.warning(f\"⚠️ Simulation test failed (non-critical): {e}\")\nbackend/app/main.py:        # 5. Simulation initialization test\nbackend/app/main.py:            test_simulation = WolfGoatPigSimulation(player_count=4)\nbackend/app/main.py:                \"message\": \"Simulation engine operational\"\nbackend/app/main.py:            logger.error(f\"Simulation initialization test failed: {e}\")\nbackend/app/main.py:                \"message\": f\"Simulation test failed: {str(e)}\"\nbackend/app/main.py:        from .services.monte_carlo import run_monte_carlo_simulation, SimulationParams\nbackend/app/main.py:            mc_params = SimulationParams()\nbackend/app/main.py:        total_simulations = db.query(models.SimulationResult).count()\nbackend/app/main.py:class SimulationSetupRequest(BaseModel):\nbackend/app/main.py:class SimulationPlayShotRequest(BaseModel):\nbackend/app/main.py:class SimulationPlayHoleRequest(BaseModel):\nbackend/app/main.py:        wgp_simulation = WolfGoatPigSimulation(\nbackend/app/main.py:        logger.info(\"Simulation setup completed successfully\")\nbackend/app/main.py:            \"message\": \"Simulation initialized successfully\",\nbackend/app/main.py:        logger.error(f\"Simulation setup failed: {e}\")\nbackend/app/main.py:def play_next_shot(request: SimulationPlayShotRequest = None):\nbackend/app/main.py:            raise HTTPException(status_code=400, detail=\"Simulation not initialized. Call /simulation/setup first.\")\nbackend/app/main.py:            raise HTTPException(status_code=400, detail=\"Simulation not initialized. Call /simulation/setup first.\")\nbackend/app/main.py:    def seed_simulation_state(payload: SimulationSeedRequest):\nbackend/app/main.py:            raise HTTPException(status_code=400, detail=\"Simulation not initialized. Call /simulation/setup first.\")\nbackend/app/main.py:        raise HTTPException(status_code=404, detail=\"Simulation not initialized\")\nbackend/app/main.py:            raise HTTPException(status_code=400, detail=\"Simulation not initialized\")\nbackend/app/main.py:            raise HTTPException(status_code=400, detail=\"Simulation not initialized\")\nbackend/app/main.py:            raise HTTPException(status_code=400, detail=\"Simulation not initialized\")\nbackend/app/main.py:            raise HTTPException(status_code=400, detail=\"Simulation not initialized\")\nbackend/app/main.py:            raise HTTPException(status_code=400, detail=\"Simulation not initialized\")\nbackend/app/main.py:            raise HTTPException(status_code=400, detail=\"Simulation not initialized\")\nbackend/app/services/monte_carlo.py:class SimulationParams:\nbackend/app/services/monte_carlo.py:class SimulationResult:\nbackend/app/services/monte_carlo.py:    def __init__(self, params: Optional[SimulationParams] = None):\nbackend/app/services/monte_carlo.py:        self.params = params or SimulationParams()\nbackend/app/services/monte_carlo.py:        params: Optional[SimulationParams] = None\nbackend/app/services/monte_carlo.py:    ) -> SimulationResult:\nbackend/app/services/monte_carlo.py:        params: SimulationParams,\nbackend/app/services/monte_carlo.py:    ) -> SimulationResult:\nbackend/app/services/monte_carlo.py:                    print(f\"Simulation batch failed: {e}\")\nbackend/app/services/monte_carlo.py:        params: SimulationParams,\nbackend/app/services/monte_carlo.py:    ) -> SimulationResult:\nbackend/app/services/monte_carlo.py:    ) -> SimulationResult:\nbackend/app/services/monte_carlo.py:            return SimulationResult(\nbackend/app/services/monte_carlo.py:        return SimulationResult(\nbackend/app/services/monte_carlo.py:) -> SimulationResult:\nbackend/app/services/monte_carlo.py:    params = SimulationParams(\nBinary file backend/app/services/__pycache__/monte_carlo.cpython-312.pyc matches\nBinary file backend/app/services/__pycache__/monte_carlo.cpython-313.pyc matches\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/simulation/test_simulation_scenarios.py::TestSimulationMode::test_aggressive_captain_solo\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/simulation/test_simulation_scenarios.py::TestSimulationMode::test_full_18_hole_game\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/simulation/test_simulation_scenarios.py::TestSimulationMode::test_karl_marx_rule\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/simulation/test_simulation_scenarios.py::TestSimulationMode::test_partnership_formation\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_integration.py::TestSimulationIntegration::test_play_next_shot_without_setup\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_integration.py::TestSimulationIntegration::test_simulation_error_handling\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_integration.py::TestSimulationIntegration::test_simulation_full_flow\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_integration.py::TestSimulationIntegration::test_simulation_legacy_format_compatibility\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_integration.py::TestSimulationIntegration::test_simulation_setup_invalid_players\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_integration.py::TestSimulationIntegration::test_simulation_setup_success\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestSimulationErrorHandling::test_invalid_partnership_request\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestSimulationErrorHandling::test_invalid_player_count\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestSimulationErrorHandling::test_missing_course\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestSimulationUtilities::test_handicap_calculation\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestSimulationUtilities::test_net_score_calculation\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestSimulationUtilities::test_team_formation_validation\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestWolfGoatPigSimulation::test_add_players\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestWolfGoatPigSimulation::test_captain_rotation\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestWolfGoatPigSimulation::test_game_state_serialization\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestWolfGoatPigSimulation::test_get_current_captain\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestWolfGoatPigSimulation::test_lie_type_determination_with_distance\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestWolfGoatPigSimulation::test_partnership_request\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestWolfGoatPigSimulation::test_partnership_response\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestWolfGoatPigSimulation::test_set_course\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestWolfGoatPigSimulation::test_short_game_progression\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestWolfGoatPigSimulation::test_shot_simulation\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestWolfGoatPigSimulation::test_simulation_initialization\",\nbackend/.pytest_cache/v/cache/nodeids:  \"tests/test_simulation_unit.py::TestWolfGoatPigSimulation::test_start_game\",\nbackend/.pytest_cache/v/cache/lastfailed:  \"tests/test_simulation_integration.py::TestSimulationIntegration::test_simulation_setup_invalid_players\": true,\nbackend/.pytest_cache/v/cache/lastfailed:  \"tests/test_simulation_integration.py::TestSimulationIntegration::test_play_next_shot_without_setup\": true,\nbackend/test_short_game.py:    from app.wolf_goat_pig_simulation import WolfGoatPigSimulation, WGPShotResult\nbackend/test_short_game.py:        sim = WolfGoatPigSimulation()\nbackend/test_progression.py:    from app.wolf_goat_pig_simulation import WolfGoatPigSimulation\nbackend/test_progression.py:        sim = WolfGoatPigSimulation()\nbackend/test_progression.py:        print(\"\\n🎯 Testing Hole Completion Simulation\")\nbackend/tests/test_models_schemas.py:    Rule, Course, Hole, GameStateModel, SimulationResult,\nbackend/tests/test_simulation_unit.py:    from app.wolf_goat_pig_simulation import WolfGoatPigSimulation\nbackend/tests/test_simulation_unit.py:class TestWolfGoatPigSimulation:\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:class TestSimulationUtilities:\nbackend/tests/test_simulation_unit.py:class TestSimulationErrorHandling:\nbackend/tests/test_simulation_unit.py:            WolfGoatPigSimulation(player_count=3)\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:        sim = WolfGoatPigSimulation()\nbackend/tests/test_simulation_unit.py:    print(\"🧪 Simulation Unit Tests\")\nbackend/tests/test_simulation_unit.py:        print(\"⚠️ Simulation components not available for testing\")\nbackend/tests/test_simulation_unit.py:        TestWolfGoatPigSimulation,\nbackend/tests/test_simulation_unit.py:        TestSimulationUtilities,\nbackend/tests/test_simulation_unit.py:        TestSimulationErrorHandling,\nbackend/tests/test_monte_carlo.py:    SimulationParams,\nbackend/tests/test_monte_carlo.py:    SimulationResult,\nbackend/tests/test_monte_carlo.py:        valid_params = SimulationParams(\nbackend/tests/test_monte_carlo.py:        default_params = SimulationParams()\nbackend/tests/test_monte_carlo.py:        params = SimulationParams(num_simulations=5000, use_parallel=False)\nbackend/tests/test_monte_carlo.py:        params = SimulationParams(\nbackend/tests/test_monte_carlo.py:        self.assertLess(total_time, 50, f\"Simulation took {total_time:.1f}ms, should be under 50ms\")\nbackend/tests/test_monte_carlo.py:        params = SimulationParams(num_simulations=1000, use_parallel=False)\nbackend/tests/test_monte_carlo.py:        params = SimulationParams(num_simulations=2000, confidence_level=0.95)\nbackend/tests/test_monte_carlo.py:        params = SimulationParams(num_simulations=1000)\nbackend/tests/test_monte_carlo.py:        params_parallel = SimulationParams(num_simulations=1000, use_parallel=True, num_threads=2)\nbackend/tests/test_monte_carlo.py:        params_sequential = SimulationParams(num_simulations=1000, use_parallel=False)\nbackend/tests/test_monte_carlo.py:        params = SimulationParams(\nbackend/tests/test_monte_carlo.py:        minimal_params = SimulationParams(num_simulations=10)\nbackend/tests/test_monte_carlo.py:        self.assertIsInstance(minimal_result, SimulationResult)\nbackend/tests/test_monte_carlo.py:        self.assertIsInstance(single_result, SimulationResult)\nbackend/tests/test_monte_carlo.py:        params = SimulationParams(num_simulations=2000, use_parallel=False)\nbackend/tests/test_monte_carlo.py:        self.assertIsInstance(result, SimulationResult)\nbackend/tests/test_monte_carlo.py:        self.assertIsInstance(result, SimulationResult)\nbackend/tests/simulation/test_simulation_scenarios.py:class WolfGoatPigSimulationTester:\nbackend/tests/simulation/test_simulation_scenarios.py:class SimulationScenarios:\nbackend/tests/simulation/test_simulation_scenarios.py:class TestSimulationMode:\nbackend/tests/simulation/test_simulation_scenarios.py:        return WolfGoatPigSimulationTester()\nbackend/tests/simulation/test_simulation_scenarios.py:        scenario = SimulationScenarios.aggressive_captain_solo()\nbackend/tests/simulation/test_simulation_scenarios.py:        scenario = SimulationScenarios.partnership_acceptance()\nbackend/tests/simulation/test_simulation_scenarios.py:        tester = WolfGoatPigSimulationTester()\nbackend/tests/simulation/test_simulation_scenarios.py:        scenario = SimulationScenarios.partnership_acceptance()\nbackend/tests/simulation/__init__.py:\"\"\"Simulation test subpackage for backend suite.\"\"\"\nBinary file backend/tests/simulation/__pycache__/test_simulation_scenarios.cpython-313-pytest-8.4.1.pyc matches\nBinary file backend/tests/simulation/__pycache__/test_simulation_scenarios.cpython-313-pytest-8.4.2.pyc matches\nBinary file backend/tests/simulation/__pycache__/test_simulation_scenarios.cpython-312-pytest-8.4.2.pyc matches\nBinary file backend/tests/simulation/__pycache__/__init__.cpython-312.pyc matches\nBinary file backend/tests/simulation/__pycache__/__init__.cpython-313.pyc matches\nBinary file backend/tests/__pycache__/test_monte_carlo.cpython-313-pytest-8.4.1.pyc matches\nBinary file backend/tests/__pycache__/test_simulation_endpoints.cpython-313-pytest-8.4.1.pyc matches\nBinary file backend/tests/__pycache__/test_monte_carlo.cpython-313-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_performance.cpython-312-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_simulation_endpoints.cpython-313-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_simulation_integration.cpython-313-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_bootstrapping.cpython-312-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_simulation_integration.cpython-313-pytest-8.4.1.pyc matches\nBinary file backend/tests/__pycache__/test_performance.cpython-313-pytest-8.4.1.pyc matches\nBinary file backend/tests/__pycache__/test_simulation_endpoints.cpython-312-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_performance.cpython-313-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_monte_carlo.cpython-312-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_simulation_integration.cpython-312-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_simulation_integration.cpython-313.pyc matches\nBinary file backend/tests/__pycache__/test_bootstrapping.cpython-313-pytest-8.4.1.pyc matches\nBinary file backend/tests/__pycache__/test_bootstrapping.cpython-313-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_models_schemas.cpython-312-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_simulation_unit.cpython-312-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_models_schemas.cpython-313-pytest-8.4.2.pyc matches\nBinary file backend/tests/__pycache__/test_simulation_uni\n\n[Full output saved to: /Users/stuartgano/Documents/wolf-goat-pig/.code/agents/1/exec-call_0g6GEjzks19oHrca9r6BajC3.txt]","metadata":{"exit_code":124,"duration_seconds":10.0}}
./.code/agents/1/exec-call_4RVJwhQNhzGXDjD9uJcWOYTY.txt:156:./.code/agents/8686/exec-call_XoxG4oyhZyliLxun4Q9epDVL.txt:17:Agent: Map backend product modes: Simulation, Signup/Matchmaking, Sunday Game, GHIN/Sheets sync, Analytics, Legacy Signup. For each, list main FastAPI/CLI entry points, services, and database seeds. Identify corresponding pytest suites or scripts. Note any TODOs, feature flags (like ENABLE_TEST_ENDPOINTS), or risks referenced in code/docs.
./.code/agents/1/exec-call_4RVJwhQNhzGXDjD9uJcWOYTY.txt:157:./.code/agents/8686/exec-call_XoxG4oyhZyliLxun4Q9epDVL.txt:37:Agent: Map backend product modes: Simulation, Signup/Matchmaking, Sunday Game, GHIN/Sheets sync, Analytics, Legacy Signup. For each, list main FastAPI/CLI entry points, services, and database seeds. Identify corresponding pytest suites or scripts. Note any TODOs, feature flags (like ENABLE_TEST_ENDPOINTS), or risks referenced in code/docs.
./.code/agents/1/exec-call_4RVJwhQNhzGXDjD9uJcWOYTY.txt:274:./.code/agents/d2500510-1eb3-4463-b8e7-50921c694cf1/result.txt:14:Agent: Map backend product modes: Simulation, Signup/Matchmaking, Sunday Game, GHIN/Sheets sync, Analytics, Legacy Signup. For each, list main FastAPI/CLI entry points, services, and database seeds. Identify corresponding pytest suites or scripts. Note any TODOs, feature flags (like ENABLE_TEST_ENDPOINTS), or risks referenced in code/docs.
[2025-10-20T16:12:35] tokens used: 124,530

[2025-10-20T16:12:50] thinking

**Verifying frontend logging guard TODOs**
[2025-10-20T16:12:51] exec bash -lc "sed -n '1,160p' frontend/src/components/WGPAnalyticsDashboard.js" in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:12:52] bash -lc "sed -n '1,160p' frontend/src/components/WGPAnalyticsDashboard.js" succeeded in 735ms:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
import React, { useState, useEffect, useCallback } from 'react';
import ghinService, { initializeGHIN } from '../services/ghinService';

const WGPAnalyticsDashboard = () => {
  const [leaderboardData, setLeaderboardData] = useState([]);
  const [topBestScores, setTopBestScores] = useState([]);
  const [topWorstScores, setTopWorstScores] = useState([]);
  const [mostRoundsPlayed, setMostRoundsPlayed] = useState([]);
  const [loading, setLoading] = useState(true);
  const [ghinLoading, setGhinLoading] = useState(false);
  const [ghinData, setGhinData] = useState({});
  const [ghinEnabled, setGhinEnabled] = useState(false);

  const calculateQB = useCallback((player, rank) => {
    const totalPlayers = 28;
    return totalPlayers * 10 + (totalPlayers - rank) * 10;
  }, []);
[2025-10-20T16:12:52] tokens used: 126,446

[2025-10-20T16:13:03] thinking

**Investigating TODO comments related to console guards**
[2025-10-20T16:13:04] exec bash -lc 'grep -R "TODO" frontend -n' in /Users/stuartgano/Documents/wolf-goat-pig
[2025-10-20T16:13:14] tokens used: 128,641
[2025-10-20T16:13:17] bash -lc 'grep -R "TODO" frontend -n' succeeded in 13.66s:
🎯 ADK auto-sync aliases loaded!
💡 Use 'sync' to sync with upstream anytime
💡 Use 'synccheck' to check sync status
frontend/node_modules/jest-runtime/build/index.js:1345:          res // TODO: will this work on windows? It might be better if `shouldInstrument` deals with it anyways
frontend/node_modules/jest-runtime/build/index.js:2025:      // TODO: consider warning somehow that this does nothing. We should support deletions, anyways
frontend/node_modules/workbox-strategies/StrategyHandler.js:307:            // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
frontend/node_modules/workbox-strategies/StrategyHandler.js:400:            // TODO(philipwalton): not sure why `any` is needed. It seems like
frontend/node_modules/workbox-strategies/StrategyHandler.js:420:                    // TODO(philipwalton): not sure why `any` is needed. It seems like
frontend/node_modules/workbox-strategies/build/workbox-strategies.dev.js:342:        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams_js.cacheMatchIgnoreParams( // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
frontend/node_modules/workbox-strategies/build/workbox-strategies.dev.js:449:          // TODO(philipwalton): not sure why `any` is needed. It seems like
frontend/node_modules/workbox-strategies/build/workbox-strategies.dev.js:473:              }); // TODO(philipwalton): not sure why `any` is needed. It seems like
frontend/node_modules/workbox-strategies/build/workbox-strategies.dev.js.map:1:{"version":3,"file":"workbox-strategies.dev.js","sources":["../_version.js","../StrategyHandler.js","../Strategy.js","../utils/messages.js","../CacheFirst.js","../CacheOnly.js","../plugins/cacheOkAndOpaquePlugin.js","../NetworkFirst.js","../NetworkOnly.js","../StaleWhileRevalidate.js"],"sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:strategies:6.5.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n    return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * {@link workbox-strategies.Strategy~handle} or\n * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof workbox-strategies\n */\nclass StrategyHandler {\n    /**\n     * Creates a new instance associated with the passed strategy and event\n     * that's handling the request.\n     *\n     * The constructor also initializes the state that will be passed to each of\n     * the plugins handling this request.\n     *\n     * @param {workbox-strategies.Strategy} strategy\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params] The return value from the\n     *     {@link workbox-routing~matchCallback} (if applicable).\n     */\n    constructor(strategy, options) {\n        this._cacheKeys = {};\n        /**\n         * The request the strategy is performing (passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * @name request\n         * @instance\n         * @type {Request}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * The event associated with this request.\n         * @name event\n         * @instance\n         * @type {ExtendableEvent}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `URL` instance of `request.url` (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `url` param will be present if the strategy was invoked\n         * from a workbox `Route` object.\n         * @name url\n         * @instance\n         * @type {URL|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `param` value (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `param` param will be present if the strategy was invoked\n         * from a workbox `Route` object and the\n         * {@link workbox-routing~matchCallback} returned\n         * a truthy value (it will be that value).\n         * @name params\n         * @instance\n         * @type {*|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(options.event, ExtendableEvent, {\n                moduleName: 'workbox-strategies',\n                className: 'StrategyHandler',\n                funcName: 'constructor',\n                paramName: 'options.event',\n            });\n        }\n        Object.assign(this, options);\n        this.event = options.event;\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        // Copy the plugins list (since it's mutable on the strategy),\n        // so any mutations don't affect this handler instance.\n        this._plugins = [...strategy.plugins];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins) {\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    /**\n     * Fetches a given request (and invokes any applicable plugin callback\n     * methods) using the `fetchOptions` (for non-navigation requests) and\n     * `plugins` defined on the `Strategy` object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - `requestWillFetch()`\n     * - `fetchDidSucceed()`\n     * - `fetchDidFail()`\n     *\n     * @param {Request|string} input The URL or request to fetch.\n     * @return {Promise<Response>}\n     */\n    async fetch(input) {\n        const { event } = this;\n        let request = toRequest(input);\n        if (request.mode === 'navigate' &&\n            event instanceof FetchEvent &&\n            event.preloadResponse) {\n            const possiblePreloadResponse = (await event.preloadResponse);\n            if (possiblePreloadResponse) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log(`Using a preloaded navigation response for ` +\n                        `'${getFriendlyURL(request.url)}'`);\n                }\n                return possiblePreloadResponse;\n            }\n        }\n        // If there is a fetchDidFail plugin, we need to save a clone of the\n        // original request before it's either modified by a requestWillFetch\n        // plugin or before the original request's body is consumed via fetch().\n        const originalRequest = this.hasCallback('fetchDidFail')\n            ? request.clone()\n            : null;\n        try {\n            for (const cb of this.iterateCallbacks('requestWillFetch')) {\n                request = await cb({ request: request.clone(), event });\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                throw new WorkboxError('plugin-error-request-will-fetch', {\n                    thrownErrorMessage: err.message,\n                });\n            }\n        }\n        // The request can be altered by plugins with `requestWillFetch` making\n        // the original request (most likely from a `fetch` event) different\n        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n        const pluginFilteredRequest = request.clone();\n        try {\n            let fetchResponse;\n            // See https://github.com/GoogleChrome/workbox/issues/1796\n            fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' returned a response with ` +\n                    `status '${fetchResponse.status}'.`);\n            }\n            for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n                fetchResponse = await callback({\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse,\n                });\n            }\n            return fetchResponse;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.log(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' threw an error.`, error);\n            }\n            // `originalRequest` will only exist if a `fetchDidFail` callback\n            // is being used (see above).\n            if (originalRequest) {\n                await this.runCallbacks('fetchDidFail', {\n                    error: error,\n                    event,\n                    originalRequest: originalRequest.clone(),\n                    request: pluginFilteredRequest.clone(),\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n     * the response generated by `this.fetch()`.\n     *\n     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n     * so you do not have to manually call `waitUntil()` on the event.\n     *\n     * @param {Request|string} input The request or URL to fetch and cache.\n     * @return {Promise<Response>}\n     */\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    /**\n     * Matches a request from the cache (and invokes any applicable plugin\n     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n     * defined on the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cachedResponseWillByUsed()\n     *\n     * @param {Request|string} key The Request or URL to use as the cache key.\n     * @return {Promise<Response|undefined>} A matching response, if found.\n     */\n    async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const { cacheName, matchOptions } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, 'read');\n        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), { cacheName });\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        if (process.env.NODE_ENV !== 'production') {\n            if (cachedResponse) {\n                logger.debug(`Found a cached response in '${cacheName}'.`);\n            }\n            else {\n                logger.debug(`No cached response found in '${cacheName}'.`);\n            }\n        }\n        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n            cachedResponse =\n                (await callback({\n                    cacheName,\n                    matchOptions,\n                    cachedResponse,\n                    request: effectiveRequest,\n                    event: this.event,\n                })) || undefined;\n        }\n        return cachedResponse;\n    }\n    /**\n     * Puts a request/response pair in the cache (and invokes any applicable\n     * plugin callback methods) using the `cacheName` and `plugins` defined on\n     * the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cacheWillUpdate()\n     * - cacheDidUpdate()\n     *\n     * @param {Request|string} key The request or URL to use as the cache key.\n     * @param {Response} response The response to cache.\n     * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n     * not be cached, and `true` otherwise.\n     */\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        // Run in the next task to avoid blocking other cache reads.\n        // https://github.com/w3c/ServiceWorker/issues/1397\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, 'write');\n        if (process.env.NODE_ENV !== 'production') {\n            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n                throw new WorkboxError('attempt-to-cache-non-get-request', {\n                    url: getFriendlyURL(effectiveRequest.url),\n                    method: effectiveRequest.method,\n                });\n            }\n            // See https://github.com/GoogleChrome/workbox/issues/2818\n            const vary = response.headers.get('Vary');\n            if (vary) {\n                logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` +\n                    `has a 'Vary: ${vary}' header. ` +\n                    `Consider setting the {ignoreVary: true} option on your strategy ` +\n                    `to ensure cache matching and deletion works as expected.`);\n            }\n        }\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(`Cannot cache non-existent response for ` +\n                    `'${getFriendlyURL(effectiveRequest.url)}'.`);\n            }\n            throw new WorkboxError('cache-put-with-no-response', {\n                url: getFriendlyURL(effectiveRequest.url),\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +\n                    `will not be cached.`, responseToCache);\n            }\n            return false;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n        const oldResponse = hasCacheUpdateCallback\n            ? await cacheMatchIgnoreParams(\n            // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n            // feature. Consider into ways to only add this behavior if using\n            // precaching.\n            cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions)\n            : null;\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +\n                `for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n                if (error.name === 'QuotaExceededError') {\n                    await executeQuotaErrorCallbacks();\n                }\n                throw error;\n            }\n        }\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event,\n            });\n        }\n        return true;\n    }\n    /**\n     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n     * executes any of those callbacks found in sequence. The final `Request`\n     * object returned by the last plugin is treated as the cache key for cache\n     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n     * been registered, the passed request is returned unmodified\n     *\n     * @param {Request} request\n     * @param {string} mode\n     * @return {Promise<Request>}\n     */\n    async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    // params has a type any can't change right now.\n                    params: this.params, // eslint-disable-line\n                }));\n            }\n            this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n    }\n    /**\n     * Returns true if the strategy has at least one plugin with the given\n     * callback.\n     *\n     * @param {string} name The name of the callback to check for.\n     * @return {boolean}\n     */\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Runs all plugin callbacks matching the given name, in order, passing the\n     * given param object (merged ith the current plugin state) as the only\n     * argument.\n     *\n     * Note: since this method runs all plugins, it's not suitable for cases\n     * where the return value of a callback needs to be applied prior to calling\n     * the next callback. See\n     * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n     * below for how to handle that case.\n     *\n     * @param {string} name The name of the callback to run within each plugin.\n     * @param {Object} param The object to pass as the first (and only) param\n     *     when executing each callback. This object will be merged with the\n     *     current plugin state prior to callback execution.\n     */\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)) {\n            // TODO(philipwalton): not sure why `any` is needed. It seems like\n            // this should work with `as WorkboxPluginCallbackParam[C]`.\n            await callback(param);\n        }\n    }\n    /**\n     * Accepts a callback and returns an iterable of matching plugin callbacks,\n     * where each callback is wrapped with the current handler state (i.e. when\n     * you call each callback, whatever object parameter you pass it will\n     * be merged with the plugin's current state).\n     *\n     * @param {string} name The name fo the callback to run\n     * @return {Array<Function>}\n     */\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (typeof plugin[name] === 'function') {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param) => {\n                    const statefulParam = Object.assign(Object.assign({}, param), { state });\n                    // TODO(philipwalton): not sure why `any` is needed. It seems like\n                    // this should work with `as WorkboxPluginCallbackParam[C]`.\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    /**\n     * Adds a promise to the\n     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n     * of the event event associated with the request being handled (usually a\n     * `FetchEvent`).\n     *\n     * Note: you can await\n     * {@link workbox-strategies.StrategyHandler~doneWaiting}\n     * to know when all added promises have settled.\n     *\n     * @param {Promise} promise A promise to add to the extend lifetime promises\n     *     of the event that triggered the request.\n     */\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    /**\n     * Returns a promise that resolves once all promises passed to\n     * {@link workbox-strategies.StrategyHandler~waitUntil}\n     * have settled.\n     *\n     * Note: any work done after `doneWaiting()` settles should be manually\n     * passed to an event's `waitUntil()` method (not this handler's\n     * `waitUntil()` method), otherwise the service worker thread my be killed\n     * prior to your work completing.\n     */\n    async doneWaiting() {\n        let promise;\n        while ((promise = this._extendLifetimePromises.shift())) {\n            await promise;\n        }\n    }\n    /**\n     * Stops running the strategy and immediately resolves any pending\n     * `waitUntil()` promises.\n     */\n    destroy() {\n        this._handlerDeferred.resolve(null);\n    }\n    /**\n     * This method will call cacheWillUpdate on the available plugins (or use\n     * status === 200) to determine if the Response is safe and valid to cache.\n     *\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @return {Promise<Response|undefined>}\n     *\n     * @private\n     */\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n            responseToCache =\n                (await callback({\n                    request: this.request,\n                    response: responseToCache,\n                    event: this.event,\n                })) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                responseToCache = undefined;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    if (responseToCache.status !== 200) {\n                        if (responseToCache.status === 0) {\n                            logger.warn(`The response for '${this.request.url}' ` +\n                                `is an opaque response. The caching strategy that you're ` +\n                                `using will not cache opaque responses by default.`);\n                        }\n                        else {\n                            logger.debug(`The response for '${this.request.url}' ` +\n                                `returned a status code of '${response.status}' and won't ` +\n                                `be cached as a result.`);\n                        }\n                    }\n                }\n            }\n        }\n        return responseToCache;\n    }\n}\nexport { StrategyHandler };\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\nclass Strategy {\n    /**\n     * Creates a new instance of the strategy and sets all documented option\n     * properties as public instance properties.\n     *\n     * Note: if a custom strategy class extends the base Strategy class and does\n     * not need more than these properties, it does not need to define its own\n     * constructor.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     */\n    constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * {@link workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n    }\n    /**\n     * Perform a request strategy and returns a `Promise` that will resolve with\n     * a `Response`, invoking all relevant plugin callbacks.\n     *\n     * When a strategy instance is registered with a Workbox\n     * {@link workbox-routing.Route}, this method is automatically\n     * called when the route matches.\n     *\n     * Alternatively, this method can be used in a standalone `FetchEvent`\n     * listener by passing it to `event.respondWith()`.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     */\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    /**\n     * Similar to {@link workbox-strategies.Strategy~handle}, but\n     * instead of just returning a `Promise` that resolves to a `Response` it\n     * it will return an tuple of `[response, done]` promises, where the former\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\n     * Promise that will resolve once any promises that were added to\n     * `event.waitUntil()` as part of performing the strategy have completed.\n     *\n     * You can await the `done` promise to ensure any extra work performed by\n     * the strategy (usually caching responses) completes successfully.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     * @return {Array<Promise>} A tuple of [response, done]\n     *     promises that can be used to determine when the response resolves as\n     *     well as when the handler has completed all its work.\n     */\n    handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request,\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string'\n            ? new Request(options.request)\n            : options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, { event, request, params });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', { event, request });\n        let response = undefined;\n        try {\n            response = await this._handle(request, handler);\n            // The \"official\" Strategy subclasses all throw this error automatically,\n            // but in case a third-party Strategy doesn't, ensure that we have a\n            // consistent failure when there's no response or an error response.\n            if (!response || response.type === 'error') {\n                throw new WorkboxError('no-response', { url: request.url });\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                for (const callback of handler.iterateCallbacks('handlerDidError')) {\n                    response = await callback({ error, event, request });\n                    if (response) {\n                        break;\n                    }\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +\n                    `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` +\n                    `a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n            response = await callback({ event, request, response });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n            response = await responseDone;\n        }\n        catch (error) {\n            // Ignore errors, as response errors should be caught via the `response`\n            // promise above. The `done` promise will only throw for errors in\n            // promises passed to `handler.waitUntil()`.\n        }\n        try {\n            await handler.runCallbacks('handlerDidRespond', {\n                event,\n                request,\n                response,\n            });\n            await handler.doneWaiting();\n        }\n        catch (waitUntilError) {\n            if (waitUntilError instanceof Error) {\n                error = waitUntilError;\n            }\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n            event,\n            request,\n            response,\n            error: error,\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport '../_version.js';\nexport const messages = {\n    strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,\n    printFinalResponse: (response) => {\n        if (response) {\n            logger.groupCollapsed(`View the final response here.`);\n            logger.log(response || '[No response returned]');\n            logger.groupEnd();\n        }\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-first-falling-back-to-network)\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass CacheFirst extends Strategy {\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        let response = await handler.cacheMatch(request);\n        let error = undefined;\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this.cacheName}' cache. ` +\n                    `Will respond with a network request.`);\n            }\n            try {\n                response = await handler.fetchAndCachePut(request);\n            }\n            catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Got response from network.`);\n                }\n                else {\n                    logs.push(`Unable to get a response from the network.`);\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { CacheFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-only)\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass CacheOnly extends Strategy {\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        const response = await handler.cacheMatch(request);\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                logger.log(`Found a cached response in the '${this.cacheName}' ` + `cache.`);\n                messages.printFinalResponse(response);\n            }\n            else {\n                logger.log(`No response found in the '${this.cacheName}' cache.`);\n            }\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n}\nexport { CacheOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nexport const cacheOkAndOpaquePlugin = {\n    /**\n     * Returns a valid response (to allow caching) if the status is 200 (OK) or\n     * 0 (opaque).\n     *\n     * @param {Object} options\n     * @param {Response} options.response\n     * @return {Response|null}\n     *\n     * @private\n     */\n    cacheWillUpdate: async ({ response }) => {\n        if (response.status === 200 || response.status === 0) {\n            return response;\n        }\n        return null;\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-first-falling-back-to-cache)\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS](https://enable-cors.org/).\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass NetworkFirst extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */\n    constructor(options = {}) {\n        super(options);\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n        if (!this.plugins.some((p) => 'cacheWillUpdate' in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._networkTimeoutSeconds) {\n                assert.isType(this._networkTimeoutSeconds, 'number', {\n                    moduleName: 'workbox-strategies',\n                    className: this.constructor.name,\n                    funcName: 'constructor',\n                    paramName: 'networkTimeoutSeconds',\n                });\n            }\n        }\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'handle',\n                paramName: 'makeRequest',\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({ request, logs, handler });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({\n            timeoutId,\n            request,\n            logs,\n            handler,\n        });\n        promises.push(networkPromise);\n        const response = await handler.waitUntil((async () => {\n            // Promise.race() will resolve as soon as the first promise resolves.\n            return ((await handler.waitUntil(Promise.race(promises))) ||\n                // If Promise.race() resolved with null, it might be due to a network\n                // timeout + a cache miss. If that were to happen, we'd rather wait until\n                // the networkPromise resolves instead of returning null.\n                // Note that it's fine to await an already-resolved promise, so we don't\n                // have to check to see if it's still \"in flight\".\n                (await networkPromise));\n        })());\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} options.event\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    _getTimeoutPromise({ request, logs, handler, }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve) => {\n            const onNetworkTimeout = async () => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logs.push(`Timing out the network response at ` +\n                        `${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await handler.cacheMatch(request));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId,\n        };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} options.event\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getNetworkPromise({ timeoutId, request, logs, handler, }) {\n        let error;\n        let response;\n        try {\n            response = await handler.fetchAndCachePut(request);\n        }\n        catch (fetchError) {\n            if (fetchError instanceof Error) {\n                error = fetchError;\n            }\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (response) {\n                logs.push(`Got response from network.`);\n            }\n            else {\n                logs.push(`Unable to get a response from the network. Will respond ` +\n                    `with a cached response.`);\n            }\n        }\n        if (error || !response) {\n            response = await handler.cacheMatch(request);\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this.cacheName}'` + ` cache.`);\n                }\n                else {\n                    logs.push(`No response found in the '${this.cacheName}' cache.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { NetworkFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-only)\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass NetworkOnly extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n     * that fail to respond within the timeout will result in a network error.\n     */\n    constructor(options = {}) {\n        super(options);\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: '_handle',\n                paramName: 'request',\n            });\n        }\n        let error = undefined;\n        let response;\n        try {\n            const promises = [\n                handler.fetch(request),\n            ];\n            if (this._networkTimeoutSeconds) {\n                const timeoutPromise = timeout(this._networkTimeoutSeconds * 1000);\n                promises.push(timeoutPromise);\n            }\n            response = await Promise.race(promises);\n            if (!response) {\n                throw new Error(`Timed out the network response after ` +\n                    `${this._networkTimeoutSeconds} seconds.`);\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                error = err;\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                logger.log(`Got response from network.`);\n            }\n            else {\n                logger.log(`Unable to get a response from the network.`);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { NetworkOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [stale-while-revalidate](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate)\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).\n * Opaque responses are cross-origin requests where the response doesn't\n * support [CORS](https://enable-cors.org/).\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass StaleWhileRevalidate extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        super(options);\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n        if (!this.plugins.some((p) => 'cacheWillUpdate' in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'handle',\n                paramName: 'request',\n            });\n        }\n        const fetchAndCachePromise = handler.fetchAndCachePut(request).catch(() => {\n            // Swallow this error because a 'no-response' error will be thrown in\n            // main handler return flow. This will be in the `waitUntil()` flow.\n        });\n        void handler.waitUntil(fetchAndCachePromise);\n        let response = await handler.cacheMatch(request);\n        let error;\n        if (response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this.cacheName}'` +\n                    ` cache. Will update with the network response in the background.`);\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this.cacheName}' cache. ` +\n                    `Will wait for the network response.`);\n            }\n            try {\n                // NOTE(philipwalton): Really annoying that we have to type cast here.\n                // https://github.com/microsoft/TypeScript/issues/20006\n                response = (await fetchAndCachePromise);\n            }\n            catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { StaleWhileRevalidate };\n"],"names":["self","_","e","toRequest","input","Request","StrategyHandler","constructor","strategy","options","_cacheKeys","assert","isInstance","event","ExtendableEvent","moduleName","className","funcName","paramName","Object","assign","_strategy","_handlerDeferred","Deferred","_extendLifetimePromises","_plugins","plugins","_pluginStateMap","Map","plugin","set","waitUntil","promise","fetch","request","mode","FetchEvent","preloadResponse","possiblePreloadResponse","logger","log","getFriendlyURL","url","originalRequest","hasCallback","clone","cb","iterateCallbacks","err","Error","WorkboxError","thrownErrorMessage","message","pluginFilteredRequest","fetchResponse","undefined","fetchOptions","process","debug","status","callback","response","error","runCallbacks","fetchAndCachePut","responseClone","cachePut","cacheMatch","key","cachedResponse","cacheName","matchOptions","effectiveRequest","getCacheKey","multiMatchOptions","caches","match","timeout","method","vary","headers","get","responseToCache","_ensureResponseSafeToCache","cache","open","hasCacheUpdateCallback","oldResponse","cacheMatchIgnoreParams","put","name","executeQuotaErrorCallbacks","newResponse","params","param","state","statefulCallback","statefulParam","push","doneWaiting","shift","destroy","resolve","pluginsUsed","warn","Strategy","cacheNames","getRuntimeName","handle","responseDone","handleAll","handler","_getResponse","handlerDone","_awaitComplete","_handle","type","toString","waitUntilError","messages","strategyStart","strategyName","printFinalResponse","groupCollapsed","groupEnd","CacheFirst","logs","CacheOnly","cacheOkAndOpaquePlugin","cacheWillUpdate","NetworkFirst","some","p","unshift","_networkTimeoutSeconds","networkTimeoutSeconds","isType","promises","timeoutId","id","_getTimeoutPromise","networkPromise","_getNetworkPromise","Promise","race","timeoutPromise","onNetworkTimeout","setTimeout","fetchError","clearTimeout","NetworkOnly","StaleWhileRevalidate","fetchAndCachePromise","catch"],"mappings":"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"}
frontend/node_modules/workbox-strategies/build/workbox-strategies.prod.js.map:1:{"version":3,"file":"workbox-strategies.prod.js","sources":["../_version.js","../StrategyHandler.js","../Strategy.js","../plugins/cacheOkAndOpaquePlugin.js","../CacheFirst.js","../CacheOnly.js","../NetworkFirst.js","../NetworkOnly.js","../StaleWhileRevalidate.js"],"sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:strategies:6.5.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n    return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * {@link workbox-strategies.Strategy~handle} or\n * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof workbox-strategies\n */\nclass StrategyHandler {\n    /**\n     * Creates a new instance associated with the passed strategy and event\n     * that's handling the request.\n     *\n     * The constructor also initializes the state that will be passed to each of\n     * the plugins handling this request.\n     *\n     * @param {workbox-strategies.Strategy} strategy\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params] The return value from the\n     *     {@link workbox-routing~matchCallback} (if applicable).\n     */\n    constructor(strategy, options) {\n        this._cacheKeys = {};\n        /**\n         * The request the strategy is performing (passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * @name request\n         * @instance\n         * @type {Request}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * The event associated with this request.\n         * @name event\n         * @instance\n         * @type {ExtendableEvent}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `URL` instance of `request.url` (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `url` param will be present if the strategy was invoked\n         * from a workbox `Route` object.\n         * @name url\n         * @instance\n         * @type {URL|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `param` value (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `param` param will be present if the strategy was invoked\n         * from a workbox `Route` object and the\n         * {@link workbox-routing~matchCallback} returned\n         * a truthy value (it will be that value).\n         * @name params\n         * @instance\n         * @type {*|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(options.event, ExtendableEvent, {\n                moduleName: 'workbox-strategies',\n                className: 'StrategyHandler',\n                funcName: 'constructor',\n                paramName: 'options.event',\n            });\n        }\n        Object.assign(this, options);\n        this.event = options.event;\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        // Copy the plugins list (since it's mutable on the strategy),\n        // so any mutations don't affect this handler instance.\n        this._plugins = [...strategy.plugins];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins) {\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    /**\n     * Fetches a given request (and invokes any applicable plugin callback\n     * methods) using the `fetchOptions` (for non-navigation requests) and\n     * `plugins` defined on the `Strategy` object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - `requestWillFetch()`\n     * - `fetchDidSucceed()`\n     * - `fetchDidFail()`\n     *\n     * @param {Request|string} input The URL or request to fetch.\n     * @return {Promise<Response>}\n     */\n    async fetch(input) {\n        const { event } = this;\n        let request = toRequest(input);\n        if (request.mode === 'navigate' &&\n            event instanceof FetchEvent &&\n            event.preloadResponse) {\n            const possiblePreloadResponse = (await event.preloadResponse);\n            if (possiblePreloadResponse) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log(`Using a preloaded navigation response for ` +\n                        `'${getFriendlyURL(request.url)}'`);\n                }\n                return possiblePreloadResponse;\n            }\n        }\n        // If there is a fetchDidFail plugin, we need to save a clone of the\n        // original request before it's either modified by a requestWillFetch\n        // plugin or before the original request's body is consumed via fetch().\n        const originalRequest = this.hasCallback('fetchDidFail')\n            ? request.clone()\n            : null;\n        try {\n            for (const cb of this.iterateCallbacks('requestWillFetch')) {\n                request = await cb({ request: request.clone(), event });\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                throw new WorkboxError('plugin-error-request-will-fetch', {\n                    thrownErrorMessage: err.message,\n                });\n            }\n        }\n        // The request can be altered by plugins with `requestWillFetch` making\n        // the original request (most likely from a `fetch` event) different\n        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n        const pluginFilteredRequest = request.clone();\n        try {\n            let fetchResponse;\n            // See https://github.com/GoogleChrome/workbox/issues/1796\n            fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' returned a response with ` +\n                    `status '${fetchResponse.status}'.`);\n            }\n            for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n                fetchResponse = await callback({\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse,\n                });\n            }\n            return fetchResponse;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.log(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' threw an error.`, error);\n            }\n            // `originalRequest` will only exist if a `fetchDidFail` callback\n            // is being used (see above).\n            if (originalRequest) {\n                await this.runCallbacks('fetchDidFail', {\n                    error: error,\n                    event,\n                    originalRequest: originalRequest.clone(),\n                    request: pluginFilteredRequest.clone(),\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n     * the response generated by `this.fetch()`.\n     *\n     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n     * so you do not have to manually call `waitUntil()` on the event.\n     *\n     * @param {Request|string} input The request or URL to fetch and cache.\n     * @return {Promise<Response>}\n     */\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    /**\n     * Matches a request from the cache (and invokes any applicable plugin\n     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n     * defined on the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cachedResponseWillByUsed()\n     *\n     * @param {Request|string} key The Request or URL to use as the cache key.\n     * @return {Promise<Response|undefined>} A matching response, if found.\n     */\n    async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const { cacheName, matchOptions } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, 'read');\n        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), { cacheName });\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        if (process.env.NODE_ENV !== 'production') {\n            if (cachedResponse) {\n                logger.debug(`Found a cached response in '${cacheName}'.`);\n            }\n            else {\n                logger.debug(`No cached response found in '${cacheName}'.`);\n            }\n        }\n        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n            cachedResponse =\n                (await callback({\n                    cacheName,\n                    matchOptions,\n                    cachedResponse,\n                    request: effectiveRequest,\n                    event: this.event,\n                })) || undefined;\n        }\n        return cachedResponse;\n    }\n    /**\n     * Puts a request/response pair in the cache (and invokes any applicable\n     * plugin callback methods) using the `cacheName` and `plugins` defined on\n     * the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cacheWillUpdate()\n     * - cacheDidUpdate()\n     *\n     * @param {Request|string} key The request or URL to use as the cache key.\n     * @param {Response} response The response to cache.\n     * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n     * not be cached, and `true` otherwise.\n     */\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        // Run in the next task to avoid blocking other cache reads.\n        // https://github.com/w3c/ServiceWorker/issues/1397\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, 'write');\n        if (process.env.NODE_ENV !== 'production') {\n            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n                throw new WorkboxError('attempt-to-cache-non-get-request', {\n                    url: getFriendlyURL(effectiveRequest.url),\n                    method: effectiveRequest.method,\n                });\n            }\n            // See https://github.com/GoogleChrome/workbox/issues/2818\n            const vary = response.headers.get('Vary');\n            if (vary) {\n                logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` +\n                    `has a 'Vary: ${vary}' header. ` +\n                    `Consider setting the {ignoreVary: true} option on your strategy ` +\n                    `to ensure cache matching and deletion works as expected.`);\n            }\n        }\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(`Cannot cache non-existent response for ` +\n                    `'${getFriendlyURL(effectiveRequest.url)}'.`);\n            }\n            throw new WorkboxError('cache-put-with-no-response', {\n                url: getFriendlyURL(effectiveRequest.url),\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +\n                    `will not be cached.`, responseToCache);\n            }\n            return false;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n        const oldResponse = hasCacheUpdateCallback\n            ? await cacheMatchIgnoreParams(\n            // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n            // feature. Consider into ways to only add this behavior if using\n            // precaching.\n            cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions)\n            : null;\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +\n                `for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n                if (error.name === 'QuotaExceededError') {\n                    await executeQuotaErrorCallbacks();\n                }\n                throw error;\n            }\n        }\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event,\n            });\n        }\n        return true;\n    }\n    /**\n     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n     * executes any of those callbacks found in sequence. The final `Request`\n     * object returned by the last plugin is treated as the cache key for cache\n     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n     * been registered, the passed request is returned unmodified\n     *\n     * @param {Request} request\n     * @param {string} mode\n     * @return {Promise<Request>}\n     */\n    async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    // params has a type any can't change right now.\n                    params: this.params, // eslint-disable-line\n                }));\n            }\n            this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n    }\n    /**\n     * Returns true if the strategy has at least one plugin with the given\n     * callback.\n     *\n     * @param {string} name The name of the callback to check for.\n     * @return {boolean}\n     */\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Runs all plugin callbacks matching the given name, in order, passing the\n     * given param object (merged ith the current plugin state) as the only\n     * argument.\n     *\n     * Note: since this method runs all plugins, it's not suitable for cases\n     * where the return value of a callback needs to be applied prior to calling\n     * the next callback. See\n     * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n     * below for how to handle that case.\n     *\n     * @param {string} name The name of the callback to run within each plugin.\n     * @param {Object} param The object to pass as the first (and only) param\n     *     when executing each callback. This object will be merged with the\n     *     current plugin state prior to callback execution.\n     */\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)) {\n            // TODO(philipwalton): not sure why `any` is needed. It seems like\n            // this should work with `as WorkboxPluginCallbackParam[C]`.\n            await callback(param);\n        }\n    }\n    /**\n     * Accepts a callback and returns an iterable of matching plugin callbacks,\n     * where each callback is wrapped with the current handler state (i.e. when\n     * you call each callback, whatever object parameter you pass it will\n     * be merged with the plugin's current state).\n     *\n     * @param {string} name The name fo the callback to run\n     * @return {Array<Function>}\n     */\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (typeof plugin[name] === 'function') {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param) => {\n                    const statefulParam = Object.assign(Object.assign({}, param), { state });\n                    // TODO(philipwalton): not sure why `any` is needed. It seems like\n                    // this should work with `as WorkboxPluginCallbackParam[C]`.\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    /**\n     * Adds a promise to the\n     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n     * of the event event associated with the request being handled (usually a\n     * `FetchEvent`).\n     *\n     * Note: you can await\n     * {@link workbox-strategies.StrategyHandler~doneWaiting}\n     * to know when all added promises have settled.\n     *\n     * @param {Promise} promise A promise to add to the extend lifetime promises\n     *     of the event that triggered the request.\n     */\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    /**\n     * Returns a promise that resolves once all promises passed to\n     * {@link workbox-strategies.StrategyHandler~waitUntil}\n     * have settled.\n     *\n     * Note: any work done after `doneWaiting()` settles should be manually\n     * passed to an event's `waitUntil()` method (not this handler's\n     * `waitUntil()` method), otherwise the service worker thread my be killed\n     * prior to your work completing.\n     */\n    async doneWaiting() {\n        let promise;\n        while ((promise = this._extendLifetimePromises.shift())) {\n            await promise;\n        }\n    }\n    /**\n     * Stops running the strategy and immediately resolves any pending\n     * `waitUntil()` promises.\n     */\n    destroy() {\n        this._handlerDeferred.resolve(null);\n    }\n    /**\n     * This method will call cacheWillUpdate on the available plugins (or use\n     * status === 200) to determine if the Response is safe and valid to cache.\n     *\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @return {Promise<Response|undefined>}\n     *\n     * @private\n     */\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n            responseToCache =\n                (await callback({\n                    request: this.request,\n                    response: responseToCache,\n                    event: this.event,\n                })) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                responseToCache = undefined;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    if (responseToCache.status !== 200) {\n                        if (responseToCache.status === 0) {\n                            logger.warn(`The response for '${this.request.url}' ` +\n                                `is an opaque response. The caching strategy that you're ` +\n                                `using will not cache opaque responses by default.`);\n                        }\n                        else {\n                            logger.debug(`The response for '${this.request.url}' ` +\n                                `returned a status code of '${response.status}' and won't ` +\n                                `be cached as a result.`);\n                        }\n                    }\n                }\n            }\n        }\n        return responseToCache;\n    }\n}\nexport { StrategyHandler };\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\nclass Strategy {\n    /**\n     * Creates a new instance of the strategy and sets all documented option\n     * properties as public instance properties.\n     *\n     * Note: if a custom strategy class extends the base Strategy class and does\n     * not need more than these properties, it does not need to define its own\n     * constructor.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     */\n    constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * {@link workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n    }\n    /**\n     * Perform a request strategy and returns a `Promise` that will resolve with\n     * a `Response`, invoking all relevant plugin callbacks.\n     *\n     * When a strategy instance is registered with a Workbox\n     * {@link workbox-routing.Route}, this method is automatically\n     * called when the route matches.\n     *\n     * Alternatively, this method can be used in a standalone `FetchEvent`\n     * listener by passing it to `event.respondWith()`.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     */\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    /**\n     * Similar to {@link workbox-strategies.Strategy~handle}, but\n     * instead of just returning a `Promise` that resolves to a `Response` it\n     * it will return an tuple of `[response, done]` promises, where the former\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\n     * Promise that will resolve once any promises that were added to\n     * `event.waitUntil()` as part of performing the strategy have completed.\n     *\n     * You can await the `done` promise to ensure any extra work performed by\n     * the strategy (usually caching responses) completes successfully.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     * @return {Array<Promise>} A tuple of [response, done]\n     *     promises that can be used to determine when the response resolves as\n     *     well as when the handler has completed all its work.\n     */\n    handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request,\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string'\n            ? new Request(options.request)\n            : options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, { event, request, params });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', { event, request });\n        let response = undefined;\n        try {\n            response = await this._handle(request, handler);\n            // The \"official\" Strategy subclasses all throw this error automatically,\n            // but in case a third-party Strategy doesn't, ensure that we have a\n            // consistent failure when there's no response or an error response.\n            if (!response || response.type === 'error') {\n                throw new WorkboxError('no-response', { url: request.url });\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                for (const callback of handler.iterateCallbacks('handlerDidError')) {\n                    response = await callback({ error, event, request });\n                    if (response) {\n                        break;\n                    }\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +\n                    `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` +\n                    `a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n            response = await callback({ event, request, response });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n            response = await responseDone;\n        }\n        catch (error) {\n            // Ignore errors, as response errors should be caught via the `response`\n            // promise above. The `done` promise will only throw for errors in\n            // promises passed to `handler.waitUntil()`.\n        }\n        try {\n            await handler.runCallbacks('handlerDidRespond', {\n                event,\n                request,\n                response,\n            });\n            await handler.doneWaiting();\n        }\n        catch (waitUntilError) {\n            if (waitUntilError instanceof Error) {\n                error = waitUntilError;\n            }\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n            event,\n            request,\n            response,\n            error: error,\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nexport const cacheOkAndOpaquePlugin = {\n    /**\n     * Returns a valid response (to allow caching) if the status is 200 (OK) or\n     * 0 (opaque).\n     *\n     * @param {Object} options\n     * @param {Response} options.response\n     * @return {Response|null}\n     *\n     * @private\n     */\n    cacheWillUpdate: async ({ response }) => {\n        if (response.status === 200 || response.status === 0) {\n            return response;\n        }\n        return null;\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-first-falling-back-to-network)\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass CacheFirst extends Strategy {\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        let response = await handler.cacheMatch(request);\n        let error = undefined;\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this.cacheName}' cache. ` +\n                    `Will respond with a network request.`);\n            }\n            try {\n                response = await handler.fetchAndCachePut(request);\n            }\n            catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Got response from network.`);\n                }\n                else {\n                    logs.push(`Unable to get a response from the network.`);\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { CacheFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-only)\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass CacheOnly extends Strategy {\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        const response = await handler.cacheMatch(request);\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                logger.log(`Found a cached response in the '${this.cacheName}' ` + `cache.`);\n                messages.printFinalResponse(response);\n            }\n            else {\n                logger.log(`No response found in the '${this.cacheName}' cache.`);\n            }\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n}\nexport { CacheOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-first-falling-back-to-cache)\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS](https://enable-cors.org/).\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass NetworkFirst extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */\n    constructor(options = {}) {\n        super(options);\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n        if (!this.plugins.some((p) => 'cacheWillUpdate' in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._networkTimeoutSeconds) {\n                assert.isType(this._networkTimeoutSeconds, 'number', {\n                    moduleName: 'workbox-strategies',\n                    className: this.constructor.name,\n                    funcName: 'constructor',\n                    paramName: 'networkTimeoutSeconds',\n                });\n            }\n        }\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'handle',\n                paramName: 'makeRequest',\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({ request, logs, handler });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({\n            timeoutId,\n            request,\n            logs,\n            handler,\n        });\n        promises.push(networkPromise);\n        const response = await handler.waitUntil((async () => {\n            // Promise.race() will resolve as soon as the first promise resolves.\n            return ((await handler.waitUntil(Promise.race(promises))) ||\n                // If Promise.race() resolved with null, it might be due to a network\n                // timeout + a cache miss. If that were to happen, we'd rather wait until\n                // the networkPromise resolves instead of returning null.\n                // Note that it's fine to await an already-resolved promise, so we don't\n                // have to check to see if it's still \"in flight\".\n                (await networkPromise));\n        })());\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} options.event\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    _getTimeoutPromise({ request, logs, handler, }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve) => {\n            const onNetworkTimeout = async () => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logs.push(`Timing out the network response at ` +\n                        `${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await handler.cacheMatch(request));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId,\n        };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} options.event\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getNetworkPromise({ timeoutId, request, logs, handler, }) {\n        let error;\n        let response;\n        try {\n            response = await handler.fetchAndCachePut(request);\n        }\n        catch (fetchError) {\n            if (fetchError instanceof Error) {\n                error = fetchError;\n            }\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (response) {\n                logs.push(`Got response from network.`);\n            }\n            else {\n                logs.push(`Unable to get a response from the network. Will respond ` +\n                    `with a cached response.`);\n            }\n        }\n        if (error || !response) {\n            response = await handler.cacheMatch(request);\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this.cacheName}'` + ` cache.`);\n                }\n                else {\n                    logs.push(`No response found in the '${this.cacheName}' cache.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { NetworkFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-only)\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass NetworkOnly extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n     * that fail to respond within the timeout will result in a network error.\n     */\n    constructor(options = {}) {\n        super(options);\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: '_handle',\n                paramName: 'request',\n            });\n        }\n        let error = undefined;\n        let response;\n        try {\n            const promises = [\n                handler.fetch(request),\n            ];\n            if (this._networkTimeoutSeconds) {\n                const timeoutPromise = timeout(this._networkTimeoutSeconds * 1000);\n                promises.push(timeoutPromise);\n            }\n            response = await Promise.race(promises);\n            if (!response) {\n                throw new Error(`Timed out the network response after ` +\n                    `${this._networkTimeoutSeconds} seconds.`);\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                error = err;\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                logger.log(`Got response from network.`);\n            }\n            else {\n                logger.log(`Unable to get a response from the network.`);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { NetworkOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [stale-while-revalidate](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate)\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).\n * Opaque responses are cross-origin requests where the response doesn't\n * support [CORS](https://enable-cors.org/).\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-strategies\n */\nclass StaleWhileRevalidate extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        super(options);\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n        if (!this.plugins.some((p) => 'cacheWillUpdate' in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'handle',\n                paramName: 'request',\n            });\n        }\n        const fetchAndCachePromise = handler.fetchAndCachePut(request).catch(() => {\n            // Swallow this error because a 'no-response' error will be thrown in\n            // main handler return flow. This will be in the `waitUntil()` flow.\n        });\n        void handler.waitUntil(fetchAndCachePromise);\n        let response = await handler.cacheMatch(request);\n        let error;\n        if (response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this.cacheName}'` +\n                    ` cache. Will update with the network response in the background.`);\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this.cacheName}' cache. ` +\n                    `Will wait for the network response.`);\n            }\n            try {\n                // NOTE(philipwalton): Really annoying that we have to type cast here.\n                // https://github.com/microsoft/TypeScript/issues/20006\n                response = (await fetchAndCachePromise);\n            }\n            catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { StaleWhileRevalidate };\n"],"names":["self","_","e","toRequest","input","Request","StrategyHandler","constructor","strategy","options","_cacheKeys","Object","assign","this","event","_strategy","_handlerDeferred","Deferred","_extendLifetimePromises","_plugins","plugins","_pluginStateMap","Map","plugin","set","waitUntil","promise","request","mode","FetchEvent","preloadResponse","possiblePreloadResponse","originalRequest","hasCallback","clone","cb","iterateCallbacks","err","Error","WorkboxError","thrownErrorMessage","message","pluginFilteredRequest","fetchResponse","fetch","undefined","fetchOptions","callback","response","error","runCallbacks","responseClone","cachePut","key","cachedResponse","cacheName","matchOptions","effectiveRequest","getCacheKey","multiMatchOptions","caches","match","timeout","url","getFriendlyURL","responseToCache","_ensureResponseSafeToCache","cache","open","hasCacheUpdateCallback","oldResponse","cacheMatchIgnoreParams","put","name","executeQuotaErrorCallbacks","newResponse","params","param","state","get","statefulCallback","statefulParam","push","shift","destroy","resolve","pluginsUsed","status","Strategy","cacheNames","getRuntimeName","handle","responseDone","handleAll","handler","_getResponse","_awaitComplete","_handle","type","doneWaiting","waitUntilError","cacheOkAndOpaquePlugin","cacheWillUpdate","async","cacheMatch","fetchAndCachePut","some","p","unshift","_networkTimeoutSeconds","networkTimeoutSeconds","logs","promises","timeoutId","id","_getTimeoutPromise","networkPromise","_getNetworkPromise","Promise","race","setTimeout","fetchError","clearTimeout","timeoutPromise","fetchAndCachePromise","catch"],"mappings":"+FAEA,IACIA,KAAK,6BAA+BC,GACvC,CACD,MAAOC,ICWP,SAASC,EAAUC,SACS,iBAAVA,EAAqB,IAAIC,QAAQD,GAASA,CAC3D,CAUD,MAAME,EAiBFC,YAAYC,EAAUC,QACbC,GAAa,GA8ClBC,OAAOC,OAAOC,KAAMJ,QACfK,MAAQL,EAAQK,WAChBC,GAAYP,OACZQ,GAAmB,IAAIC,gBACvBC,GAA0B,QAG1BC,GAAW,IAAIX,EAASY,cACxBC,GAAkB,IAAIC,QACtB,MAAMC,KAAUV,KAAKM,QACjBE,GAAgBG,IAAID,EAAQ,SAEhCT,MAAMW,UAAUZ,KAAKG,GAAiBU,qBAenCtB,SACFU,MAAEA,GAAUD,SACdc,EAAUxB,EAAUC,MACH,aAAjBuB,EAAQC,MACRd,aAAiBe,YACjBf,EAAMgB,gBAAiB,OACjBC,QAAiCjB,EAAMgB,mBACzCC,SAKOA,QAMTC,EAAkBnB,KAAKoB,YAAY,gBACnCN,EAAQO,QACR,aAEG,MAAMC,KAAMtB,KAAKuB,iBAAiB,oBACnCT,QAAgBQ,EAAG,CAAER,QAASA,EAAQO,QAASpB,UAGvD,MAAOuB,MACCA,aAAeC,YACT,IAAIC,eAAa,kCAAmC,CACtDC,mBAAoBH,EAAII,gBAO9BC,EAAwBf,EAAQO,gBAE9BS,EAEJA,QAAsBC,MAAMjB,EAA0B,aAAjBA,EAAQC,UAAsBiB,EAAYhC,KAAKE,GAAU+B,kBAMzF,MAAMC,KAAYlC,KAAKuB,iBAAiB,mBACzCO,QAAsBI,EAAS,CAC3BjC,QACAa,QAASe,EACTM,SAAUL,WAGXA,EAEX,MAAOM,SAOCjB,SACMnB,KAAKqC,aAAa,eAAgB,CACpCD,MAAOA,EACPnC,QACAkB,gBAAiBA,EAAgBE,QACjCP,QAASe,EAAsBR,UAGjCe,0BAaS7C,SACb4C,QAAiBnC,KAAK+B,MAAMxC,GAC5B+C,EAAgBH,EAASd,eAC1BrB,KAAKY,UAAUZ,KAAKuC,SAAShD,EAAO+C,IAClCH,mBAcMK,SACP1B,EAAUxB,EAAUkD,OACtBC,QACEC,UAAEA,EAAFC,aAAaA,GAAiB3C,KAAKE,GACnC0C,QAAyB5C,KAAK6C,YAAY/B,EAAS,QACnDgC,EAAoBhD,OAAOC,OAAOD,OAAOC,OAAO,GAAI4C,GAAe,CAAED,cAC3ED,QAAuBM,OAAOC,MAAMJ,EAAkBE,OASjD,MAAMZ,KAAYlC,KAAKuB,iBAAiB,4BACzCkB,QACWP,EAAS,CACZQ,YACAC,eACAF,iBACA3B,QAAS8B,EACT3C,MAAOD,KAAKC,cACT+B,SAERS,iBAiBID,EAAKL,SACVrB,EAAUxB,EAAUkD,SAGpBS,UAAQ,SACRL,QAAyB5C,KAAK6C,YAAY/B,EAAS,aAiBpDqB,QAKK,IAAIT,eAAa,6BAA8B,CACjDwB,IAAKC,iBAAeP,EAAiBM,aAGvCE,QAAwBpD,KAAKqD,GAA2BlB,OACzDiB,SAKM,QAELV,UAAEA,EAAFC,aAAaA,GAAiB3C,KAAKE,GACnCoD,QAAcnE,KAAK4D,OAAOQ,KAAKb,GAC/Bc,EAAyBxD,KAAKoB,YAAY,kBAC1CqC,EAAcD,QACRE,yBAIRJ,EAAOV,EAAiBvB,QAAS,CAAC,mBAAoBsB,GACpD,eAMIW,EAAMK,IAAIf,EAAkBY,EAAyBJ,EAAgB/B,QAAU+B,GAEzF,MAAOhB,MACCA,aAAiBX,WAEE,uBAAfW,EAAMwB,YACAC,+BAEJzB,MAGT,MAAMF,KAAYlC,KAAKuB,iBAAiB,wBACnCW,EAAS,CACXQ,YACAe,cACAK,YAAaV,EAAgB/B,QAC7BP,QAAS8B,EACT3C,MAAOD,KAAKC,eAGb,oBAaOa,EAASC,SACjByB,EAAO,GAAE1B,EAAQoC,SAASnC,QAC3Bf,KAAKH,GAAW2C,GAAM,KACnBI,EAAmB9B,MAClB,MAAMoB,KAAYlC,KAAKuB,iBAAiB,sBACzCqB,EAAmBtD,QAAgB4C,EAAS,CACxCnB,OACAD,QAAS8B,EACT3C,MAAOD,KAAKC,MAEZ8D,OAAQ/D,KAAK+D,eAGhBlE,GAAW2C,GAAOI,SAEpB5C,KAAKH,GAAW2C,GAS3BpB,YAAYwC,OACH,MAAMlD,KAAUV,KAAKE,GAAUK,WAC5BqD,KAAQlD,SACD,SAGR,qBAkBQkD,EAAMI,OAChB,MAAM9B,KAAYlC,KAAKuB,iBAAiBqC,SAGnC1B,EAAS8B,qBAYLJ,OACT,MAAMlD,KAAUV,KAAKE,GAAUK,WACJ,mBAAjBG,EAAOkD,GAAsB,OAC9BK,EAAQjE,KAAKQ,GAAgB0D,IAAIxD,GACjCyD,EAAoBH,UAChBI,EAAgBtE,OAAOC,OAAOD,OAAOC,OAAO,GAAIiE,GAAQ,CAAEC,iBAGzDvD,EAAOkD,GAAMQ,EAApB,QAEED,GAiBlBvD,UAAUC,eACDR,GAAwBgE,KAAKxD,GAC3BA,0BAaHA,OACIA,EAAUb,KAAKK,GAAwBiE,eACrCzD,EAOd0D,eACSpE,GAAiBqE,QAAQ,eAYDrC,OACzBiB,EAAkBjB,EAClBsC,GAAc,MACb,MAAMvC,KAAYlC,KAAKuB,iBAAiB,sBACzC6B,QACWlB,EAAS,CACZpB,QAASd,KAAKc,QACdqB,SAAUiB,EACVnD,MAAOD,KAAKC,cACT+B,EACXyC,GAAc,GACTrB,eAIJqB,GACGrB,GAA8C,MAA3BA,EAAgBsB,SACnCtB,OAAkBpB,GAmBnBoB,GC/ef,MAAMuB,EAuBFjF,YAAYE,EAAU,SAQb8C,UAAYkC,aAAWC,eAAejF,EAAQ8C,gBAQ9CnC,QAAUX,EAAQW,SAAW,QAQ7B0B,aAAerC,EAAQqC,kBAQvBU,aAAe/C,EAAQ+C,aAqBhCmC,OAAOlF,SACImF,GAAgB/E,KAAKgF,UAAUpF,UAC/BmF,EAwBXC,UAAUpF,GAEFA,aAAmBoB,aACnBpB,EAAU,CACNK,MAAOL,EACPkB,QAASlB,EAAQkB,gBAGnBb,EAAQL,EAAQK,MAChBa,EAAqC,iBAApBlB,EAAQkB,QACzB,IAAItB,QAAQI,EAAQkB,SACpBlB,EAAQkB,QACRiD,EAAS,WAAYnE,EAAUA,EAAQmE,YAAS/B,EAChDiD,EAAU,IAAIxF,EAAgBO,KAAM,CAAEC,QAAOa,UAASiD,WACtDgB,EAAe/E,KAAKkF,GAAaD,EAASnE,EAASb,SAGlD,CAAC8E,EAFY/E,KAAKmF,GAAeJ,EAAcE,EAASnE,EAASb,aAIzDgF,EAASnE,EAASb,OAE7BkC,QADE8C,EAAQ5C,aAAa,mBAAoB,CAAEpC,QAAOa,mBAGpDqB,QAAiBnC,KAAKoF,QAAQtE,EAASmE,IAIlC9C,GAA8B,UAAlBA,EAASkD,WAChB,IAAI3D,eAAa,cAAe,CAAEwB,IAAKpC,EAAQoC,MAG7D,MAAOd,MACCA,aAAiBX,UACZ,MAAMS,KAAY+C,EAAQ1D,iBAAiB,sBAC5CY,QAAiBD,EAAS,CAAEE,QAAOnC,QAAOa,YACtCqB,YAKPA,QACKC,MAQT,MAAMF,KAAY+C,EAAQ1D,iBAAiB,sBAC5CY,QAAiBD,EAAS,CAAEjC,QAAOa,UAASqB,oBAEzCA,WAEU4C,EAAcE,EAASnE,EAASb,OAC7CkC,EACAC,MAEAD,QAAiB4C,EAErB,MAAO3C,cAMG6C,EAAQ5C,aAAa,oBAAqB,CAC5CpC,QACAa,UACAqB,mBAEE8C,EAAQK,cAElB,MAAOC,GACCA,aAA0B9D,QAC1BW,EAAQmD,YAGVN,EAAQ5C,aAAa,qBAAsB,CAC7CpC,QACAa,UACAqB,WACAC,MAAOA,IAEX6C,EAAQV,UACJnC,QACMA,GCtMX,MAAMoD,EAAyB,CAWlCC,gBAAiBC,OAASvD,cACE,MAApBA,EAASuC,QAAsC,IAApBvC,EAASuC,OAC7BvC,EAEJ,0BCIf,cAAyBwC,gBAQP7D,EAASmE,OAWf7C,EADAD,QAAiB8C,EAAQU,WAAW7E,OAEnCqB,MAMGA,QAAiB8C,EAAQW,iBAAiB9E,GAE9C,MAAOU,GACCA,aAAeC,QACfW,EAAQZ,OAyBfW,QACK,IAAIT,eAAa,cAAe,CAAEwB,IAAKpC,EAAQoC,IAAKd,iBAEvDD,gBC5Df,cAAwBwC,gBAQN7D,EAASmE,SASb9C,QAAiB8C,EAAQU,WAAW7E,OAYrCqB,QACK,IAAIT,eAAa,cAAe,CAAEwB,IAAKpC,EAAQoC,aAElDf,mBC3Bf,cAA2BwC,EAoBvBjF,YAAYE,EAAU,UACZA,GAGDI,KAAKO,QAAQsF,MAAMC,GAAM,oBAAqBA,UAC1CvF,QAAQwF,QAAQP,QAEpBQ,GAAyBpG,EAAQqG,uBAAyB,gBAmBrDnF,EAASmE,SACbiB,EAAO,GASPC,EAAW,OACbC,KACApG,KAAKgG,GAAwB,OACvBK,GAAEA,EAAFxF,QAAMA,GAAYb,KAAKsG,GAAmB,CAAExF,UAASoF,OAAMjB,YACjEmB,EAAYC,EACZF,EAAS9B,KAAKxD,SAEZ0F,EAAiBvG,KAAKwG,GAAmB,CAC3CJ,YACAtF,UACAoF,OACAjB,YAEJkB,EAAS9B,KAAKkC,SACRpE,QAAiB8C,EAAQrE,UAAU,gBAEtBqE,EAAQrE,UAAU6F,QAAQC,KAAKP,WAMnCI,EAR0B,QAkBpCpE,QACK,IAAIT,eAAa,cAAe,CAAEwB,IAAKpC,EAAQoC,aAElDf,EAWXmE,IAAmBxF,QAAEA,EAAFoF,KAAWA,EAAXjB,QAAiBA,QAC5BmB,QAWG,CACHvF,QAXmB,IAAI4F,SAASjC,IAQhC4B,EAAYO,YAPajB,UAKrBlB,QAAcS,EAAQU,WAAW7E,GAAjC,GAEmE,IAA9Bd,KAAKgG,GAA9C,IAIAK,GAAID,aAaaA,UAAEA,EAAFtF,QAAaA,EAAboF,KAAsBA,EAAtBjB,QAA4BA,QAC7C7C,EACAD,MAEAA,QAAiB8C,EAAQW,iBAAiB9E,GAE9C,MAAO8F,GACCA,aAAsBnF,QACtBW,EAAQwE,UAGZR,GACAS,aAAaT,IAWbhE,GAAUD,IACVA,QAAiB8C,EAAQU,WAAW7E,IAUjCqB,kBCtKf,cAA0BwC,EAYtBjF,YAAYE,EAAU,UACZA,QACDoG,GAAyBpG,EAAQqG,uBAAyB,gBASrDnF,EAASmE,OASf7C,EACAD,YAEMgE,EAAW,CACblB,EAAQlD,MAAMjB,OAEdd,KAAKgG,GAAwB,OACvBc,EAAiB7D,UAAsC,IAA9BjD,KAAKgG,IACpCG,EAAS9B,KAAKyC,MAElB3E,QAAiBsE,QAAQC,KAAKP,IACzBhE,QACK,IAAIV,MACL,wCAAEzB,KAAKgG,eAGpB,MAAOxE,GACCA,aAAeC,QACfW,EAAQZ,OAcXW,QACK,IAAIT,eAAa,cAAe,CAAEwB,IAAKpC,EAAQoC,IAAKd,iBAEvDD,2BC3Df,cAAmCwC,EAc/BjF,YAAYE,EAAU,UACZA,GAGDI,KAAKO,QAAQsF,MAAMC,GAAM,oBAAqBA,UAC1CvF,QAAQwF,QAAQP,iBAUf1E,EAASmE,SAUb8B,EAAuB9B,EAAQW,iBAAiB9E,GAASkG,OAAM,SAIhE/B,EAAQrE,UAAUmG,OAEnB3E,EADAD,QAAiB8C,EAAQU,WAAW7E,MAEpCqB,YAcIA,QAAkB4E,EAEtB,MAAOvF,GACCA,aAAeC,QACfW,EAAQZ,OAYfW,QACK,IAAIT,eAAa,cAAe,CAAEwB,IAAKpC,EAAQoC,IAAKd,iBAEvDD"}
frontend/node_modules/workbox-strategies/src/StrategyHandler.ts:381:          // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
frontend/node_modules/workbox-strategies/src/StrategyHandler.ts:499:      // TODO(philipwalton): not sure why `any` is needed. It seems like
frontend/node_modules/workbox-strategies/src/StrategyHandler.ts:525:          // TODO(philipwalton): not sure why `any` is needed. It seems like
frontend/node_modules/callsites/index.js:12:// TODO: Remove this for the next major release
frontend/node_modules/callsites/index.d.ts:90:	// TODO: Remove this for the next major release, refactor the whole definition to:
frontend/node_modules/node-forge/README.md:593:// TODO
frontend/node_modules/node-forge/README.md:605:// TODO
[2025-10-20T16:13:17] grep -R "TODO" frontend -n completed in background

[2025-10-20T16:13:47] thinking

**Stopping recursive TODO search**
[2025-10-20T16:13:50] tool kill
{
  "call_id": "call_viIC2PIdjJyK5jGkKAqw0RbW"
}
[2025-10-20T16:13:50] tool kill failed
Background job call_viIC2PIdjJyK5jGkKAqw0RbW has already completed.
[2025-10-20T16:13:52] tokens used: 130,848

[2025-10-20T16:14:18] thinking

**Summarizing key findings and confirmations**

I'll prepare a concise bullet-point list covering all requested topics with file references, confirming there are no frontend logging guard TODOs, highlighting existing debug guards, seeding env vars, test impacts, GHIN secret mismatches, and sheets validation gaps, noting that no code changes or tests were done as the environment is read-only.
[2025-10-20T16:14:19] codex

**Key Points**
- `ENABLE_TEST_ENDPOINTS` defaults to on (`backend/app/main.py:141`), so test-only FastAPI routes ship unless the env var is explicitly set false.
- The seeding helper `/simulation/test/seed-state` lives inside that flag’s block (`backend/app/main.py:4604-4724`), and backend tests call it directly (`tests/backend/test_simulation_state_endpoint.py:43-48`), so disabling the flag—or removing the helper—breaks simulation-state fixtures.
- Sunday pairing requests resolve a seed from either the explicit query or `SUNDAY_GAME_RANDOM_SEED`; bad values fall back to nondeterministic RNG with a warning (`backend/app/services/sunday_game_service.py:11-112`), and the endpoint surfaces the resolved seed for reproducibility (`backend/app/main.py:6153-6187`).
- GHIN endpoints refuse to run without `GHIN_API_USER/GHIN_API_PASS` (`backend/app/main.py:872-879`), while `GHINService` tries to log in with `GHIN_USERNAME/GHIN_PASSWORD` (`backend/app/services/ghin_service.py:33-43`), so both name pairs must be populated today or the service stays uninitialized.
- Sheet sync accepts any column layout, logging missing headers but still proceeding (`backend/app/services/sheet_integration_service.py:178-245`), and there are no dedicated tests under `tests/backend` covering this service—leaving schema validation gaps.
- Frontend logging already guards `console.debug` behind non-production checks (`frontend/src/context/SheetSyncContext.js:76-82`, `frontend/src/components/WGPAnalyticsDashboard.js:62-71`), and repository searches showed no outstanding TODOs about adding further logging guards.
[2025-10-20T16:14:23] tokens used: 133,678
