Cloud task completed: task_e_68f6daadea508330a63c25337dd362ba

Prompt:
Context: Repo: Wolf Goat Pig golf simulation. Test endpoints default disabled; /simulation/state and /simulation/test/seed-state require admin header when flag true. Current betting.feature covers doubling, carry over, ping pong counts, special rules. Need fresh examples to enrich coverage without duplicating existing ones.

Agent: Review existing Behave features in tests/bdd/behave/features and brainstorm additional Simulation betting scenarios that exercise edge cases around doubles, carry overs, wagering locks, and admin-only state endpoints. Produce concise Gherkin scenario titles, step outlines, and rationale for inclusion. Highlight any dependencies on ENABLE_TEST_ENDPOINTS or admin headers.

Desired output: List of 4-6 candidate scenarios with bullet rationale and rough Given/When/Then skeleton.

Files to consider: tests/bdd/behave/features/simulation_betting.feature, tests/bdd/behave/steps/simulation_steps.py

[Running in read-only mode - no modifications allowed]

Assistant Messages:
1. ### Candidate Behave Scenarios for Enriching Betting Coverage

1. **Scenario: Admin-only seed state rejects missing header when test endpoints enabled**
   - *Rationale*: Validates access control edge case when `ENABLE_TEST_ENDPOINTS` toggles admin protection for `/simulation/test/seed-state`, ensuring we do not assume global access across scenarios. Reinforces best practice by centralizing auth header setup in shared steps instead of duplicating inline dictionaries.
   - *Skeleton*:
     ```
     Given ENABLE_TEST_ENDPOINTS is set to "true"
     And the simulation API is available
     And I omit the admin authentication header for seed requests
     When I seed the simulation state with
       | betting.current_wager | 4 |
     Then the response code is 403
     And the betting_state remains unchanged in the subsequent GET /simulation/state call (with admin header)
     ```
   - *Dependencies*: Requires toggling `ENABLE_TEST_ENDPOINTS` and a reusable step for sending admin headers to keep things DRY.

2. **Scenario: Double request ignored when wager already redoubled and wagering closed**
   - *Rationale*: Current coverage stops at redouble success; this scenario ensures further doubling attempts are blocked when both `redoubled` and `wagering_closed` are true, guarding against runaway escalation bugs.
   - *Skeleton*:
     ```
     Given the simulation is at hole 9
     And wagering is set to closed
     And the betting state is
       | current_wager | 8 |
       | doubled       | true |
       | redoubled     | true |
       | ping_pong_count | 2 |
     When I seed the betting state with
       | current_wager | 16 |
       | redoubled     | true |
     Then the simulation state contains
       | betting_state.current_wager | 8 |
       | betting_state.redoubled     | true |
       | betting_state.ping_pong_count | 2 |
     And an error is recorded in the response payload
     ```
   - *Dependencies*: None beyond existing seeding steps; ensure shared helper asserts for immutable states to avoid duplicated checks.

3. **Scenario: Carry-over clears automatically after wager settlement**
   - *Rationale*: We have positive carry-over persistence tests, but no scenario confirming the flag resets when the wager returns to base. Captures regression risk around settlement logic.
   - *Skeleton*:
     ```
     Given the simulation is at hole 14
     And the betting state is
       | base_wager    | 2 |
       | current_wager | 8 |
       | carry_over    | true |
     When I seed the betting state with
       | current_wager | 2 |
       | carry_over    | false |
     And I refresh the simulation state
     Then the simulation state contains
       | betting_state.carry_over    | false |
       | betting_state.current_wager | 2 |
     And the carry_over history log is empty
     ```
   - *Dependencies*: Reuse existing carry-over validation helpers; avoid new ad-hoc assertions by extending shared step assertions if needed.

4. **Scenario: Wagering lock toggled mid-hole blocks new ping pong escalation**
   - *Rationale*: Tests behavior when `ping_pong_count` increments while wagering is open but should freeze once the lock engages. Ensures no drift between count and wager after lock.
   - *Skeleton*:
     ```
     Given the simulation is at hole 3
     And wagering is set to open
     And the betting state is
       | base_wager      | 1 |
       | current_wager   | 1 |
       | ping_pong_count | 0 |
       | doubled         | false |
     When I seed the betting state with
       | doubled         | true |
       | current_wager   | 2 |
       | ping_pong_count | 1 |
     And wagering is set to closed
     When I seed the betting state with
       | current_wager   | 4 |
       | ping_pong_count | 2 |
     Then the simulation state contains
       | wagering_closed             | true |
       | betting_state.current_wager | 2 |
       | betting_state.ping_pong_count | 1 |
     ```
   - *Dependencies*: None; leverage existing “wagering is set to” step to avoid duplicating lock logic.

5. **Scenario: Admin state snapshot accessible only with header when test endpoints locked**
   - *Rationale*: Complements Scenario 1 by proving `/simulation/state` remains public (when enabled) but `/simulation/test/seed-state` does not, highlighting difference and catching misconfigurations.
   - *Skeleton*:
     ```
     Given ENABLE_TEST_ENDPOINTS is set to "true"
     And the simulation API is available
     When I request the "GET" "/simulation/state" endpoint without an admin header
     Then the response code is 200
     When I request the "POST" "/simulation/test/seed-state" endpoint without an admin header
     Then the response code is 403
     And the same POST with the admin header succeeds
     ```
   - *Dependencies*: Requires a shared utility/step to inject the admin header (consider centralizing header constants in a config fixture to avoid hardcoding).

2. I'm searching for the AGENTS.md file to follow its instructions.

3. I’ll look around for the AGENTS.md file to guide me further.

4. I'll check the root directory for AGENTS.md to find the instructions.

5. It looks like there's no AGENT file, but I can check for scenario instructions. I'll look for a feature file to get context and produce a scenario list.

6. I'll look in the tests/bdd/features directory—let's see if that's the correct path.

7. I’ll check inside the tests/bdd features to see what’s there.

8. I need to find the feature file, probably under tests/bdd/features.

9. I need to check if there are AGENT instructions within the tests/bdd folder.

10. I need to check out the simulation_betting.feature file next.

11. I'll provide 4-6 scenarios with Gherkin syntax, mentioning admin header dependencies.

12. I'll brainstorm and create a list of potential scenarios, ensuring to follow DRY principles.

13. ### Candidate Behave Scenarios for Enriching Betting Coverage

1. **Scenario: Admin-only seed state rejects missing header when test endpoints enabled**
   - *Rationale*: Validates access control edge case when `ENABLE_TEST_ENDPOINTS` toggles admin protection for `/simulation/test/seed-state`, ensuring we do not assume global access across scenarios. Reinforces best practice by centralizing auth header setup in shared steps instead of duplicating inline dictionaries.
   - *Skeleton*:
     ```
     Given ENABLE_TEST_ENDPOINTS is set to "true"
     And the simulation API is available
     And I omit the admin authentication header for seed requests
     When I seed the simulation state with
       | betting.current_wager | 4 |
     Then the response code is 403
     And the betting_state remains unchanged in the subsequent GET /simulation/state call (with admin header)
     ```
   - *Dependencies*: Requires toggling `ENABLE_TEST_ENDPOINTS` and a reusable step for sending admin headers to keep things DRY.

2. **Scenario: Double request ignored when wager already redoubled and wagering closed**
   - *Rationale*: Current coverage stops at redouble success; this scenario ensures further doubling attempts are blocked when both `redoubled` and `wagering_closed` are true, guarding against runaway escalation bugs.
   - *Skeleton*:
     ```
     Given the simulation is at hole 9
     And wagering is set to closed
     And the betting state is
       | current_wager | 8 |
       | doubled       | true |
       | redoubled     | true |
       | ping_pong_count | 2 |
     When I seed the betting state with
       | current_wager | 16 |
       | redoubled     | true |
     Then the simulation state contains
       | betting_state.current_wager | 8 |
       | betting_state.redoubled     | true |
       | betting_state.ping_pong_count | 2 |
     And an error is recorded in the response payload
     ```
   - *Dependencies*: None beyond existing seeding steps; ensure shared helper asserts for immutable states to avoid duplicated checks.

3. **Scenario: Carry-over clears automatically after wager settlement**
   - *Rationale*: We have positive carry-over persistence tests, but no scenario confirming the flag resets when the wager returns to base. Captures regression risk around settlement logic.
   - *Skeleton*:
     ```
     Given the simulation is at hole 14
     And the betting state is
       | base_wager    | 2 |
       | current_wager | 8 |
       | carry_over    | true |
     When I seed the betting state with
       | current_wager | 2 |
       | carry_over    | false |
     And I refresh the simulation state
     Then the simulation state contains
       | betting_state.carry_over    | false |
       | betting_state.current_wager | 2 |
     And the carry_over history log is empty
     ```
   - *Dependencies*: Reuse existing carry-over validation helpers; avoid new ad-hoc assertions by extending shared step assertions if needed.

4. **Scenario: Wagering lock toggled mid-hole blocks new ping pong escalation**
   - *Rationale*: Tests behavior when `ping_pong_count` increments while wagering is open but should freeze once the lock engages. Ensures no drift between count and wager after lock.
   - *Skeleton*:
     ```
     Given the simulation is at hole 3
     And wagering is set to open
     And the betting state is
       | base_wager      | 1 |
       | current_wager   | 1 |
       | ping_pong_count | 0 |
       | doubled         | false |
     When I seed the betting state with
       | doubled         | true |
       | current_wager   | 2 |
       | ping_pong_count | 1 |
     And wagering is set to closed
     When I seed the betting state with
       | current_wager   | 4 |
       | ping_pong_count | 2 |
     Then the simulation state contains
       | wagering_closed             | true |
       | betting_state.current_wager | 2 |
       | betting_state.ping_pong_count | 1 |
     ```
   - *Dependencies*: None; leverage existing “wagering is set to” step to avoid duplicating lock logic.

5. **Scenario: Admin state snapshot accessible only with header when test endpoints locked**
   - *Rationale*: Complements Scenario 1 by proving `/simulation/state` remains public (when enabled) but `/simulation/test/seed-state` does not, highlighting difference and catching misconfigurations.
   - *Skeleton*:
     ```
     Given ENABLE_TEST_ENDPOINTS is set to "true"
     And the simulation API is available
     When I request the "GET" "/simulation/state" endpoint without an admin header
     Then the response code is 200
     When I request the "POST" "/simulation/test/seed-state" endpoint without an admin header
     Then the response code is 403
     And the same POST with the admin header succeeds
     ```
   - *Dependencies*: Requires a shared utility/step to inject the admin header (consider centralizing header constants in a config fixture to avoid hardcoding).

No diff available.
