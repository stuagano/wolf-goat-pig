ðŸŽ¯ ADK auto-sync aliases loaded!
ðŸ’¡ Use 'sync' to sync with upstream anytime
ðŸ’¡ Use 'synccheck' to check sync status
        }
        
    except Exception as e:
        logger.error(f"Failed to get poker state: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get poker state: {str(e)}")

# Daily Sign-up System Endpoints

@app.get("/signups/weekly", response_model=schemas.WeeklySignupView)
def get_weekly_signups(week_start: str = Query(description="YYYY-MM-DD format for Monday of the week")):
    """Get sign-ups for a rolling 7-day period starting from specified Monday."""
    try:
        db = database.SessionLocal()
        from datetime import datetime, timedelta
        
        # Parse the week start date
        start_date = datetime.strptime(week_start, '%Y-%m-%d')
        
        # Get all 7 days
        daily_summaries = []
        for i in range(7):
            current_date = start_date + timedelta(days=i)
            date_str = current_date.strftime('%Y-%m-%d')
            
            signups = db.query(models.DailySignup).filter(
                models.DailySignup.date == date_str,
                models.DailySignup.status != "cancelled"
            ).all()
            
            daily_summaries.append(schemas.DailySignupSummary(
                date=date_str,
                signups=[schemas.DailySignupResponse.from_orm(signup) for signup in signups],
                total_count=len(signups)
            ))
        
        return schemas.WeeklySignupView(
            week_start=week_start,
            daily_summaries=daily_summaries
        )
        
    except ValueError as e:
        raise HTTPException(status_code=400, detail=f"Invalid date format: {str(e)}")
    except Exception as e:
        logger.error(f"Error getting weekly signups: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get weekly signups: {str(e)}")
    finally:
        db.close()

@app.get("/signups")
def get_signups(limit: int = Query(50, description="Maximum number of signups to return")):
    """Get recent signups with basic information"""
    try:
        db = database.SessionLocal()
        
        # Get recent signups
        signups = db.query(models.DailySignup).filter(
            models.DailySignup.status != "cancelled"
        ).order_by(models.DailySignup.created_at.desc()).limit(limit).all()
        
        return {
            "signups": [
                {
                    "id": signup.id,
                    "date": signup.date,
                    "player_name": signup.player_name,
                    "player_profile_id": signup.player_profile_id,
                    "status": signup.status,
                    "signup_time": signup.signup_time,
                    "preferred_start_time": signup.preferred_start_time,
                    "notes": signup.notes,
                    "created_at": signup.created_at if signup.created_at else None
                }
                for signup in signups
            ],
            "total": len(signups)
        }
        
    except Exception as e:
        logger.error(f"Error getting signups: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get signups: {str(e)}")
    finally:
        db.close()

@app.post("/signups", response_model=schemas.DailySignupResponse)
def create_signup(signup: schemas.DailySignupCreate):
    """Create a daily sign-up for a player."""
    try:
        db = database.SessionLocal()
        
        # Check if player already signed up for this date
        existing = db.query(models.DailySignup).filter(
            models.DailySignup.date == signup.date,
            models.DailySignup.player_profile_id == signup.player_profile_id,
            models.DailySignup.status != "cancelled"
        ).first()
        
        if existing:
            raise HTTPException(status_code=400, detail="Player already signed up for this date")
        
        # Create new signup
        db_signup = models.DailySignup(
            date=signup.date,
            player_profile_id=signup.player_profile_id,
            player_name=signup.player_name,
            signup_time=datetime.now().isoformat(),
            preferred_start_time=signup.preferred_start_time,
            notes=signup.notes,
            status="signed_up",
            created_at=datetime.now().isoformat(),
            updated_at=datetime.now().isoformat()
        )
        
        db.add(db_signup)
        db.commit()
        db.refresh(db_signup)

        logger.info(f"Created signup for player {signup.player_name} on {signup.date}")

        # Mirror the signup to the legacy CGI sheet when configured.
        try:
            legacy_service = get_legacy_signup_service()
            legacy_service.sync_signup_created(db_signup)
        except Exception:
            logger.exception(
                "Legacy signup sync failed for create id=%s", db_signup.id
            )

        return schemas.DailySignupResponse.from_orm(db_signup)
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        logger.error(f"Error creating signup: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to create signup: {str(e)}")
    finally:
        db.close()

@app.put("/signups/{signup_id}", response_model=schemas.DailySignupResponse)
def update_signup(signup_id: int, signup_update: schemas.DailySignupUpdate):
    """Update a daily sign-up."""
    try:
        db = database.SessionLocal()
        
        db_signup = db.query(models.DailySignup).filter(models.DailySignup.id == signup_id).first()
        if not db_signup:
            raise HTTPException(status_code=404, detail="Sign-up not found")
        
        # Update fields
        if signup_update.preferred_start_time is not None:
            db_signup.preferred_start_time = signup_update.preferred_start_time
        if signup_update.notes is not None:
            db_signup.notes = signup_update.notes
        if signup_update.status is not None:
            db_signup.status = signup_update.status
            
        db_signup.updated_at = datetime.now().isoformat()
        
        db.commit()
        db.refresh(db_signup)

        logger.info(f"Updated signup {signup_id}")

        try:
            legacy_service = get_legacy_signup_service()
            legacy_service.sync_signup_updated(db_signup)
        except Exception:
            logger.exception(
                "Legacy signup sync failed for update id=%s", db_signup.id
            )

        return schemas.DailySignupResponse.from_orm(db_signup)
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        logger.error(f"Error updating signup {signup_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to update signup: {str(e)}")
    finally:
        db.close()

@app.delete("/signups/{signup_id}")
def cancel_signup(signup_id: int):
    """Cancel a daily sign-up."""
    try:
        db = database.SessionLocal()
        
        db_signup = db.query(models.DailySignup).filter(models.DailySignup.id == signup_id).first()
        if not db_signup:
            raise HTTPException(status_code=404, detail="Sign-up not found")
        
        db_signup.status = "cancelled"
        db_signup.updated_at = datetime.now().isoformat()
        
        db.commit()

        logger.info(f"Cancelled signup {signup_id}")

        try:
            legacy_service = get_legacy_signup_service()
            legacy_service.sync_signup_cancelled(db_signup)
        except Exception:
            logger.exception(
                "Legacy signup sync failed for cancel id=%s", db_signup.id
            )

        return {"message": "Sign-up cancelled successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        logger.error(f"Error cancelling signup {signup_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to cancel signup: {str(e)}")
    finally:
        db.close()

# Daily Message Board Endpoints

@app.get("/messages/daily", response_model=List[schemas.DailyMessageResponse])
def get_daily_messages(date: str = Query(description="YYYY-MM-DD format")):
    """Get all messages for a specific date."""
    try:
        db = database.SessionLocal()
        
        messages = db.query(models.DailyMessage).filter(
            models.DailyMessage.date == date,
            models.DailyMessage.is_active == 1
        ).order_by(models.DailyMessage.message_time).all()
        
        return [schemas.DailyMessageResponse.from_orm(message) for message in messages]
        
    except Exception as e:
        logger.error(f"Error getting messages for date {date}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get messages: {str(e)}")
    finally:
        db.close()

@app.get("/signups/weekly-with-messages", response_model=schemas.WeeklySignupWithMessagesView)
def get_weekly_signups_with_messages(week_start: str = Query(description="YYYY-MM-DD format for Monday of the week")):
    """Get sign-ups and messages for a rolling 7-day period starting from specified Monday."""
    try:
        db = database.SessionLocal()
        from datetime import datetime, timedelta
        
        # Parse the week start date
        start_date = datetime.strptime(week_start, '%Y-%m-%d')
        
        # Get all 7 days
        daily_summaries = []
        for i in range(7):
            current_date = start_date + timedelta(days=i)
            date_str = current_date.strftime('%Y-%m-%d')
            
            # Get signups
            signups = db.query(models.DailySignup).filter(
                models.DailySignup.date == date_str,
                models.DailySignup.status != "cancelled"
            ).all()
            
            # Get messages
            messages = db.query(models.DailyMessage).filter(
                models.DailyMessage.date == date_str,
                models.DailyMessage.is_active == 1
            ).order_by(models.DailyMessage.message_time).all()
            
            daily_summaries.append(schemas.DailySignupWithMessages(
                date=date_str,
                signups=[schemas.DailySignupResponse.from_orm(signup) for signup in signups],
                total_count=len(signups),
                messages=[schemas.DailyMessageResponse.from_orm(message) for message in messages],
                message_count=len(messages)
            ))
        
        return schemas.WeeklySignupWithMessagesView(
            week_start=week_start,
            daily_summaries=daily_summaries
        )
        
    except ValueError as e:
        raise HTTPException(status_code=400, detail=f"Invalid date format: {str(e)}")
    except Exception as e:
        logger.error(f"Error getting weekly data with messages: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get weekly data: {str(e)}")
    finally:
        db.close()

@app.post("/messages", response_model=schemas.DailyMessageResponse)
def create_message(message: schemas.DailyMessageCreate):
    """Create a new daily message."""
    try:
        db = database.SessionLocal()
        from datetime import datetime
        
        # Create new message
        db_message = models.DailyMessage(
            date=message.date,
            player_profile_id=message.player_profile_id or 1,  # Default player if not provided
            player_name=message.player_name or "Anonymous",
            message=message.message,
            message_time=datetime.now().isoformat(),
            is_active=1,
            created_at=datetime.now().isoformat(),
            updated_at=datetime.now().isoformat()
        )
        
        db.add(db_message)
        db.commit()
        db.refresh(db_message)
        
        logger.info(f"Created message {db_message.id} for date {message.date}")
        return schemas.DailyMessageResponse.from_orm(db_message)
        
    except Exception as e:
        db.rollback()
        logger.error(f"Error creating message: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to create message: {str(e)}")
    finally:
        db.close()

@app.put("/messages/{message_id}", response_model=schemas.DailyMessageResponse)
def update_message(message_id: int, message_update: schemas.DailyMessageUpdate):
    """Update an existing message."""
    try:
        db = database.SessionLocal()
        from datetime import datetime
        
        db_message = db.query(models.DailyMessage).filter(models.DailyMessage.id == message_id).first()
        if not db_message:
            raise HTTPException(status_code=404, detail="Message not found")
        
        if message_update.message is not None:
            db_message.message = message_update.message
            db_message.updated_at = datetime.now().isoformat()
        
        db.commit()
        db.refresh(db_message)
        
        logger.info(f"Updated message {message_id}")
        return schemas.DailyMessageResponse.from_orm(db_message)
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        logger.error(f"Error updating message {message_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to update message: {str(e)}")
    finally:
        db.close()

@app.delete("/messages/{message_id}")
def delete_message(message_id: int):
    """Delete (deactivate) a message."""
    try:
        db = database.SessionLocal()
        from datetime import datetime
        
        db_message = db.query(models.DailyMessage).filter(models.DailyMessage.id == message_id).first()
        if not db_message:
            raise HTTPException(status_code=404, detail="Message not found")
        
        db_message.is_active = 0
        db_message.updated_at = datetime.now().isoformat()
        
        db.commit()
        
        logger.info(f"Deleted message {message_id}")
        return {"message": "Message deleted successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        db.rollback()
        logger.error(f"Error deleting message {message_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to delete message: {str(e)}")
    finally:
        db.close()

# Player Availability Endpoints

@app.get("/players/me/availability", response_model=List[schemas.PlayerAvailabilityResponse])
async def get_my_availability(current_user: models.PlayerProfile = Depends(get_current_user)):
    """Get current user's weekly availability."""
    try:
        db = database.SessionLocal()
        
        availability = db.query(models.PlayerAvailability).filter(
            models.PlayerAvailability.player_profile_id == current_user.id
        ).all()
        
        return [schemas.PlayerAvailabilityResponse.from_orm(a) for a in availability]
        
    except Exception as e:
        logger.error(f"Error getting availability for user {current_user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get availability: {str(e)}")
    finally:
        db.close()

@app.post("/players/me/availability", response_model=schemas.PlayerAvailabilityResponse)
async def set_my_availability(
    availability: schemas.PlayerAvailabilityCreate,
    current_user: models.PlayerProfile = Depends(get_current_user)
):
    """Set or update current user's availability for a specific day."""
    try:
        db = database.SessionLocal()
        
        # Override the player_profile_id with the current user's ID
        availability.player_profile_id = current_user.id
        
        # Check if availability already exists for this day
        existing = db.query(models.PlayerAvailability).filter(
            models.PlayerAvailability.player_profile_id == current_user.id,
            models.PlayerAvailability.day_of_week == availability.day_of_week
        ).first()
        
        if existing:
            # Update existing
            existing.available_from_time = availability.available_from_time
            existing.available_to_time = availability.available_to_time
            existing.is_available = availability.is_available
            existing.notes = availability.notes
            existing.updated_at = datetime.now().isoformat()
            
            db.commit()
            db.refresh(existing)
            
            logger.info(f"Updated availability for user {current_user.id}, day {availability.day_of_week}")
            return schemas.PlayerAvailabilityResponse.from_orm(existing)
        else:
            # Create new
            db_availability = models.PlayerAvailability(
                player_profile_id=current_user.id,
                day_of_week=availability.day_of_week,
                available_from_time=availability.available_from_time,
                available_to_time=availability.available_to_time,
                is_available=availability.is_available,
                notes=availability.notes,
                created_at=datetime.now().isoformat(),
                updated_at=datetime.now().isoformat()
            )
            
            db.add(db_availability)
            db.commit()
            db.refresh(db_availability)
            
            logger.info(f"Created availability for user {current_user.id}, day {availability.day_of_week}")
            return schemas.PlayerAvailabilityResponse.from_orm(db_availability)
        
    except Exception as e:
        db.rollback()
        logger.error(f"Error setting availability for user {current_user.id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to set availability: {str(e)}")
    finally:
        db.close()

@app.get("/players/{player_id}/availability", response_model=List[schemas.PlayerAvailabilityResponse])
def get_player_availability(player_id: int):
    """Get a player's weekly availability."""
    try:
        db = database.SessionLocal()
        
        availability = db.query(models.PlayerAvailability).filter(
            models.PlayerAvailability.player_profile_id == player_id
        ).order_by(models.PlayerAvailability.day_of_week).all()
        
        return [schemas.PlayerAvailabilityResponse.from_orm(avail) for avail in availability]
        
    except Exception as e:
        logger.error(f"Error getting availability for player {player_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get availability: {str(e)}")
    finally:
        db.close()

@app.get("/players/availability/all", response_model=List[Dict])
def get_all_players_availability():
    """Get all players' weekly availability with their names."""
    try:
        db = database.SessionLocal()
        
        # Get all players with their availability
        players_with_availability = db.query(models.PlayerProfile).all()
        
        result = []
        for player in players_with_availability:
            player_data = {
                "player_id": player.id,
                "player_name": player.name,
                "email": player.email,
                "availability": []
            }
            
            # Get this player's availability
            availability = db.query(models.PlayerAvailability).filter(
                models.PlayerAvailability.player_profile_id == player.id
            ).all()
            
            for avail in availability:
                player_data["availability"].append({
                    "day_of_week": avail.day_of_week,
                    "is_available": avail.is_available,
                    "available_from_time": avail.available_from_time,
                    "available_to_time": avail.available_to_time,
                    "notes": avail.notes
                })
            
            result.append(player_data)
        
        return result
        
    except Exception as e:
        logger.error(f"Error getting all players availability: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get availability: {str(e)}")
    finally:
        db.close()

@app.post("/players/{player_id}/availability", response_model=schemas.PlayerAvailabilityResponse)
def set_player_availability(player_id: int, availability: schemas.PlayerAvailabilityCreate):
    """Set or update a player's availability for a specific day."""
    try:
        db = database.SessionLocal()
        
        # Check if availability already exists for this day
        existing = db.query(models.PlayerAvailability).filter(
            models.PlayerAvailability.player_profile_id == player_id,
            models.PlayerAvailability.day_of_week == availability.day_of_week
        ).first()
        
        if existing:
            # Update existing
            existing.available_from_time = availability.available_from_time
            existing.available_to_time = availability.available_to_time
            existing.is_available = availability.is_available
            existing.notes = availability.notes
            existing.updated_at = datetime.now().isoformat()
            
            db.commit()
            db.refresh(existing)
            
            logger.info(f"Updated availability for player {player_id}, day {availability.day_of_week}")
            return schemas.PlayerAvailabilityResponse.from_orm(existing)
        else:
            # Create new
            db_availability = models.PlayerAvailability(
                player_profile_id=player_id,
                day_of_week=availability.day_of_week,
                available_from_time=availability.available_from_time,
                available_to_time=availability.available_to_time,
                is_available=availability.is_available,
                notes=availability.notes,
                created_at=datetime.now().isoformat(),
                updated_at=datetime.now().isoformat()
            )
            
            db.add(db_availability)
            db.commit()
            db.refresh(db_availability)
            
            logger.info(f"Created availability for player {player_id}, day {availability.day_of_week}")
            return schemas.PlayerAvailabilityResponse.from_orm(db_availability)
        
    except Exception as e:
        db.rollback()
        logger.error(f"Error setting availability for player {player_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to set availability: {str(e)}")
    finally:
        db.close()

# Team Formation Helpers & Endpoints


def _get_active_signups_for_date(db: Session, date: str) -> List[models.DailySignup]:
    """Fetch non-cancelled signups for the requested date."""
    return db.query(models.DailySignup).filter(
        models.DailySignup.date == date,
        models.DailySignup.status != "cancelled"
    ).all()


def _build_player_payload(
    signups: List[models.DailySignup],
    *,
    include_handicap: bool = False,
    db: Optional[Session] = None
) -> List[Dict[str, Any]]:
    """Convert signup records into the player dictionaries used by formation services."""
    if include_handicap and db is None:
        raise ValueError("Database session is required when include_handicap=True")

    players: List[Dict[str, Any]] = []
    handicap_lookup: Dict[int, float] = {}

    if include_handicap:
        profile_ids = [s.player_profile_id for s in signups if s.player_profile_id is not None]
        if profile_ids:
            profiles = db.query(models.PlayerProfile).filter(
                models.PlayerProfile.id.in_(profile_ids)
            ).all()
            handicap_lookup = {profile.id: profile.handicap for profile in profiles}

    for signup in signups:
        player_data: Dict[str, Any] = {
            "id": signup.id,
            "player_profile_id": signup.player_profile_id,
            "player_name": signup.player_name,
            "preferred_start_time": signup.preferred_start_time,
            "notes": signup.notes,
            "signup_time": signup.signup_time
        }

        if include_handicap:
            player_data["handicap"] = handicap_lookup.get(signup.player_profile_id, 18.0)

        players.append(player_data)

    return players


@app.post("/signups/{date}/team-formation/random")
def generate_random_teams_for_date(
    date: str = Path(description="Date in YYYY-MM-DD format"),
    seed: Optional[int] = Query(None, description="Random seed for reproducible results"),
    max_teams: Optional[int] = Query(None, description="Maximum number of teams to create")
):
    """Generate random 4-player teams from players signed up for a specific date."""
    try:
        db = database.SessionLocal()

        # Get all signups for the specified date
        signups = _get_active_signups_for_date(db, date)
        
        if len(signups) < 4:
            raise HTTPException(
                status_code=400, 
                detail=f"Not enough players signed up for {date}. Need at least 4 players, found {len(signups)}"
            )
        
        # Convert signups to player dictionaries
        players = _build_player_payload(signups)
        
        # Generate random teams
        teams = TeamFormationService.generate_random_teams(
            players=players,
            seed=seed,
            max_teams=max_teams
        )
        
        # Create summary
        summary = TeamFormationService.create_team_summary(teams)
        summary["date"] = date
        summary["total_signups"] = len(signups)
        
        # Validate results
        validation = TeamFormationService.validate_team_formation(teams)
        
        logger.info(f"Generated {len(teams)} random teams for date {date}")
        
        return {
            "summary": summary,
            "teams": teams,
            "validation": validation,
            "remaining_players": len(signups) % 4
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating random teams for date {date}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to generate teams: {str(e)}")
    finally:
        db.close()

@app.post("/signups/{date}/team-formation/balanced")
def generate_balanced_teams_for_date(
    date: str = Path(description="Date in YYYY-MM-DD format"),
    seed: Optional[int] = Query(None, description="Random seed for reproducible results")
):
    """Generate skill-balanced 4-player teams from players signed up for a specific date."""
    try:
        db = database.SessionLocal()

        # Get all signups for the specified date
        signups = _get_active_signups_for_date(db, date)
        
        if len(signups) < 4:
            raise HTTPException(
                status_code=400,
                detail=f"Not enough players signed up for {date}. Need at least 4 players, found {len(signups)}"
            )
        
        # Get player profiles with handicap information
        players = _build_player_payload(signups, include_handicap=True, db=db)
        
        # Generate balanced teams
        teams = TeamFormationService.generate_balanced_teams(
            players=players,
            skill_key="handicap",
            seed=seed
        )
        
        # Create summary
        summary = TeamFormationService.create_team_summary(teams)
        summary["date"] = date
        summary["total_signups"] = len(signups)
        
        # Validate results
        validation = TeamFormationService.validate_team_formation(teams)
        
        logger.info(f"Generated {len(teams)} balanced teams for date {date}")
        
        return {
            "summary": summary,
            "teams": teams,
            "validation": validation,
            "remaining_players": len(signups) % 4
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating balanced teams for date {date}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to generate balanced teams: {str(e)}")
    finally:
        db.close()

@app.post("/signups/{date}/team-formation/rotations")
def generate_team_rotations_for_date(
    date: str = Path(description="Date in YYYY-MM-DD format"),
    num_rotations: int = Query(3, description="Number of different team rotations to create"),
    seed: Optional[int] = Query(None, description="Random seed for reproducible results")
):
    """Generate multiple team rotation options for variety throughout the day."""
    try:
        db = database.SessionLocal()

        # Get all signups for the specified date
        signups = _get_active_signups_for_date(db, date)
        
        if len(signups) < 4:
            raise HTTPException(
                status_code=400,
                detail=f"Not enough players signed up for {date}. Need at least 4 players, found {len(signups)}"
            )
        
        # Convert signups to player dictionaries
        players = _build_player_payload(signups)
        
        # Generate team rotations
        rotations = TeamFormationService.create_team_pairings_with_rotations(
            players=players,
            num_rotations=num_rotations,
            seed=seed
        )
        
        logger.info(f"Generated {len(rotations)} team rotations for date {date}")
        
        return {
            "date": date,
            "total_signups": len(signups),
            "num_rotations": len(rotations),
            "rotations": rotations
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating team rotations for date {date}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to generate rotations: {str(e)}")
    finally:
        db.close()


@app.post("/signups/{date}/sunday-game/pairings")
def generate_sunday_game_pairings(
    date: str = Path(description="Date in YYYY-MM-DD format"),
    num_rotations: int = Query(3, description="Number of Sunday pairing options to generate"),
    seed: Optional[int] = Query(None, description="Override random seed for reproducible results")
):
    """Generate randomized Sunday game pairings with optional deterministic seeding."""
    try:
        db = database.SessionLocal()

        signups = _get_active_signups_for_date(db, date)

        if len(signups) < 4:
            raise HTTPException(
                status_code=400,
                detail=f"Not enough players signed up for {date}. Need at least 4 players, found {len(signups)}"
            )

        players = _build_player_payload(signups)

        pairing_result = generate_sunday_pairings(
            players,
            num_rotations=num_rotations,
            seed=seed
        )

        return {
            "date": date,
            "total_signups": len(signups),
            "player_count": pairing_result["player_count"],
            "pairing_sets_available": pairing_result["total_rotations"],
            "selected_rotation": pairing_result["selected_rotation"],
            "rotations": pairing_result["rotations"],
            "random_seed": pairing_result["random_seed"],
            "remaining_players": pairing_result["remaining_players"]
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating Sunday game pairings for {date}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to generate Sunday pairings: {str(e)}")
    finally:
        db.close()

@app.get("/signups/{date}/players")
def get_players_for_date(date: str = Path(description="Date in YYYY-MM-DD format")):
    """Get all players signed up for a specific date."""
    try:
        db = database.SessionLocal()
        
        # Get all signups for the specified date
        signups = db.query(models.DailySignup).filter(
            models.DailySignup.date == date,
            models.DailySignup.status != "cancelled"
        ).all()
        
        players = []
        for signup in signups:
            # Get player profile for additional info
            player_profile = db.query(models.PlayerProfile).filter(
                models.PlayerProfile.id == signup.player_profile_id
            ).first()
            
            player_data = {
                "signup_id": signup.id,
                "player_profile_id": signup.player_profile_id,
                "player_name": signup.player_name,
                "preferred_start_time": signup.preferred_start_time,
                "notes": signup.notes,
                "signup_time": signup.signup_time,
                "handicap": player_profile.handicap if player_profile else None,
                "email": player_profile.email if player_profile else None
            }
            players.append(player_data)
        
        return {
            "date": date,
            "total_players": len(players),
            "players": players,
            "can_form_teams": len(players) >= 4,
            "max_complete_teams": len(players) // 4,
            "remaining_players": len(players) % 4
        }
        
    except Exception as e:
        logger.error(f"Error getting players for date {date}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get players: {str(e)}")
    finally:
        db.close()

# Email Preferences Endpoints

@app.get("/players/{player_id}/email-preferences", response_model=schemas.EmailPreferencesResponse)
def get_email_preferences(player_id: int):
    """Get a player's email preferences."""
    try:
        db = database.SessionLocal()
        
        preferences = db.query(models.EmailPreferences).filter(
            models.EmailPreferences.player_profile_id == player_id
        ).first()
        
        if not preferences:
            # Create default preferences
            preferences = models.EmailPreferences(
                player_profile_id=player_id,
                created_at=datetime.now().isoformat(),
