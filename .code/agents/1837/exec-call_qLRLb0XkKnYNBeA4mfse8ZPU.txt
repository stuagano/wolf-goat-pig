ðŸŽ¯ ADK auto-sync aliases loaded!
ðŸ’¡ Use 'sync' to sync with upstream anytime
ðŸ’¡ Use 'synccheck' to check sync status
Binary file ./node_modules/.cache/default-development/4.pack matches
Binary file ./node_modules/.cache/default-development/8.pack matches
Binary file ./node_modules/.cache/default-development/3.pack matches
Binary file ./node_modules/.cache/default-development/1.pack matches
Binary file ./node_modules/.cache/default-development/11.pack matches
Binary file ./node_modules/.cache/default-development/7.pack matches
Binary file ./node_modules/.cache/default-development/6.pack matches
./node_modules/.cache/babel-loader/75cefdc93a1e363837121cee254cf512cf4a8724ff3c321b7baf8ab80f3f9ab8.json:1:{"ast":null,"code":"import{useState,useEffect,useCallback}from'react';/**\n * usePlayerProfile - Custom hook for player profile management\n * \n * Features:\n * - Profile selection and persistence\n * - Local storage integration\n * - Profile statistics caching\n * - Real-time profile updates\n * - Error handling and loading states\n */const usePlayerProfile=()=>{var _profileStatistics$se;const[selectedProfile,setSelectedProfile]=useState(null);const[profiles,setProfiles]=useState([]);const[profileStatistics,setProfileStatistics]=useState({});const[loading,setLoading]=useState(false);const[error,setError]=useState(null);const[syncStatus,setSyncStatus]=useState('idle');// 'idle', 'syncing', 'success', 'error'\n// Storage keys\nconst STORAGE_KEYS={SELECTED_PROFILE:'wgp_selected_profile',PROFILES_CACHE:'wgp_profiles_cache',STATISTICS_CACHE:'wgp_statistics_cache',LAST_SYNC:'wgp_last_sync'};// Load initial data on mount\nuseEffect(()=>{loadInitialData();},[loadInitialData]);// Sync with server periodically\nuseEffect(()=>{const interval=setInterval(()=>{const lastSync=localStorage.getItem(STORAGE_KEYS.LAST_SYNC);const now=Date.now();const fiveMinutes=5*60*1000;// Sync if more than 5 minutes since last sync\nif(!lastSync||now-parseInt(lastSync)>fiveMinutes){syncWithServer();}},60000);// Check every minute\nreturn()=>clearInterval(interval);},[STORAGE_KEYS.LAST_SYNC,syncWithServer]);const loadInitialData=async()=>{try{setLoading(true);// Load from localStorage first for immediate UI\nloadFromLocalStorage();// Then sync with server\nawait syncWithServer();}catch(err){console.error('Error loading initial data:',err);setError('Failed to load player profiles');}finally{setLoading(false);}};const loadFromLocalStorage=()=>{try{// Load selected profile\nconst savedProfile=localStorage.getItem(STORAGE_KEYS.SELECTED_PROFILE);if(savedProfile){setSelectedProfile(JSON.parse(savedProfile));}// Load profiles cache\nconst cachedProfiles=localStorage.getItem(STORAGE_KEYS.PROFILES_CACHE);if(cachedProfiles){setProfiles(JSON.parse(cachedProfiles));}// Load statistics cache\nconst cachedStats=localStorage.getItem(STORAGE_KEYS.STATISTICS_CACHE);if(cachedStats){setProfileStatistics(JSON.parse(cachedStats));}}catch(err){console.error('Error loading from localStorage:',err);// Clear corrupted data\nObject.values(STORAGE_KEYS).forEach(key=>{localStorage.removeItem(key);});}};const saveToLocalStorage=(key,data)=>{try{localStorage.setItem(key,JSON.stringify(data));}catch(err){console.error('Error saving to localStorage:',err);}};const syncWithServer=useCallback(async()=>{try{setSyncStatus('syncing');// Fetch latest profiles from server\nconst response=await fetch('/api/players');if(!response.ok){throw new Error('Failed to fetch profiles from server');}const serverProfiles=await response.json();setProfiles(serverProfiles);saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE,serverProfiles);// Update selected profile if it exists on server\nif(selectedProfile){const updatedProfile=serverProfiles.find(p=>p.id===selectedProfile.id);if(updatedProfile){setSelectedProfile(updatedProfile);saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE,updatedProfile);}}// Mark last sync time\nlocalStorage.setItem(STORAGE_KEYS.LAST_SYNC,Date.now().toString());setSyncStatus('success');// Clear sync status after 2 seconds\nsetTimeout(()=>setSyncStatus('idle'),2000);}catch(err){console.error('Error syncing with server:',err);setSyncStatus('error');// Clear error status after 5 seconds\nsetTimeout(()=>setSyncStatus('idle'),5000);}},[selectedProfile]);const selectProfile=useCallback(async profile=>{try{setSelectedProfile(profile);saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE,profile);// Load statistics for the selected profile\nawait loadProfileStatistics(profile.id);// Update last played on server\nawait updateLastPlayed(profile.id);}catch(err){console.error('Error selecting profile:',err);setError('Failed to select profile');}},[loadProfileStatistics,updateLastPlayed,STORAGE_KEYS.SELECTED_PROFILE]);const createProfile=useCallback(async profileData=>{try{setLoading(true);setError(null);const response=await fetch('/api/players',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(profileData)});if(!response.ok){const errorData=await response.json();throw new Error(errorData.detail||'Failed to create profile');}const newProfile=await response.json();// Update local state\nconst updatedProfiles=[...profiles,newProfile];setProfiles(updatedProfiles);saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE,updatedProfiles);// Auto-select the new profile\nawait selectProfile(newProfile);return newProfile;}catch(err){console.error('Error creating profile:',err);setError(err.message);throw err;}finally{setLoading(false);}},[profiles,selectProfile,STORAGE_KEYS.PROFILES_CACHE]);const updateProfile=useCallback(async(profileId,updateData)=>{try{setLoading(true);setError(null);const response=await fetch(`/api/players/${profileId}`,{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify(updateData)});if(!response.ok){const errorData=await response.json();throw new Error(errorData.detail||'Failed to update profile');}const updatedProfile=await response.json();// Update local state\nconst updatedProfiles=profiles.map(p=>p.id===profileId?updatedProfile:p);setProfiles(updatedProfiles);saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE,updatedProfiles);// Update selected profile if it's the one being updated\nif(selectedProfile&&selectedProfile.id===profileId){setSelectedProfile(updatedProfile);saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE,updatedProfile);}return updatedProfile;}catch(err){console.error('Error updating profile:',err);setError(err.message);throw err;}finally{setLoading(false);}},[profiles,selectedProfile,STORAGE_KEYS.PROFILES_CACHE,STORAGE_KEYS.SELECTED_PROFILE]);const deleteProfile=useCallback(async profileId=>{try{setLoading(true);setError(null);const response=await fetch(`/api/players/${profileId}`,{method:'DELETE'});if(!response.ok){throw new Error('Failed to delete profile');}// Update local state\nconst updatedProfiles=profiles.filter(p=>p.id!==profileId);setProfiles(updatedProfiles);saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE,updatedProfiles);// Clear selected profile if it was deleted\nif(selectedProfile&&selectedProfile.id===profileId){setSelectedProfile(null);localStorage.removeItem(STORAGE_KEYS.SELECTED_PROFILE);}// Remove from statistics cache\nconst updatedStats={...profileStatistics};delete updatedStats[profileId];setProfileStatistics(updatedStats);saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE,updatedStats);}catch(err){console.error('Error deleting profile:',err);setError(err.message);throw err;}finally{setLoading(false);}},[profiles,selectedProfile,profileStatistics,STORAGE_KEYS.PROFILES_CACHE,STORAGE_KEYS.SELECTED_PROFILE,STORAGE_KEYS.STATISTICS_CACHE]);const loadProfileStatistics=useCallback(async profileId=>{try{// Return cached statistics if available and recent\nconst cached=profileStatistics[profileId];if(cached&&Date.now()-cached.loadedAt<300000){// 5 minutes\nreturn cached.data;}const response=await fetch(`/api/players/${profileId}/statistics`);if(!response.ok){// Statistics might not exist for new profiles\nreturn null;}const stats=await response.json();// Cache the statistics\nconst updatedStats={...profileStatistics,[profileId]:{data:stats,loadedAt:Date.now()}};setProfileStatistics(updatedStats);saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE,updatedStats);return stats;}catch(err){console.error('Error loading profile statistics:',err);return null;}},[profileStatistics,STORAGE_KEYS.STATISTICS_CACHE]);const updateLastPlayed=useCallback(async profileId=>{try{await fetch(`/api/players/${profileId}`,{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify({last_played:new Date().toISOString()})});}catch(err){console.error('Error updating last played:',err);// Don't throw - this is not critical\n}},[STORAGE_KEYS.LAST_SYNC]);const recordGameResult=useCallback(async gameResult=>{try{const response=await fetch('/api/game-results',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(gameResult)});if(!response.ok){const errorData=await response.json();throw new Error(errorData.detail||'Failed to record game result');}const result=await response.json();// Invalidate cached statistics for the player\nconst updatedStats={...profileStatistics};delete updatedStats[gameResult.player_profile_id];setProfileStatistics(updatedStats);saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE,updatedStats);return result;}catch(err){console.error('Error recording game result:',err);setError(err.message);throw err;}},[profileStatistics,STORAGE_KEYS.STATISTICS_CACHE]);const getProfileById=useCallback(profileId=>{return profiles.find(p=>p.id===profileId);},[profiles]);const getProfileByName=useCallback(name=>{return profiles.find(p=>p.name.toLowerCase()===name.toLowerCase());},[profiles]);const clearError=useCallback(()=>{setError(null);},[]);const refreshProfiles=useCallback(async()=>{await syncWithServer();},[syncWithServer]);// Export/Import functionality\nconst exportProfileData=useCallback(async profileId=>{try{const profile=getProfileById(profileId);const statistics=await loadProfileStatistics(profileId);const exportData={profile,statistics,exportedAt:new Date().toISOString(),version:'1.0'};// Create and download file\nconst blob=new Blob([JSON.stringify(exportData,null,2)],{type:'application/json'});const url=URL.createObjectURL(blob);const link=document.createElement('a');link.href=url;link.download=`wgp-profile-${profile.name}-${new Date().toISOString().split('T')[0]}.json`;document.body.appendChild(link);link.click();document.body.removeChild(link);URL.revokeObjectURL(url);}catch(err){console.error('Error exporting profile data:',err);setError('Failed to export profile data');}},[getProfileById,loadProfileStatistics,selectedProfile]);// Check if profile exists locally\nconst hasProfiles=profiles.length>0;const hasSelectedProfile=selectedProfile!==null;// Get current profile statistics\nconst currentProfileStats=selectedProfile?(_profileStatistics$se=profileStatistics[selectedProfile.id])===null||_profileStatistics$se===void 0?void 0:_profileStatistics$se.data:null;return{// State\nselectedProfile,profiles,profileStatistics:currentProfileStats,loading,error,syncStatus,hasProfiles,hasSelectedProfile,// Actions\nselectProfile,createProfile,updateProfile,deleteProfile,loadProfileStatistics,recordGameResult,refreshProfiles,exportProfileData,clearError,// Utilities\ngetProfileById,getProfileByName,syncWithServer};};export default usePlayerProfile;","map":{"version":3,"names":["useState","useEffect","useCallback","usePlayerProfile","_profileStatistics$se","selectedProfile","setSelectedProfile","profiles","setProfiles","profileStatistics","setProfileStatistics","loading","setLoading","error","setError","syncStatus","setSyncStatus","STORAGE_KEYS","SELECTED_PROFILE","PROFILES_CACHE","STATISTICS_CACHE","LAST_SYNC","loadInitialData","interval","setInterval","lastSync","localStorage","getItem","now","Date","fiveMinutes","parseInt","syncWithServer","clearInterval","loadFromLocalStorage","err","console","savedProfile","JSON","parse","cachedProfiles","cachedStats","Object","values","forEach","key","removeItem","saveToLocalStorage","data","setItem","stringify","response","fetch","ok","Error","serverProfiles","json","updatedProfile","find","p","id","toString","setTimeout","selectProfile","profile","loadProfileStatistics","updateLastPlayed","createProfile","profileData","method","headers","body","errorData","detail","newProfile","updatedProfiles","message","updateProfile","profileId","updateData","map","deleteProfile","filter","updatedStats","cached","loadedAt","stats","last_played","toISOString","recordGameResult","gameResult","result","player_profile_id","getProfileById","getProfileByName","name","toLowerCase","clearError","refreshProfiles","exportProfileData","statistics","exportData","exportedAt","version","blob","Blob","type","url","URL","createObjectURL","link","document","createElement","href","download","split","appendChild","click","removeChild","revokeObjectURL","hasProfiles","length","hasSelectedProfile","currentProfileStats"],"sources":["/Users/stuartgano/Documents/wolf-goat-pig/frontend/src/hooks/usePlayerProfile.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\n\n/**\n * usePlayerProfile - Custom hook for player profile management\n * \n * Features:\n * - Profile selection and persistence\n * - Local storage integration\n * - Profile statistics caching\n * - Real-time profile updates\n * - Error handling and loading states\n */\nconst usePlayerProfile = () => {\n    const [selectedProfile, setSelectedProfile] = useState(null);\n    const [profiles, setProfiles] = useState([]);\n    const [profileStatistics, setProfileStatistics] = useState({});\n    const [loading, setLoading] = useState(false);\n    const [error, setError] = useState(null);\n    const [syncStatus, setSyncStatus] = useState('idle'); // 'idle', 'syncing', 'success', 'error'\n\n    // Storage keys\n    const STORAGE_KEYS = {\n        SELECTED_PROFILE: 'wgp_selected_profile',\n        PROFILES_CACHE: 'wgp_profiles_cache',\n        STATISTICS_CACHE: 'wgp_statistics_cache',\n        LAST_SYNC: 'wgp_last_sync'\n    };\n\n    // Load initial data on mount\n    useEffect(() => {\n        loadInitialData();\n    }, [loadInitialData]);\n\n    // Sync with server periodically\n    useEffect(() => {\n        const interval = setInterval(() => {\n            const lastSync = localStorage.getItem(STORAGE_KEYS.LAST_SYNC);\n            const now = Date.now();\n            const fiveMinutes = 5 * 60 * 1000;\n\n            // Sync if more than 5 minutes since last sync\n            if (!lastSync || (now - parseInt(lastSync)) > fiveMinutes) {\n                syncWithServer();\n            }\n        }, 60000); // Check every minute\n\n        return () => clearInterval(interval);\n    }, [STORAGE_KEYS.LAST_SYNC, syncWithServer]);\n\n    const loadInitialData = async () => {\n        try {\n            setLoading(true);\n            \n            // Load from localStorage first for immediate UI\n            loadFromLocalStorage();\n            \n            // Then sync with server\n            await syncWithServer();\n        } catch (err) {\n            console.error('Error loading initial data:', err);\n            setError('Failed to load player profiles');\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    const loadFromLocalStorage = () => {\n        try {\n            // Load selected profile\n            const savedProfile = localStorage.getItem(STORAGE_KEYS.SELECTED_PROFILE);\n            if (savedProfile) {\n                setSelectedProfile(JSON.parse(savedProfile));\n            }\n\n            // Load profiles cache\n            const cachedProfiles = localStorage.getItem(STORAGE_KEYS.PROFILES_CACHE);\n            if (cachedProfiles) {\n                setProfiles(JSON.parse(cachedProfiles));\n            }\n\n            // Load statistics cache\n            const cachedStats = localStorage.getItem(STORAGE_KEYS.STATISTICS_CACHE);\n            if (cachedStats) {\n                setProfileStatistics(JSON.parse(cachedStats));\n            }\n        } catch (err) {\n            console.error('Error loading from localStorage:', err);\n            // Clear corrupted data\n            Object.values(STORAGE_KEYS).forEach(key => {\n                localStorage.removeItem(key);\n            });\n        }\n    };\n\n    const saveToLocalStorage = (key, data) => {\n        try {\n            localStorage.setItem(key, JSON.stringify(data));\n        } catch (err) {\n            console.error('Error saving to localStorage:', err);\n        }\n    };\n\n    const syncWithServer = useCallback(async () => {\n        try {\n            setSyncStatus('syncing');\n            \n            // Fetch latest profiles from server\n            const response = await fetch('/api/players');\n            if (!response.ok) {\n                throw new Error('Failed to fetch profiles from server');\n            }\n            \n            const serverProfiles = await response.json();\n            setProfiles(serverProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, serverProfiles);\n\n            // Update selected profile if it exists on server\n            if (selectedProfile) {\n                const updatedProfile = serverProfiles.find(p => p.id === selectedProfile.id);\n                if (updatedProfile) {\n                    setSelectedProfile(updatedProfile);\n                    saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n                }\n            }\n\n            // Mark last sync time\n            localStorage.setItem(STORAGE_KEYS.LAST_SYNC, Date.now().toString());\n            setSyncStatus('success');\n            \n            // Clear sync status after 2 seconds\n            setTimeout(() => setSyncStatus('idle'), 2000);\n            \n        } catch (err) {\n            console.error('Error syncing with server:', err);\n            setSyncStatus('error');\n            \n            // Clear error status after 5 seconds\n            setTimeout(() => setSyncStatus('idle'), 5000);\n        }\n    }, [selectedProfile]);\n\n    const selectProfile = useCallback(async (profile) => {\n        try {\n            setSelectedProfile(profile);\n            saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, profile);\n            \n            // Load statistics for the selected profile\n            await loadProfileStatistics(profile.id);\n            \n            // Update last played on server\n            await updateLastPlayed(profile.id);\n            \n        } catch (err) {\n            console.error('Error selecting profile:', err);\n            setError('Failed to select profile');\n        }\n    }, [loadProfileStatistics, updateLastPlayed, STORAGE_KEYS.SELECTED_PROFILE]);\n\n    const createProfile = useCallback(async (profileData) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch('/api/players', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(profileData)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to create profile');\n            }\n\n            const newProfile = await response.json();\n            \n            // Update local state\n            const updatedProfiles = [...profiles, newProfile];\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Auto-select the new profile\n            await selectProfile(newProfile);\n            \n            return newProfile;\n            \n        } catch (err) {\n            console.error('Error creating profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectProfile, STORAGE_KEYS.PROFILES_CACHE]);\n\n    const updateProfile = useCallback(async (profileId, updateData) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch(`/api/players/${profileId}`, {\n                method: 'PUT',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(updateData)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to update profile');\n            }\n\n            const updatedProfile = await response.json();\n            \n            // Update local state\n            const updatedProfiles = profiles.map(p => \n                p.id === profileId ? updatedProfile : p\n            );\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Update selected profile if it's the one being updated\n            if (selectedProfile && selectedProfile.id === profileId) {\n                setSelectedProfile(updatedProfile);\n                saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n            }\n            \n            return updatedProfile;\n            \n        } catch (err) {\n            console.error('Error updating profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectedProfile, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE]);\n\n    const deleteProfile = useCallback(async (profileId) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch(`/api/players/${profileId}`, {\n                method: 'DELETE'\n            });\n\n            if (!response.ok) {\n                throw new Error('Failed to delete profile');\n            }\n\n            // Update local state\n            const updatedProfiles = profiles.filter(p => p.id !== profileId);\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Clear selected profile if it was deleted\n            if (selectedProfile && selectedProfile.id === profileId) {\n                setSelectedProfile(null);\n                localStorage.removeItem(STORAGE_KEYS.SELECTED_PROFILE);\n            }\n            \n            // Remove from statistics cache\n            const updatedStats = { ...profileStatistics };\n            delete updatedStats[profileId];\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n        } catch (err) {\n            console.error('Error deleting profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectedProfile, profileStatistics, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE, STORAGE_KEYS.STATISTICS_CACHE]);\n\n    const loadProfileStatistics = useCallback(async (profileId) => {\n        try {\n            // Return cached statistics if available and recent\n            const cached = profileStatistics[profileId];\n            if (cached && (Date.now() - cached.loadedAt) < 300000) { // 5 minutes\n                return cached.data;\n            }\n            \n            const response = await fetch(`/api/players/${profileId}/statistics`);\n            if (!response.ok) {\n                // Statistics might not exist for new profiles\n                return null;\n            }\n            \n            const stats = await response.json();\n            \n            // Cache the statistics\n            const updatedStats = {\n                ...profileStatistics,\n                [profileId]: {\n                    data: stats,\n                    loadedAt: Date.now()\n                }\n            };\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n            return stats;\n            \n        } catch (err) {\n            console.error('Error loading profile statistics:', err);\n            return null;\n        }\n    }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n\n    const updateLastPlayed = useCallback(async (profileId) => {\n        try {\n            await fetch(`/api/players/${profileId}`, {\n                method: 'PUT',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    last_played: new Date().toISOString()\n                })\n            });\n        } catch (err) {\n            console.error('Error updating last played:', err);\n            // Don't throw - this is not critical\n        }\n    }, [STORAGE_KEYS.LAST_SYNC]);\n\n    const recordGameResult = useCallback(async (gameResult) => {\n        try {\n            const response = await fetch('/api/game-results', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(gameResult)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to record game result');\n            }\n\n            const result = await response.json();\n            \n            // Invalidate cached statistics for the player\n            const updatedStats = { ...profileStatistics };\n            delete updatedStats[gameResult.player_profile_id];\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n            return result;\n            \n        } catch (err) {\n            console.error('Error recording game result:', err);\n            setError(err.message);\n            throw err;\n        }\n    }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n\n    const getProfileById = useCallback((profileId) => {\n        return profiles.find(p => p.id === profileId);\n    }, [profiles]);\n\n    const getProfileByName = useCallback((name) => {\n        return profiles.find(p => p.name.toLowerCase() === name.toLowerCase());\n    }, [profiles]);\n\n    const clearError = useCallback(() => {\n        setError(null);\n    }, []);\n\n    const refreshProfiles = useCallback(async () => {\n        await syncWithServer();\n    }, [syncWithServer]);\n\n    // Export/Import functionality\n    const exportProfileData = useCallback(async (profileId) => {\n        try {\n            const profile = getProfileById(profileId);\n            const statistics = await loadProfileStatistics(profileId);\n            \n            const exportData = {\n                profile,\n                statistics,\n                exportedAt: new Date().toISOString(),\n                version: '1.0'\n            };\n            \n            // Create and download file\n            const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n                type: 'application/json'\n            });\n            const url = URL.createObjectURL(blob);\n            const link = document.createElement('a');\n            link.href = url;\n            link.download = `wgp-profile-${profile.name}-${new Date().toISOString().split('T')[0]}.json`;\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n            URL.revokeObjectURL(url);\n            \n        } catch (err) {\n            console.error('Error exporting profile data:', err);\n            setError('Failed to export profile data');\n        }\n    }, [getProfileById, loadProfileStatistics, selectedProfile]);\n\n    // Check if profile exists locally\n    const hasProfiles = profiles.length > 0;\n    const hasSelectedProfile = selectedProfile !== null;\n    \n    // Get current profile statistics\n    const currentProfileStats = selectedProfile ? \n        profileStatistics[selectedProfile.id]?.data : null;\n\n    return {\n        // State\n        selectedProfile,\n        profiles,\n        profileStatistics: currentProfileStats,\n        loading,\n        error,\n        syncStatus,\n        hasProfiles,\n        hasSelectedProfile,\n        \n        // Actions\n        selectProfile,\n        createProfile,\n        updateProfile,\n        deleteProfile,\n        loadProfileStatistics,\n        recordGameResult,\n        refreshProfiles,\n        exportProfileData,\n        clearError,\n        \n        // Utilities\n        getProfileById,\n        getProfileByName,\n        syncWithServer\n    };\n};\n\nexport default usePlayerProfile;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
./node_modules/.cache/babel-loader/ee1da45176e31556a1698f3b5cca94287aa26c475818bc3e9b15cb0c8533e19d.json:1:{"ast":null,"code":"import{useState,useEffect,useCallback}from'react';/**\n * usePlayerProfile - Custom hook for player profile management\n * \n * Features:\n * - Profile selection and persistence\n * - Local storage integration\n * - Profile statistics caching\n * - Real-time profile updates\n * - Error handling and loading states\n */const usePlayerProfile=()=>{var _profileStatistics$se;const[selectedProfile,setSelectedProfile]=useState(null);const[profiles,setProfiles]=useState([]);const[profileStatistics,setProfileStatistics]=useState({});const[loading,setLoading]=useState(false);const[error,setError]=useState(null);const[syncStatus,setSyncStatus]=useState('idle');// 'idle', 'syncing', 'success', 'error'\n// Storage keys\nconst STORAGE_KEYS={SELECTED_PROFILE:'wgp_selected_profile',PROFILES_CACHE:'wgp_profiles_cache',STATISTICS_CACHE:'wgp_statistics_cache',LAST_SYNC:'wgp_last_sync'};// Load initial data on mount\nuseEffect(()=>{loadInitialData();},[]);// Sync with server periodically\nuseEffect(()=>{const interval=setInterval(()=>{const lastSync=localStorage.getItem(STORAGE_KEYS.LAST_SYNC);const now=Date.now();const fiveMinutes=5*60*1000;// Sync if more than 5 minutes since last sync\nif(!lastSync||now-parseInt(lastSync)>fiveMinutes){syncWithServer();}},60000);// Check every minute\nreturn()=>clearInterval(interval);},[]);const loadInitialData=async()=>{try{setLoading(true);// Load from localStorage first for immediate UI\nloadFromLocalStorage();// Then sync with server\nawait syncWithServer();}catch(err){console.error('Error loading initial data:',err);setError('Failed to load player profiles');}finally{setLoading(false);}};const loadFromLocalStorage=()=>{try{// Load selected profile\nconst savedProfile=localStorage.getItem(STORAGE_KEYS.SELECTED_PROFILE);if(savedProfile){setSelectedProfile(JSON.parse(savedProfile));}// Load profiles cache\nconst cachedProfiles=localStorage.getItem(STORAGE_KEYS.PROFILES_CACHE);if(cachedProfiles){setProfiles(JSON.parse(cachedProfiles));}// Load statistics cache\nconst cachedStats=localStorage.getItem(STORAGE_KEYS.STATISTICS_CACHE);if(cachedStats){setProfileStatistics(JSON.parse(cachedStats));}}catch(err){console.error('Error loading from localStorage:',err);// Clear corrupted data\nObject.values(STORAGE_KEYS).forEach(key=>{localStorage.removeItem(key);});}};const saveToLocalStorage=(key,data)=>{try{localStorage.setItem(key,JSON.stringify(data));}catch(err){console.error('Error saving to localStorage:',err);}};const syncWithServer=useCallback(async()=>{try{setSyncStatus('syncing');// Fetch latest profiles from server\nconst response=await fetch('/api/players');if(!response.ok){throw new Error('Failed to fetch profiles from server');}const serverProfiles=await response.json();setProfiles(serverProfiles);saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE,serverProfiles);// Update selected profile if it exists on server\nif(selectedProfile){const updatedProfile=serverProfiles.find(p=>p.id===selectedProfile.id);if(updatedProfile){setSelectedProfile(updatedProfile);saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE,updatedProfile);}}// Mark last sync time\nlocalStorage.setItem(STORAGE_KEYS.LAST_SYNC,Date.now().toString());setSyncStatus('success');// Clear sync status after 2 seconds\nsetTimeout(()=>setSyncStatus('idle'),2000);}catch(err){console.error('Error syncing with server:',err);setSyncStatus('error');// Clear error status after 5 seconds\nsetTimeout(()=>setSyncStatus('idle'),5000);}},[selectedProfile]);const selectProfile=useCallback(async profile=>{try{setSelectedProfile(profile);saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE,profile);// Load statistics for the selected profile\nawait loadProfileStatistics(profile.id);// Update last played on server\nawait updateLastPlayed(profile.id);}catch(err){console.error('Error selecting profile:',err);setError('Failed to select profile');}},[]);const createProfile=useCallback(async profileData=>{try{setLoading(true);setError(null);const response=await fetch('/api/players',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(profileData)});if(!response.ok){const errorData=await response.json();throw new Error(errorData.detail||'Failed to create profile');}const newProfile=await response.json();// Update local state\nconst updatedProfiles=[...profiles,newProfile];setProfiles(updatedProfiles);saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE,updatedProfiles);// Auto-select the new profile\nawait selectProfile(newProfile);return newProfile;}catch(err){console.error('Error creating profile:',err);setError(err.message);throw err;}finally{setLoading(false);}},[profiles,selectProfile]);const updateProfile=useCallback(async(profileId,updateData)=>{try{setLoading(true);setError(null);const response=await fetch(`/api/players/${profileId}`,{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify(updateData)});if(!response.ok){const errorData=await response.json();throw new Error(errorData.detail||'Failed to update profile');}const updatedProfile=await response.json();// Update local state\nconst updatedProfiles=profiles.map(p=>p.id===profileId?updatedProfile:p);setProfiles(updatedProfiles);saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE,updatedProfiles);// Update selected profile if it's the one being updated\nif(selectedProfile&&selectedProfile.id===profileId){setSelectedProfile(updatedProfile);saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE,updatedProfile);}return updatedProfile;}catch(err){console.error('Error updating profile:',err);setError(err.message);throw err;}finally{setLoading(false);}},[profiles,selectedProfile]);const deleteProfile=useCallback(async profileId=>{try{setLoading(true);setError(null);const response=await fetch(`/api/players/${profileId}`,{method:'DELETE'});if(!response.ok){throw new Error('Failed to delete profile');}// Update local state\nconst updatedProfiles=profiles.filter(p=>p.id!==profileId);setProfiles(updatedProfiles);saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE,updatedProfiles);// Clear selected profile if it was deleted\nif(selectedProfile&&selectedProfile.id===profileId){setSelectedProfile(null);localStorage.removeItem(STORAGE_KEYS.SELECTED_PROFILE);}// Remove from statistics cache\nconst updatedStats={...profileStatistics};delete updatedStats[profileId];setProfileStatistics(updatedStats);saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE,updatedStats);}catch(err){console.error('Error deleting profile:',err);setError(err.message);throw err;}finally{setLoading(false);}},[profiles,selectedProfile,profileStatistics]);const loadProfileStatistics=useCallback(async profileId=>{try{// Return cached statistics if available and recent\nconst cached=profileStatistics[profileId];if(cached&&Date.now()-cached.loadedAt<300000){// 5 minutes\nreturn cached.data;}const response=await fetch(`/api/players/${profileId}/statistics`);if(!response.ok){// Statistics might not exist for new profiles\nreturn null;}const stats=await response.json();// Cache the statistics\nconst updatedStats={...profileStatistics,[profileId]:{data:stats,loadedAt:Date.now()}};setProfileStatistics(updatedStats);saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE,updatedStats);return stats;}catch(err){console.error('Error loading profile statistics:',err);return null;}},[profileStatistics]);const updateLastPlayed=useCallback(async profileId=>{try{await fetch(`/api/players/${profileId}`,{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify({last_played:new Date().toISOString()})});}catch(err){console.error('Error updating last played:',err);// Don't throw - this is not critical\n}},[]);const recordGameResult=useCallback(async gameResult=>{try{const response=await fetch('/api/game-results',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(gameResult)});if(!response.ok){const errorData=await response.json();throw new Error(errorData.detail||'Failed to record game result');}const result=await response.json();// Invalidate cached statistics for the player\nconst updatedStats={...profileStatistics};delete updatedStats[gameResult.player_profile_id];setProfileStatistics(updatedStats);saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE,updatedStats);return result;}catch(err){console.error('Error recording game result:',err);setError(err.message);throw err;}},[profileStatistics]);const getProfileById=useCallback(profileId=>{return profiles.find(p=>p.id===profileId);},[profiles]);const getProfileByName=useCallback(name=>{return profiles.find(p=>p.name.toLowerCase()===name.toLowerCase());},[profiles]);const clearError=useCallback(()=>{setError(null);},[]);const refreshProfiles=useCallback(async()=>{await syncWithServer();},[syncWithServer]);// Export/Import functionality\nconst exportProfileData=useCallback(async profileId=>{try{const profile=getProfileById(profileId);const statistics=await loadProfileStatistics(profileId);const exportData={profile,statistics,exportedAt:new Date().toISOString(),version:'1.0'};// Create and download file\nconst blob=new Blob([JSON.stringify(exportData,null,2)],{type:'application/json'});const url=URL.createObjectURL(blob);const link=document.createElement('a');link.href=url;link.download=`wgp-profile-${profile.name}-${new Date().toISOString().split('T')[0]}.json`;document.body.appendChild(link);link.click();document.body.removeChild(link);URL.revokeObjectURL(url);}catch(err){console.error('Error exporting profile data:',err);setError('Failed to export profile data');}},[getProfileById,loadProfileStatistics]);// Check if profile exists locally\nconst hasProfiles=profiles.length>0;const hasSelectedProfile=selectedProfile!==null;// Get current profile statistics\nconst currentProfileStats=selectedProfile?(_profileStatistics$se=profileStatistics[selectedProfile.id])===null||_profileStatistics$se===void 0?void 0:_profileStatistics$se.data:null;return{// State\nselectedProfile,profiles,profileStatistics:currentProfileStats,loading,error,syncStatus,hasProfiles,hasSelectedProfile,// Actions\nselectProfile,createProfile,updateProfile,deleteProfile,loadProfileStatistics,recordGameResult,refreshProfiles,exportProfileData,clearError,// Utilities\ngetProfileById,getProfileByName,syncWithServer};};export default usePlayerProfile;","map":{"version":3,"names":["useState","useEffect","useCallback","usePlayerProfile","_profileStatistics$se","selectedProfile","setSelectedProfile","profiles","setProfiles","profileStatistics","setProfileStatistics","loading","setLoading","error","setError","syncStatus","setSyncStatus","STORAGE_KEYS","SELECTED_PROFILE","PROFILES_CACHE","STATISTICS_CACHE","LAST_SYNC","loadInitialData","interval","setInterval","lastSync","localStorage","getItem","now","Date","fiveMinutes","parseInt","syncWithServer","clearInterval","loadFromLocalStorage","err","console","savedProfile","JSON","parse","cachedProfiles","cachedStats","Object","values","forEach","key","removeItem","saveToLocalStorage","data","setItem","stringify","response","fetch","ok","Error","serverProfiles","json","updatedProfile","find","p","id","toString","setTimeout","selectProfile","profile","loadProfileStatistics","updateLastPlayed","createProfile","profileData","method","headers","body","errorData","detail","newProfile","updatedProfiles","message","updateProfile","profileId","updateData","map","deleteProfile","filter","updatedStats","cached","loadedAt","stats","last_played","toISOString","recordGameResult","gameResult","result","player_profile_id","getProfileById","getProfileByName","name","toLowerCase","clearError","refreshProfiles","exportProfileData","statistics","exportData","exportedAt","version","blob","Blob","type","url","URL","createObjectURL","link","document","createElement","href","download","split","appendChild","click","removeChild","revokeObjectURL","hasProfiles","length","hasSelectedProfile","currentProfileStats"],"sources":["/Users/stuartgano/Documents/wolf-goat-pig/frontend/src/hooks/usePlayerProfile.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\n\n/**\n * usePlayerProfile - Custom hook for player profile management\n * \n * Features:\n * - Profile selection and persistence\n * - Local storage integration\n * - Profile statistics caching\n * - Real-time profile updates\n * - Error handling and loading states\n */\nconst usePlayerProfile = () => {\n    const [selectedProfile, setSelectedProfile] = useState(null);\n    const [profiles, setProfiles] = useState([]);\n    const [profileStatistics, setProfileStatistics] = useState({});\n    const [loading, setLoading] = useState(false);\n    const [error, setError] = useState(null);\n    const [syncStatus, setSyncStatus] = useState('idle'); // 'idle', 'syncing', 'success', 'error'\n\n    // Storage keys\n    const STORAGE_KEYS = {\n        SELECTED_PROFILE: 'wgp_selected_profile',\n        PROFILES_CACHE: 'wgp_profiles_cache',\n        STATISTICS_CACHE: 'wgp_statistics_cache',\n        LAST_SYNC: 'wgp_last_sync'\n    };\n\n    // Load initial data on mount\n    useEffect(() => {\n        loadInitialData();\n    }, []);\n\n    // Sync with server periodically\n    useEffect(() => {\n        const interval = setInterval(() => {\n            const lastSync = localStorage.getItem(STORAGE_KEYS.LAST_SYNC);\n            const now = Date.now();\n            const fiveMinutes = 5 * 60 * 1000;\n\n            // Sync if more than 5 minutes since last sync\n            if (!lastSync || (now - parseInt(lastSync)) > fiveMinutes) {\n                syncWithServer();\n            }\n        }, 60000); // Check every minute\n\n        return () => clearInterval(interval);\n    }, []);\n\n    const loadInitialData = async () => {\n        try {\n            setLoading(true);\n            \n            // Load from localStorage first for immediate UI\n            loadFromLocalStorage();\n            \n            // Then sync with server\n            await syncWithServer();\n        } catch (err) {\n            console.error('Error loading initial data:', err);\n            setError('Failed to load player profiles');\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    const loadFromLocalStorage = () => {\n        try {\n            // Load selected profile\n            const savedProfile = localStorage.getItem(STORAGE_KEYS.SELECTED_PROFILE);\n            if (savedProfile) {\n                setSelectedProfile(JSON.parse(savedProfile));\n            }\n\n            // Load profiles cache\n            const cachedProfiles = localStorage.getItem(STORAGE_KEYS.PROFILES_CACHE);\n            if (cachedProfiles) {\n                setProfiles(JSON.parse(cachedProfiles));\n            }\n\n            // Load statistics cache\n            const cachedStats = localStorage.getItem(STORAGE_KEYS.STATISTICS_CACHE);\n            if (cachedStats) {\n                setProfileStatistics(JSON.parse(cachedStats));\n            }\n        } catch (err) {\n            console.error('Error loading from localStorage:', err);\n            // Clear corrupted data\n            Object.values(STORAGE_KEYS).forEach(key => {\n                localStorage.removeItem(key);\n            });\n        }\n    };\n\n    const saveToLocalStorage = (key, data) => {\n        try {\n            localStorage.setItem(key, JSON.stringify(data));\n        } catch (err) {\n            console.error('Error saving to localStorage:', err);\n        }\n    };\n\n    const syncWithServer = useCallback(async () => {\n        try {\n            setSyncStatus('syncing');\n            \n            // Fetch latest profiles from server\n            const response = await fetch('/api/players');\n            if (!response.ok) {\n                throw new Error('Failed to fetch profiles from server');\n            }\n            \n            const serverProfiles = await response.json();\n            setProfiles(serverProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, serverProfiles);\n\n            // Update selected profile if it exists on server\n            if (selectedProfile) {\n                const updatedProfile = serverProfiles.find(p => p.id === selectedProfile.id);\n                if (updatedProfile) {\n                    setSelectedProfile(updatedProfile);\n                    saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n                }\n            }\n\n            // Mark last sync time\n            localStorage.setItem(STORAGE_KEYS.LAST_SYNC, Date.now().toString());\n            setSyncStatus('success');\n            \n            // Clear sync status after 2 seconds\n            setTimeout(() => setSyncStatus('idle'), 2000);\n            \n        } catch (err) {\n            console.error('Error syncing with server:', err);\n            setSyncStatus('error');\n            \n            // Clear error status after 5 seconds\n            setTimeout(() => setSyncStatus('idle'), 5000);\n        }\n    }, [selectedProfile]);\n\n    const selectProfile = useCallback(async (profile) => {\n        try {\n            setSelectedProfile(profile);\n            saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, profile);\n            \n            // Load statistics for the selected profile\n            await loadProfileStatistics(profile.id);\n            \n            // Update last played on server\n            await updateLastPlayed(profile.id);\n            \n        } catch (err) {\n            console.error('Error selecting profile:', err);\n            setError('Failed to select profile');\n        }\n    }, []);\n\n    const createProfile = useCallback(async (profileData) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch('/api/players', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(profileData)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to create profile');\n            }\n\n            const newProfile = await response.json();\n            \n            // Update local state\n            const updatedProfiles = [...profiles, newProfile];\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Auto-select the new profile\n            await selectProfile(newProfile);\n            \n            return newProfile;\n            \n        } catch (err) {\n            console.error('Error creating profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectProfile]);\n\n    const updateProfile = useCallback(async (profileId, updateData) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch(`/api/players/${profileId}`, {\n                method: 'PUT',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(updateData)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to update profile');\n            }\n\n            const updatedProfile = await response.json();\n            \n            // Update local state\n            const updatedProfiles = profiles.map(p => \n                p.id === profileId ? updatedProfile : p\n            );\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Update selected profile if it's the one being updated\n            if (selectedProfile && selectedProfile.id === profileId) {\n                setSelectedProfile(updatedProfile);\n                saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n            }\n            \n            return updatedProfile;\n            \n        } catch (err) {\n            console.error('Error updating profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectedProfile]);\n\n    const deleteProfile = useCallback(async (profileId) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch(`/api/players/${profileId}`, {\n                method: 'DELETE'\n            });\n\n            if (!response.ok) {\n                throw new Error('Failed to delete profile');\n            }\n\n            // Update local state\n            const updatedProfiles = profiles.filter(p => p.id !== profileId);\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Clear selected profile if it was deleted\n            if (selectedProfile && selectedProfile.id === profileId) {\n                setSelectedProfile(null);\n                localStorage.removeItem(STORAGE_KEYS.SELECTED_PROFILE);\n            }\n            \n            // Remove from statistics cache\n            const updatedStats = { ...profileStatistics };\n            delete updatedStats[profileId];\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n        } catch (err) {\n            console.error('Error deleting profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectedProfile, profileStatistics]);\n\n    const loadProfileStatistics = useCallback(async (profileId) => {\n        try {\n            // Return cached statistics if available and recent\n            const cached = profileStatistics[profileId];\n            if (cached && (Date.now() - cached.loadedAt) < 300000) { // 5 minutes\n                return cached.data;\n            }\n            \n            const response = await fetch(`/api/players/${profileId}/statistics`);\n            if (!response.ok) {\n                // Statistics might not exist for new profiles\n                return null;\n            }\n            \n            const stats = await response.json();\n            \n            // Cache the statistics\n            const updatedStats = {\n                ...profileStatistics,\n                [profileId]: {\n                    data: stats,\n                    loadedAt: Date.now()\n                }\n            };\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n            return stats;\n            \n        } catch (err) {\n            console.error('Error loading profile statistics:', err);\n            return null;\n        }\n    }, [profileStatistics]);\n\n    const updateLastPlayed = useCallback(async (profileId) => {\n        try {\n            await fetch(`/api/players/${profileId}`, {\n                method: 'PUT',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    last_played: new Date().toISOString()\n                })\n            });\n        } catch (err) {\n            console.error('Error updating last played:', err);\n            // Don't throw - this is not critical\n        }\n    }, []);\n\n    const recordGameResult = useCallback(async (gameResult) => {\n        try {\n            const response = await fetch('/api/game-results', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(gameResult)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to record game result');\n            }\n\n            const result = await response.json();\n            \n            // Invalidate cached statistics for the player\n            const updatedStats = { ...profileStatistics };\n            delete updatedStats[gameResult.player_profile_id];\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n            return result;\n            \n        } catch (err) {\n            console.error('Error recording game result:', err);\n            setError(err.message);\n            throw err;\n        }\n    }, [profileStatistics]);\n\n    const getProfileById = useCallback((profileId) => {\n        return profiles.find(p => p.id === profileId);\n    }, [profiles]);\n\n    const getProfileByName = useCallback((name) => {\n        return profiles.find(p => p.name.toLowerCase() === name.toLowerCase());\n    }, [profiles]);\n\n    const clearError = useCallback(() => {\n        setError(null);\n    }, []);\n\n    const refreshProfiles = useCallback(async () => {\n        await syncWithServer();\n    }, [syncWithServer]);\n\n    // Export/Import functionality\n    const exportProfileData = useCallback(async (profileId) => {\n        try {\n            const profile = getProfileById(profileId);\n            const statistics = await loadProfileStatistics(profileId);\n            \n            const exportData = {\n                profile,\n                statistics,\n                exportedAt: new Date().toISOString(),\n                version: '1.0'\n            };\n            \n            // Create and download file\n            const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n                type: 'application/json'\n            });\n            const url = URL.createObjectURL(blob);\n            const link = document.createElement('a');\n            link.href = url;\n            link.download = `wgp-profile-${profile.name}-${new Date().toISOString().split('T')[0]}.json`;\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n            URL.revokeObjectURL(url);\n            \n        } catch (err) {\n            console.error('Error exporting profile data:', err);\n            setError('Failed to export profile data');\n        }\n    }, [getProfileById, loadProfileStatistics]);\n\n    // Check if profile exists locally\n    const hasProfiles = profiles.length > 0;\n    const hasSelectedProfile = selectedProfile !== null;\n    \n    // Get current profile statistics\n    const currentProfileStats = selectedProfile ? \n        profileStatistics[selectedProfile.id]?.data : null;\n\n    return {\n        // State\n        selectedProfile,\n        profiles,\n        profileStatistics: currentProfileStats,\n        loading,\n        error,\n        syncStatus,\n        hasProfiles,\n        hasSelectedProfile,\n        \n        // Actions\n        selectProfile,\n        createProfile,\n        updateProfile,\n        deleteProfile,\n        loadProfileStatistics,\n        recordGameResult,\n        refreshProfiles,\n        exportProfileData,\n        clearError,\n        \n        // Utilities\n        getProfileById,\n        getProfileByName,\n        syncWithServer\n    };\n};\n\nexport default usePlayerProfile;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
./node_modules/.cache/babel-loader/5250811d137d2bb0db7091cf68d7082f9bc8cc74118f89bf8b1e687cb3137698.json:1:{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\n\n/**\n * usePlayerProfile - Custom hook for player profile management\n * \n * Features:\n * - Profile selection and persistence\n * - Local storage integration\n * - Profile statistics caching\n * - Real-time profile updates\n * - Error handling and loading states\n */\nconst usePlayerProfile = () => {\n  _s();\n  var _profileStatistics$se;\n  const [selectedProfile, setSelectedProfile] = useState(null);\n  const [profiles, setProfiles] = useState([]);\n  const [profileStatistics, setProfileStatistics] = useState({});\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [syncStatus, setSyncStatus] = useState('idle'); // 'idle', 'syncing', 'success', 'error'\n\n  // Storage keys\n  const STORAGE_KEYS = {\n    SELECTED_PROFILE: 'wgp_selected_profile',\n    PROFILES_CACHE: 'wgp_profiles_cache',\n    STATISTICS_CACHE: 'wgp_statistics_cache',\n    LAST_SYNC: 'wgp_last_sync'\n  };\n  const loadInitialData = useCallback(async () => {\n    try {\n      setLoading(true);\n\n      // Load from localStorage first for immediate UI\n      loadFromLocalStorage();\n\n      // Then sync with server\n      await syncWithServer();\n    } catch (err) {\n      console.error('Error loading initial data:', err);\n      setError('Failed to load player profiles');\n    } finally {\n      setLoading(false);\n    }\n  }, []); // Add dependencies array for useCallback\n\n  const loadFromLocalStorage = () => {\n    try {\n      // Load selected profile\n      const savedProfile = localStorage.getItem(STORAGE_KEYS.SELECTED_PROFILE);\n      if (savedProfile) {\n        setSelectedProfile(JSON.parse(savedProfile));\n      }\n\n      // Load profiles cache\n      const cachedProfiles = localStorage.getItem(STORAGE_KEYS.PROFILES_CACHE);\n      if (cachedProfiles) {\n        setProfiles(JSON.parse(cachedProfiles));\n      }\n\n      // Load statistics cache\n      const cachedStats = localStorage.getItem(STORAGE_KEYS.STATISTICS_CACHE);\n      if (cachedStats) {\n        setProfileStatistics(JSON.parse(cachedStats));\n      }\n    } catch (err) {\n      console.error('Error loading from localStorage:', err);\n      // Clear corrupted data\n      Object.values(STORAGE_KEYS).forEach(key => {\n        localStorage.removeItem(key);\n      });\n    }\n  };\n  const saveToLocalStorage = (key, data) => {\n    try {\n      localStorage.setItem(key, JSON.stringify(data));\n    } catch (err) {\n      console.error('Error saving to localStorage:', err);\n    }\n  };\n  const syncWithServer = useCallback(async () => {\n    try {\n      setSyncStatus('syncing');\n\n      // Fetch latest profiles from server\n      const response = await fetch('/api/players');\n      if (!response.ok) {\n        throw new Error('Failed to fetch profiles from server');\n      }\n      const serverProfiles = await response.json();\n      setProfiles(serverProfiles);\n      saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, serverProfiles);\n\n      // Update selected profile if it exists on server\n      if (selectedProfile) {\n        const updatedProfile = serverProfiles.find(p => p.id === selectedProfile.id);\n        if (updatedProfile) {\n          setSelectedProfile(updatedProfile);\n          saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n        }\n      }\n\n      // Mark last sync time\n      localStorage.setItem(STORAGE_KEYS.LAST_SYNC, Date.now().toString());\n      setSyncStatus('success');\n\n      // Clear sync status after 2 seconds\n      setTimeout(() => setSyncStatus('idle'), 2000);\n    } catch (err) {\n      console.error('Error syncing with server:', err);\n      setSyncStatus('error');\n\n      // Clear error status after 5 seconds\n      setTimeout(() => setSyncStatus('idle'), 5000);\n    }\n  }, [selectedProfile]);\n  const selectProfile = useCallback(async profile => {\n    try {\n      setSelectedProfile(profile);\n      saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, profile);\n\n      // Load statistics for the selected profile\n      await loadProfileStatistics(profile.id);\n\n      // Update last played on server\n      await updateLastPlayed(profile.id);\n    } catch (err) {\n      console.error('Error selecting profile:', err);\n      setError('Failed to select profile');\n    }\n  }, [loadProfileStatistics, updateLastPlayed, STORAGE_KEYS.SELECTED_PROFILE]);\n  const createProfile = useCallback(async profileData => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await fetch('/api/players', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(profileData)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to create profile');\n      }\n      const newProfile = await response.json();\n\n      // Update local state\n      const updatedProfiles = [...profiles, newProfile];\n      setProfiles(updatedProfiles);\n      saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n\n      // Auto-select the new profile\n      await selectProfile(newProfile);\n      return newProfile;\n    } catch (err) {\n      console.error('Error creating profile:', err);\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [profiles, selectProfile, STORAGE_KEYS.PROFILES_CACHE]);\n  const updateProfile = useCallback(async (profileId, updateData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await fetch(`/api/players/${profileId}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(updateData)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to update profile');\n      }\n      const updatedProfile = await response.json();\n\n      // Update local state\n      const updatedProfiles = profiles.map(p => p.id === profileId ? updatedProfile : p);\n      setProfiles(updatedProfiles);\n      saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n\n      // Update selected profile if it's the one being updated\n      if (selectedProfile && selectedProfile.id === profileId) {\n        setSelectedProfile(updatedProfile);\n        saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n      }\n      return updatedProfile;\n    } catch (err) {\n      console.error('Error updating profile:', err);\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [profiles, selectedProfile, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE]);\n  const deleteProfile = useCallback(async profileId => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await fetch(`/api/players/${profileId}`, {\n        method: 'DELETE'\n      });\n      if (!response.ok) {\n        throw new Error('Failed to delete profile');\n      }\n\n      // Update local state\n      const updatedProfiles = profiles.filter(p => p.id !== profileId);\n      setProfiles(updatedProfiles);\n      saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n\n      // Clear selected profile if it was deleted\n      if (selectedProfile && selectedProfile.id === profileId) {\n        setSelectedProfile(null);\n        localStorage.removeItem(STORAGE_KEYS.SELECTED_PROFILE);\n      }\n\n      // Remove from statistics cache\n      const updatedStats = {\n        ...profileStatistics\n      };\n      delete updatedStats[profileId];\n      setProfileStatistics(updatedStats);\n      saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n    } catch (err) {\n      console.error('Error deleting profile:', err);\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [profiles, selectedProfile, profileStatistics, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE, STORAGE_KEYS.STATISTICS_CACHE]);\n  const loadProfileStatistics = useCallback(async profileId => {\n    try {\n      // Return cached statistics if available and recent\n      const cached = profileStatistics[profileId];\n      if (cached && Date.now() - cached.loadedAt < 300000) {\n        // 5 minutes\n        return cached.data;\n      }\n      const response = await fetch(`/api/players/${profileId}/statistics`);\n      if (!response.ok) {\n        // Statistics might not exist for new profiles\n        return null;\n      }\n      const stats = await response.json();\n\n      // Cache the statistics\n      const updatedStats = {\n        ...profileStatistics,\n        [profileId]: {\n          data: stats,\n          loadedAt: Date.now()\n        }\n      };\n      setProfileStatistics(updatedStats);\n      saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n      return stats;\n    } catch (err) {\n      console.error('Error loading profile statistics:', err);\n      return null;\n    }\n  }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n  const updateLastPlayed = useCallback(async profileId => {\n    try {\n      await fetch(`/api/players/${profileId}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          last_played: new Date().toISOString()\n        })\n      });\n    } catch (err) {\n      console.error('Error updating last played:', err);\n      // Don't throw - this is not critical\n    }\n  }, [STORAGE_KEYS.LAST_SYNC]);\n  const recordGameResult = useCallback(async gameResult => {\n    try {\n      const response = await fetch('/api/game-results', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(gameResult)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to record game result');\n      }\n      const result = await response.json();\n\n      // Invalidate cached statistics for the player\n      const updatedStats = {\n        ...profileStatistics\n      };\n      delete updatedStats[gameResult.player_profile_id];\n      setProfileStatistics(updatedStats);\n      saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n      return result;\n    } catch (err) {\n      console.error('Error recording game result:', err);\n      setError(err.message);\n      throw err;\n    }\n  }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n  const getProfileById = useCallback(profileId => {\n    return profiles.find(p => p.id === profileId);\n  }, [profiles]);\n  const getProfileByName = useCallback(name => {\n    return profiles.find(p => p.name.toLowerCase() === name.toLowerCase());\n  }, [profiles]);\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n  const refreshProfiles = useCallback(async () => {\n    await syncWithServer();\n  }, [syncWithServer]);\n\n  // Export/Import functionality\n  const exportProfileData = useCallback(async profileId => {\n    try {\n      const profile = getProfileById(profileId);\n      const statistics = await loadProfileStatistics(profileId);\n      const exportData = {\n        profile,\n        statistics,\n        exportedAt: new Date().toISOString(),\n        version: '1.0'\n      };\n\n      // Create and download file\n      const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n        type: 'application/json'\n      });\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `wgp-profile-${profile.name}-${new Date().toISOString().split('T')[0]}.json`;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      console.error('Error exporting profile data:', err);\n      setError('Failed to export profile data');\n    }\n  }, [getProfileById, loadProfileStatistics, selectedProfile]);\n\n  // Check if profile exists locally\n  const hasProfiles = profiles.length > 0;\n  const hasSelectedProfile = selectedProfile !== null;\n\n  // Get current profile statistics\n  const currentProfileStats = selectedProfile ? (_profileStatistics$se = profileStatistics[selectedProfile.id]) === null || _profileStatistics$se === void 0 ? void 0 : _profileStatistics$se.data : null;\n  return {\n    // State\n    selectedProfile,\n    profiles,\n    profileStatistics: currentProfileStats,\n    loading,\n    error,\n    syncStatus,\n    hasProfiles,\n    hasSelectedProfile,\n    // Actions\n    selectProfile,\n    createProfile,\n    updateProfile,\n    deleteProfile,\n    loadProfileStatistics,\n    recordGameResult,\n    refreshProfiles,\n    exportProfileData,\n    clearError,\n    // Utilities\n    getProfileById,\n    getProfileByName,\n    syncWithServer\n  };\n};\n_s(usePlayerProfile, \"IOv3bGLZ7jFy+7iablyIFqH6q3Q=\");\nexport default usePlayerProfile;","map":{"version":3,"names":["useState","useEffect","useCallback","usePlayerProfile","_s","_profileStatistics$se","selectedProfile","setSelectedProfile","profiles","setProfiles","profileStatistics","setProfileStatistics","loading","setLoading","error","setError","syncStatus","setSyncStatus","STORAGE_KEYS","SELECTED_PROFILE","PROFILES_CACHE","STATISTICS_CACHE","LAST_SYNC","loadInitialData","loadFromLocalStorage","syncWithServer","err","console","savedProfile","localStorage","getItem","JSON","parse","cachedProfiles","cachedStats","Object","values","forEach","key","removeItem","saveToLocalStorage","data","setItem","stringify","response","fetch","ok","Error","serverProfiles","json","updatedProfile","find","p","id","Date","now","toString","setTimeout","selectProfile","profile","loadProfileStatistics","updateLastPlayed","createProfile","profileData","method","headers","body","errorData","detail","newProfile","updatedProfiles","message","updateProfile","profileId","updateData","map","deleteProfile","filter","updatedStats","cached","loadedAt","stats","last_played","toISOString","recordGameResult","gameResult","result","player_profile_id","getProfileById","getProfileByName","name","toLowerCase","clearError","refreshProfiles","exportProfileData","statistics","exportData","exportedAt","version","blob","Blob","type","url","URL","createObjectURL","link","document","createElement","href","download","split","appendChild","click","removeChild","revokeObjectURL","hasProfiles","length","hasSelectedProfile","currentProfileStats"],"sources":["/Users/stuartgano/Documents/wolf-goat-pig/frontend/src/hooks/usePlayerProfile.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\n\n/**\n * usePlayerProfile - Custom hook for player profile management\n * \n * Features:\n * - Profile selection and persistence\n * - Local storage integration\n * - Profile statistics caching\n * - Real-time profile updates\n * - Error handling and loading states\n */\nconst usePlayerProfile = () => {\n    const [selectedProfile, setSelectedProfile] = useState(null);\n    const [profiles, setProfiles] = useState([]);\n    const [profileStatistics, setProfileStatistics] = useState({});\n    const [loading, setLoading] = useState(false);\n    const [error, setError] = useState(null);\n    const [syncStatus, setSyncStatus] = useState('idle'); // 'idle', 'syncing', 'success', 'error'\n\n    // Storage keys\n    const STORAGE_KEYS = {\n        SELECTED_PROFILE: 'wgp_selected_profile',\n        PROFILES_CACHE: 'wgp_profiles_cache',\n        STATISTICS_CACHE: 'wgp_statistics_cache',\n        LAST_SYNC: 'wgp_last_sync'\n    };\n\n    const loadInitialData = useCallback(async () => {\n        try {\n            setLoading(true);\n            \n            // Load from localStorage first for immediate UI\n            loadFromLocalStorage();\n            \n            // Then sync with server\n            await syncWithServer();\n        } catch (err) {\n            console.error('Error loading initial data:', err);\n            setError('Failed to load player profiles');\n        } finally {\n            setLoading(false);\n        }\n    }, []); // Add dependencies array for useCallback\n\n    const loadFromLocalStorage = () => {\n        try {\n            // Load selected profile\n            const savedProfile = localStorage.getItem(STORAGE_KEYS.SELECTED_PROFILE);\n            if (savedProfile) {\n                setSelectedProfile(JSON.parse(savedProfile));\n            }\n\n            // Load profiles cache\n            const cachedProfiles = localStorage.getItem(STORAGE_KEYS.PROFILES_CACHE);\n            if (cachedProfiles) {\n                setProfiles(JSON.parse(cachedProfiles));\n            }\n\n            // Load statistics cache\n            const cachedStats = localStorage.getItem(STORAGE_KEYS.STATISTICS_CACHE);\n            if (cachedStats) {\n                setProfileStatistics(JSON.parse(cachedStats));\n            }\n        } catch (err) {\n            console.error('Error loading from localStorage:', err);\n            // Clear corrupted data\n            Object.values(STORAGE_KEYS).forEach(key => {\n                localStorage.removeItem(key);\n            });\n        }\n    };\n\n    const saveToLocalStorage = (key, data) => {\n        try {\n            localStorage.setItem(key, JSON.stringify(data));\n        } catch (err) {\n            console.error('Error saving to localStorage:', err);\n        }\n    };\n\n    const syncWithServer = useCallback(async () => {\n        try {\n            setSyncStatus('syncing');\n            \n            // Fetch latest profiles from server\n            const response = await fetch('/api/players');\n            if (!response.ok) {\n                throw new Error('Failed to fetch profiles from server');\n            }\n            \n            const serverProfiles = await response.json();\n            setProfiles(serverProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, serverProfiles);\n\n            // Update selected profile if it exists on server\n            if (selectedProfile) {\n                const updatedProfile = serverProfiles.find(p => p.id === selectedProfile.id);\n                if (updatedProfile) {\n                    setSelectedProfile(updatedProfile);\n                    saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n                }\n            }\n\n            // Mark last sync time\n            localStorage.setItem(STORAGE_KEYS.LAST_SYNC, Date.now().toString());\n            setSyncStatus('success');\n            \n            // Clear sync status after 2 seconds\n            setTimeout(() => setSyncStatus('idle'), 2000);\n            \n        } catch (err) {\n            console.error('Error syncing with server:', err);\n            setSyncStatus('error');\n            \n            // Clear error status after 5 seconds\n            setTimeout(() => setSyncStatus('idle'), 5000);\n        }\n    }, [selectedProfile]);\n\n    const selectProfile = useCallback(async (profile) => {\n        try {\n            setSelectedProfile(profile);\n            saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, profile);\n            \n            // Load statistics for the selected profile\n            await loadProfileStatistics(profile.id);\n            \n            // Update last played on server\n            await updateLastPlayed(profile.id);\n            \n        } catch (err) {\n            console.error('Error selecting profile:', err);\n            setError('Failed to select profile');\n        }\n    }, [loadProfileStatistics, updateLastPlayed, STORAGE_KEYS.SELECTED_PROFILE]);\n\n    const createProfile = useCallback(async (profileData) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch('/api/players', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(profileData)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to create profile');\n            }\n\n            const newProfile = await response.json();\n            \n            // Update local state\n            const updatedProfiles = [...profiles, newProfile];\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Auto-select the new profile\n            await selectProfile(newProfile);\n            \n            return newProfile;\n            \n        } catch (err) {\n            console.error('Error creating profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectProfile, STORAGE_KEYS.PROFILES_CACHE]);\n\n    const updateProfile = useCallback(async (profileId, updateData) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch(`/api/players/${profileId}`, {\n                method: 'PUT',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(updateData)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to update profile');\n            }\n\n            const updatedProfile = await response.json();\n            \n            // Update local state\n            const updatedProfiles = profiles.map(p => \n                p.id === profileId ? updatedProfile : p\n            );\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Update selected profile if it's the one being updated\n            if (selectedProfile && selectedProfile.id === profileId) {\n                setSelectedProfile(updatedProfile);\n                saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n            }\n            \n            return updatedProfile;\n            \n        } catch (err) {\n            console.error('Error updating profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectedProfile, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE]);\n\n    const deleteProfile = useCallback(async (profileId) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch(`/api/players/${profileId}`, {\n                method: 'DELETE'\n            });\n\n            if (!response.ok) {\n                throw new Error('Failed to delete profile');\n            }\n\n            // Update local state\n            const updatedProfiles = profiles.filter(p => p.id !== profileId);\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Clear selected profile if it was deleted\n            if (selectedProfile && selectedProfile.id === profileId) {\n                setSelectedProfile(null);\n                localStorage.removeItem(STORAGE_KEYS.SELECTED_PROFILE);\n            }\n            \n            // Remove from statistics cache\n            const updatedStats = { ...profileStatistics };\n            delete updatedStats[profileId];\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n        } catch (err) {\n            console.error('Error deleting profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectedProfile, profileStatistics, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE, STORAGE_KEYS.STATISTICS_CACHE]);\n\n    const loadProfileStatistics = useCallback(async (profileId) => {\n        try {\n            // Return cached statistics if available and recent\n            const cached = profileStatistics[profileId];\n            if (cached && (Date.now() - cached.loadedAt) < 300000) { // 5 minutes\n                return cached.data;\n            }\n            \n            const response = await fetch(`/api/players/${profileId}/statistics`);\n            if (!response.ok) {\n                // Statistics might not exist for new profiles\n                return null;\n            }\n            \n            const stats = await response.json();\n            \n            // Cache the statistics\n            const updatedStats = {\n                ...profileStatistics,\n                [profileId]: {\n                    data: stats,\n                    loadedAt: Date.now()\n                }\n            };\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n            return stats;\n            \n        } catch (err) {\n            console.error('Error loading profile statistics:', err);\n            return null;\n        }\n    }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n\n    const updateLastPlayed = useCallback(async (profileId) => {\n        try {\n            await fetch(`/api/players/${profileId}`, {\n                method: 'PUT',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    last_played: new Date().toISOString()\n                })\n            });\n        } catch (err) {\n            console.error('Error updating last played:', err);\n            // Don't throw - this is not critical\n        }\n    }, [STORAGE_KEYS.LAST_SYNC]);\n\n    const recordGameResult = useCallback(async (gameResult) => {\n        try {\n            const response = await fetch('/api/game-results', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(gameResult)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to record game result');\n            }\n\n            const result = await response.json();\n            \n            // Invalidate cached statistics for the player\n            const updatedStats = { ...profileStatistics };\n            delete updatedStats[gameResult.player_profile_id];\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n            return result;\n            \n        } catch (err) {\n            console.error('Error recording game result:', err);\n            setError(err.message);\n            throw err;\n        }\n    }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n\n    const getProfileById = useCallback((profileId) => {\n        return profiles.find(p => p.id === profileId);\n    }, [profiles]);\n\n    const getProfileByName = useCallback((name) => {\n        return profiles.find(p => p.name.toLowerCase() === name.toLowerCase());\n    }, [profiles]);\n\n    const clearError = useCallback(() => {\n        setError(null);\n    }, []);\n\n    const refreshProfiles = useCallback(async () => {\n        await syncWithServer();\n    }, [syncWithServer]);\n\n    // Export/Import functionality\n    const exportProfileData = useCallback(async (profileId) => {\n        try {\n            const profile = getProfileById(profileId);\n            const statistics = await loadProfileStatistics(profileId);\n            \n            const exportData = {\n                profile,\n                statistics,\n                exportedAt: new Date().toISOString(),\n                version: '1.0'\n            };\n            \n            // Create and download file\n            const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n                type: 'application/json'\n            });\n            const url = URL.createObjectURL(blob);\n            const link = document.createElement('a');\n            link.href = url;\n            link.download = `wgp-profile-${profile.name}-${new Date().toISOString().split('T')[0]}.json`;\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n            URL.revokeObjectURL(url);\n            \n        } catch (err) {\n            console.error('Error exporting profile data:', err);\n            setError('Failed to export profile data');\n        }\n    }, [getProfileById, loadProfileStatistics, selectedProfile]);\n\n    // Check if profile exists locally\n    const hasProfiles = profiles.length > 0;\n    const hasSelectedProfile = selectedProfile !== null;\n    \n    // Get current profile statistics\n    const currentProfileStats = selectedProfile ? \n        profileStatistics[selectedProfile.id]?.data : null;\n\n    return {\n        // State\n        selectedProfile,\n        profiles,\n        profileStatistics: currentProfileStats,\n        loading,\n        error,\n        syncStatus,\n        hasProfiles,\n        hasSelectedProfile,\n        \n        // Actions\n        selectProfile,\n        createProfile,\n        updateProfile,\n        deleteProfile,\n        loadProfileStatistics,\n        recordGameResult,\n        refreshProfiles,\n        exportProfileData,\n        clearError,\n        \n        // Utilities\n        getProfileById,\n        getProfileByName,\n        syncWithServer\n    };\n};\n\nexport default usePlayerProfile;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
./node_modules/.cache/babel-loader/652acf477e7f0c4907b718f1793e77451afe08bd7521ba20ec500b543b9ea506.json:1:{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\n\n/**\n * usePlayerProfile - Custom hook for player profile management\n * \n * Features:\n * - Profile selection and persistence\n * - Local storage integration\n * - Profile statistics caching\n * - Real-time profile updates\n * - Error handling and loading states\n */\nconst usePlayerProfile = () => {\n  _s();\n  var _profileStatistics$se;\n  const [selectedProfile, setSelectedProfile] = useState(null);\n  const [profiles, setProfiles] = useState([]);\n  const [profileStatistics, setProfileStatistics] = useState({});\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [syncStatus, setSyncStatus] = useState('idle'); // 'idle', 'syncing', 'success', 'error'\n\n  // Storage keys\n  const STORAGE_KEYS = {\n    SELECTED_PROFILE: 'wgp_selected_profile',\n    PROFILES_CACHE: 'wgp_profiles_cache',\n    STATISTICS_CACHE: 'wgp_statistics_cache',\n    LAST_SYNC: 'wgp_last_sync'\n  };\n  const loadInitialData = useCallback(async () => {\n    try {\n      setLoading(true);\n\n      // Load from localStorage first for immediate UI\n      loadFromLocalStorage();\n\n      // Then sync with server\n      await syncWithServer();\n    } catch (err) {\n      console.error('Error loading initial data:', err);\n      setError('Failed to load player profiles');\n    } finally {\n      setLoading(false);\n    }\n  }, []); // Add dependencies array for useCallback\n\n  // Load initial data on mount\n  useEffect(() => {\n    loadInitialData();\n  }, [loadInitialData]);\n  const loadFromLocalStorage = () => {\n    try {\n      // Load selected profile\n      const savedProfile = localStorage.getItem(STORAGE_KEYS.SELECTED_PROFILE);\n      if (savedProfile) {\n        setSelectedProfile(JSON.parse(savedProfile));\n      }\n\n      // Load profiles cache\n      const cachedProfiles = localStorage.getItem(STORAGE_KEYS.PROFILES_CACHE);\n      if (cachedProfiles) {\n        setProfiles(JSON.parse(cachedProfiles));\n      }\n\n      // Load statistics cache\n      const cachedStats = localStorage.getItem(STORAGE_KEYS.STATISTICS_CACHE);\n      if (cachedStats) {\n        setProfileStatistics(JSON.parse(cachedStats));\n      }\n    } catch (err) {\n      console.error('Error loading from localStorage:', err);\n      // Clear corrupted data\n      Object.values(STORAGE_KEYS).forEach(key => {\n        localStorage.removeItem(key);\n      });\n    }\n  };\n  const saveToLocalStorage = (key, data) => {\n    try {\n      localStorage.setItem(key, JSON.stringify(data));\n    } catch (err) {\n      console.error('Error saving to localStorage:', err);\n    }\n  };\n  const syncWithServer = useCallback(async () => {\n    try {\n      setSyncStatus('syncing');\n\n      // Fetch latest profiles from server\n      const response = await fetch('/api/players');\n      if (!response.ok) {\n        throw new Error('Failed to fetch profiles from server');\n      }\n      const serverProfiles = await response.json();\n      setProfiles(serverProfiles);\n      saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, serverProfiles);\n\n      // Update selected profile if it exists on server\n      if (selectedProfile) {\n        const updatedProfile = serverProfiles.find(p => p.id === selectedProfile.id);\n        if (updatedProfile) {\n          setSelectedProfile(updatedProfile);\n          saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n        }\n      }\n\n      // Mark last sync time\n      localStorage.setItem(STORAGE_KEYS.LAST_SYNC, Date.now().toString());\n      setSyncStatus('success');\n\n      // Clear sync status after 2 seconds\n      setTimeout(() => setSyncStatus('idle'), 2000);\n    } catch (err) {\n      console.error('Error syncing with server:', err);\n      setSyncStatus('error');\n\n      // Clear error status after 5 seconds\n      setTimeout(() => setSyncStatus('idle'), 5000);\n    }\n  }, [selectedProfile]);\n  const selectProfile = useCallback(async profile => {\n    try {\n      setSelectedProfile(profile);\n      saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, profile);\n\n      // Load statistics for the selected profile\n      await loadProfileStatistics(profile.id);\n\n      // Update last played on server\n      await updateLastPlayed(profile.id);\n    } catch (err) {\n      console.error('Error selecting profile:', err);\n      setError('Failed to select profile');\n    }\n  }, [loadProfileStatistics, updateLastPlayed, STORAGE_KEYS.SELECTED_PROFILE]);\n  const createProfile = useCallback(async profileData => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await fetch('/api/players', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(profileData)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to create profile');\n      }\n      const newProfile = await response.json();\n\n      // Update local state\n      const updatedProfiles = [...profiles, newProfile];\n      setProfiles(updatedProfiles);\n      saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n\n      // Auto-select the new profile\n      await selectProfile(newProfile);\n      return newProfile;\n    } catch (err) {\n      console.error('Error creating profile:', err);\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [profiles, selectProfile, STORAGE_KEYS.PROFILES_CACHE]);\n  const updateProfile = useCallback(async (profileId, updateData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await fetch(`/api/players/${profileId}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(updateData)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to update profile');\n      }\n      const updatedProfile = await response.json();\n\n      // Update local state\n      const updatedProfiles = profiles.map(p => p.id === profileId ? updatedProfile : p);\n      setProfiles(updatedProfiles);\n      saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n\n      // Update selected profile if it's the one being updated\n      if (selectedProfile && selectedProfile.id === profileId) {\n        setSelectedProfile(updatedProfile);\n        saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n      }\n      return updatedProfile;\n    } catch (err) {\n      console.error('Error updating profile:', err);\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [profiles, selectedProfile, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE]);\n  const deleteProfile = useCallback(async profileId => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await fetch(`/api/players/${profileId}`, {\n        method: 'DELETE'\n      });\n      if (!response.ok) {\n        throw new Error('Failed to delete profile');\n      }\n\n      // Update local state\n      const updatedProfiles = profiles.filter(p => p.id !== profileId);\n      setProfiles(updatedProfiles);\n      saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n\n      // Clear selected profile if it was deleted\n      if (selectedProfile && selectedProfile.id === profileId) {\n        setSelectedProfile(null);\n        localStorage.removeItem(STORAGE_KEYS.SELECTED_PROFILE);\n      }\n\n      // Remove from statistics cache\n      const updatedStats = {\n        ...profileStatistics\n      };\n      delete updatedStats[profileId];\n      setProfileStatistics(updatedStats);\n      saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n    } catch (err) {\n      console.error('Error deleting profile:', err);\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [profiles, selectedProfile, profileStatistics, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE, STORAGE_KEYS.STATISTICS_CACHE]);\n  const loadProfileStatistics = useCallback(async profileId => {\n    try {\n      // Return cached statistics if available and recent\n      const cached = profileStatistics[profileId];\n      if (cached && Date.now() - cached.loadedAt < 300000) {\n        // 5 minutes\n        return cached.data;\n      }\n      const response = await fetch(`/api/players/${profileId}/statistics`);\n      if (!response.ok) {\n        // Statistics might not exist for new profiles\n        return null;\n      }\n      const stats = await response.json();\n\n      // Cache the statistics\n      const updatedStats = {\n        ...profileStatistics,\n        [profileId]: {\n          data: stats,\n          loadedAt: Date.now()\n        }\n      };\n      setProfileStatistics(updatedStats);\n      saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n      return stats;\n    } catch (err) {\n      console.error('Error loading profile statistics:', err);\n      return null;\n    }\n  }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n  const updateLastPlayed = useCallback(async profileId => {\n    try {\n      await fetch(`/api/players/${profileId}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          last_played: new Date().toISOString()\n        })\n      });\n    } catch (err) {\n      console.error('Error updating last played:', err);\n      // Don't throw - this is not critical\n    }\n  }, [STORAGE_KEYS.LAST_SYNC]);\n  const recordGameResult = useCallback(async gameResult => {\n    try {\n      const response = await fetch('/api/game-results', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(gameResult)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to record game result');\n      }\n      const result = await response.json();\n\n      // Invalidate cached statistics for the player\n      const updatedStats = {\n        ...profileStatistics\n      };\n      delete updatedStats[gameResult.player_profile_id];\n      setProfileStatistics(updatedStats);\n      saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n      return result;\n    } catch (err) {\n      console.error('Error recording game result:', err);\n      setError(err.message);\n      throw err;\n    }\n  }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n  const getProfileById = useCallback(profileId => {\n    return profiles.find(p => p.id === profileId);\n  }, [profiles]);\n  const getProfileByName = useCallback(name => {\n    return profiles.find(p => p.name.toLowerCase() === name.toLowerCase());\n  }, [profiles]);\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n  const refreshProfiles = useCallback(async () => {\n    await syncWithServer();\n  }, [syncWithServer]);\n\n  // Export/Import functionality\n  const exportProfileData = useCallback(async profileId => {\n    try {\n      const profile = getProfileById(profileId);\n      const statistics = await loadProfileStatistics(profileId);\n      const exportData = {\n        profile,\n        statistics,\n        exportedAt: new Date().toISOString(),\n        version: '1.0'\n      };\n\n      // Create and download file\n      const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n        type: 'application/json'\n      });\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `wgp-profile-${profile.name}-${new Date().toISOString().split('T')[0]}.json`;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      console.error('Error exporting profile data:', err);\n      setError('Failed to export profile data');\n    }\n  }, [getProfileById, loadProfileStatistics, selectedProfile]);\n\n  // Check if profile exists locally\n  const hasProfiles = profiles.length > 0;\n  const hasSelectedProfile = selectedProfile !== null;\n\n  // Get current profile statistics\n  const currentProfileStats = selectedProfile ? (_profileStatistics$se = profileStatistics[selectedProfile.id]) === null || _profileStatistics$se === void 0 ? void 0 : _profileStatistics$se.data : null;\n  return {\n    // State\n    selectedProfile,\n    profiles,\n    profileStatistics: currentProfileStats,\n    loading,\n    error,\n    syncStatus,\n    hasProfiles,\n    hasSelectedProfile,\n    // Actions\n    selectProfile,\n    createProfile,\n    updateProfile,\n    deleteProfile,\n    loadProfileStatistics,\n    recordGameResult,\n    refreshProfiles,\n    exportProfileData,\n    clearError,\n    // Utilities\n    getProfileById,\n    getProfileByName,\n    syncWithServer\n  };\n};\n_s(usePlayerProfile, \"Z61xRDp93FZKTO7wkRCyx/8TBn4=\");\nexport default usePlayerProfile;","map":{"version":3,"names":["useState","useEffect","useCallback","usePlayerProfile","_s","_profileStatistics$se","selectedProfile","setSelectedProfile","profiles","setProfiles","profileStatistics","setProfileStatistics","loading","setLoading","error","setError","syncStatus","setSyncStatus","STORAGE_KEYS","SELECTED_PROFILE","PROFILES_CACHE","STATISTICS_CACHE","LAST_SYNC","loadInitialData","loadFromLocalStorage","syncWithServer","err","console","savedProfile","localStorage","getItem","JSON","parse","cachedProfiles","cachedStats","Object","values","forEach","key","removeItem","saveToLocalStorage","data","setItem","stringify","response","fetch","ok","Error","serverProfiles","json","updatedProfile","find","p","id","Date","now","toString","setTimeout","selectProfile","profile","loadProfileStatistics","updateLastPlayed","createProfile","profileData","method","headers","body","errorData","detail","newProfile","updatedProfiles","message","updateProfile","profileId","updateData","map","deleteProfile","filter","updatedStats","cached","loadedAt","stats","last_played","toISOString","recordGameResult","gameResult","result","player_profile_id","getProfileById","getProfileByName","name","toLowerCase","clearError","refreshProfiles","exportProfileData","statistics","exportData","exportedAt","version","blob","Blob","type","url","URL","createObjectURL","link","document","createElement","href","download","split","appendChild","click","removeChild","revokeObjectURL","hasProfiles","length","hasSelectedProfile","currentProfileStats"],"sources":["/Users/stuartgano/Documents/wolf-goat-pig/frontend/src/hooks/usePlayerProfile.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\n\n/**\n * usePlayerProfile - Custom hook for player profile management\n * \n * Features:\n * - Profile selection and persistence\n * - Local storage integration\n * - Profile statistics caching\n * - Real-time profile updates\n * - Error handling and loading states\n */\nconst usePlayerProfile = () => {\n    const [selectedProfile, setSelectedProfile] = useState(null);\n    const [profiles, setProfiles] = useState([]);\n    const [profileStatistics, setProfileStatistics] = useState({});\n    const [loading, setLoading] = useState(false);\n    const [error, setError] = useState(null);\n    const [syncStatus, setSyncStatus] = useState('idle'); // 'idle', 'syncing', 'success', 'error'\n\n    // Storage keys\n    const STORAGE_KEYS = {\n        SELECTED_PROFILE: 'wgp_selected_profile',\n        PROFILES_CACHE: 'wgp_profiles_cache',\n        STATISTICS_CACHE: 'wgp_statistics_cache',\n        LAST_SYNC: 'wgp_last_sync'\n    };\n\n    const loadInitialData = useCallback(async () => {\n        try {\n            setLoading(true);\n            \n            // Load from localStorage first for immediate UI\n            loadFromLocalStorage();\n            \n            // Then sync with server\n            await syncWithServer();\n        } catch (err) {\n            console.error('Error loading initial data:', err);\n            setError('Failed to load player profiles');\n        } finally {\n            setLoading(false);\n        }\n    }, []); // Add dependencies array for useCallback\n\n    // Load initial data on mount\n    useEffect(() => {\n        loadInitialData();\n    }, [loadInitialData]);\n\n    const loadFromLocalStorage = () => {\n        try {\n            // Load selected profile\n            const savedProfile = localStorage.getItem(STORAGE_KEYS.SELECTED_PROFILE);\n            if (savedProfile) {\n                setSelectedProfile(JSON.parse(savedProfile));\n            }\n\n            // Load profiles cache\n            const cachedProfiles = localStorage.getItem(STORAGE_KEYS.PROFILES_CACHE);\n            if (cachedProfiles) {\n                setProfiles(JSON.parse(cachedProfiles));\n            }\n\n            // Load statistics cache\n            const cachedStats = localStorage.getItem(STORAGE_KEYS.STATISTICS_CACHE);\n            if (cachedStats) {\n                setProfileStatistics(JSON.parse(cachedStats));\n            }\n        } catch (err) {\n            console.error('Error loading from localStorage:', err);\n            // Clear corrupted data\n            Object.values(STORAGE_KEYS).forEach(key => {\n                localStorage.removeItem(key);\n            });\n        }\n    };\n\n    const saveToLocalStorage = (key, data) => {\n        try {\n            localStorage.setItem(key, JSON.stringify(data));\n        } catch (err) {\n            console.error('Error saving to localStorage:', err);\n        }\n    };\n\n    const syncWithServer = useCallback(async () => {\n        try {\n            setSyncStatus('syncing');\n            \n            // Fetch latest profiles from server\n            const response = await fetch('/api/players');\n            if (!response.ok) {\n                throw new Error('Failed to fetch profiles from server');\n            }\n            \n            const serverProfiles = await response.json();\n            setProfiles(serverProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, serverProfiles);\n\n            // Update selected profile if it exists on server\n            if (selectedProfile) {\n                const updatedProfile = serverProfiles.find(p => p.id === selectedProfile.id);\n                if (updatedProfile) {\n                    setSelectedProfile(updatedProfile);\n                    saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n                }\n            }\n\n            // Mark last sync time\n            localStorage.setItem(STORAGE_KEYS.LAST_SYNC, Date.now().toString());\n            setSyncStatus('success');\n            \n            // Clear sync status after 2 seconds\n            setTimeout(() => setSyncStatus('idle'), 2000);\n            \n        } catch (err) {\n            console.error('Error syncing with server:', err);\n            setSyncStatus('error');\n            \n            // Clear error status after 5 seconds\n            setTimeout(() => setSyncStatus('idle'), 5000);\n        }\n    }, [selectedProfile]);\n\n    const selectProfile = useCallback(async (profile) => {\n        try {\n            setSelectedProfile(profile);\n            saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, profile);\n            \n            // Load statistics for the selected profile\n            await loadProfileStatistics(profile.id);\n            \n            // Update last played on server\n            await updateLastPlayed(profile.id);\n            \n        } catch (err) {\n            console.error('Error selecting profile:', err);\n            setError('Failed to select profile');\n        }\n    }, [loadProfileStatistics, updateLastPlayed, STORAGE_KEYS.SELECTED_PROFILE]);\n\n    const createProfile = useCallback(async (profileData) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch('/api/players', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(profileData)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to create profile');\n            }\n\n            const newProfile = await response.json();\n            \n            // Update local state\n            const updatedProfiles = [...profiles, newProfile];\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Auto-select the new profile\n            await selectProfile(newProfile);\n            \n            return newProfile;\n            \n        } catch (err) {\n            console.error('Error creating profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectProfile, STORAGE_KEYS.PROFILES_CACHE]);\n\n    const updateProfile = useCallback(async (profileId, updateData) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch(`/api/players/${profileId}`, {\n                method: 'PUT',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(updateData)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to update profile');\n            }\n\n            const updatedProfile = await response.json();\n            \n            // Update local state\n            const updatedProfiles = profiles.map(p => \n                p.id === profileId ? updatedProfile : p\n            );\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Update selected profile if it's the one being updated\n            if (selectedProfile && selectedProfile.id === profileId) {\n                setSelectedProfile(updatedProfile);\n                saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n            }\n            \n            return updatedProfile;\n            \n        } catch (err) {\n            console.error('Error updating profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectedProfile, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE]);\n\n    const deleteProfile = useCallback(async (profileId) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch(`/api/players/${profileId}`, {\n                method: 'DELETE'\n            });\n\n            if (!response.ok) {\n                throw new Error('Failed to delete profile');\n            }\n\n            // Update local state\n            const updatedProfiles = profiles.filter(p => p.id !== profileId);\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Clear selected profile if it was deleted\n            if (selectedProfile && selectedProfile.id === profileId) {\n                setSelectedProfile(null);\n                localStorage.removeItem(STORAGE_KEYS.SELECTED_PROFILE);\n            }\n            \n            // Remove from statistics cache\n            const updatedStats = { ...profileStatistics };\n            delete updatedStats[profileId];\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n        } catch (err) {\n            console.error('Error deleting profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectedProfile, profileStatistics, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE, STORAGE_KEYS.STATISTICS_CACHE]);\n\n    const loadProfileStatistics = useCallback(async (profileId) => {\n        try {\n            // Return cached statistics if available and recent\n            const cached = profileStatistics[profileId];\n            if (cached && (Date.now() - cached.loadedAt) < 300000) { // 5 minutes\n                return cached.data;\n            }\n            \n            const response = await fetch(`/api/players/${profileId}/statistics`);\n            if (!response.ok) {\n                // Statistics might not exist for new profiles\n                return null;\n            }\n            \n            const stats = await response.json();\n            \n            // Cache the statistics\n            const updatedStats = {\n                ...profileStatistics,\n                [profileId]: {\n                    data: stats,\n                    loadedAt: Date.now()\n                }\n            };\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n            return stats;\n            \n        } catch (err) {\n            console.error('Error loading profile statistics:', err);\n            return null;\n        }\n    }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n\n    const updateLastPlayed = useCallback(async (profileId) => {\n        try {\n            await fetch(`/api/players/${profileId}`, {\n                method: 'PUT',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    last_played: new Date().toISOString()\n                })\n            });\n        } catch (err) {\n            console.error('Error updating last played:', err);\n            // Don't throw - this is not critical\n        }\n    }, [STORAGE_KEYS.LAST_SYNC]);\n\n    const recordGameResult = useCallback(async (gameResult) => {\n        try {\n            const response = await fetch('/api/game-results', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(gameResult)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to record game result');\n            }\n\n            const result = await response.json();\n            \n            // Invalidate cached statistics for the player\n            const updatedStats = { ...profileStatistics };\n            delete updatedStats[gameResult.player_profile_id];\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n            return result;\n            \n        } catch (err) {\n            console.error('Error recording game result:', err);\n            setError(err.message);\n            throw err;\n        }\n    }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n\n    const getProfileById = useCallback((profileId) => {\n        return profiles.find(p => p.id === profileId);\n    }, [profiles]);\n\n    const getProfileByName = useCallback((name) => {\n        return profiles.find(p => p.name.toLowerCase() === name.toLowerCase());\n    }, [profiles]);\n\n    const clearError = useCallback(() => {\n        setError(null);\n    }, []);\n\n    const refreshProfiles = useCallback(async () => {\n        await syncWithServer();\n    }, [syncWithServer]);\n\n    // Export/Import functionality\n    const exportProfileData = useCallback(async (profileId) => {\n        try {\n            const profile = getProfileById(profileId);\n            const statistics = await loadProfileStatistics(profileId);\n            \n            const exportData = {\n                profile,\n                statistics,\n                exportedAt: new Date().toISOString(),\n                version: '1.0'\n            };\n            \n            // Create and download file\n            const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n                type: 'application/json'\n            });\n            const url = URL.createObjectURL(blob);\n            const link = document.createElement('a');\n            link.href = url;\n            link.download = `wgp-profile-${profile.name}-${new Date().toISOString().split('T')[0]}.json`;\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n            URL.revokeObjectURL(url);\n            \n        } catch (err) {\n            console.error('Error exporting profile data:', err);\n            setError('Failed to export profile data');\n        }\n    }, [getProfileById, loadProfileStatistics, selectedProfile]);\n\n    // Check if profile exists locally\n    const hasProfiles = profiles.length > 0;\n    const hasSelectedProfile = selectedProfile !== null;\n    \n    // Get current profile statistics\n    const currentProfileStats = selectedProfile ? \n        profileStatistics[selectedProfile.id]?.data : null;\n\n    return {\n        // State\n        selectedProfile,\n        profiles,\n        profileStatistics: currentProfileStats,\n        loading,\n        error,\n        syncStatus,\n        hasProfiles,\n        hasSelectedProfile,\n        \n        // Actions\n        selectProfile,\n        createProfile,\n        updateProfile,\n        deleteProfile,\n        loadProfileStatistics,\n        recordGameResult,\n        refreshProfiles,\n        exportProfileData,\n        clearError,\n        \n        // Utilities\n        getProfileById,\n        getProfileByName,\n        syncWithServer\n    };\n};\n\nexport default usePlayerProfile;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
./node_modules/.cache/babel-loader/44a97c0b06bd8ebb360537079a3390b628ee13f66bd1574c14b899df79a71433.json:1:{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\n\n/**\n * usePlayerProfile - Custom hook for player profile management\n * \n * Features:\n * - Profile selection and persistence\n * - Local storage integration\n * - Profile statistics caching\n * - Real-time profile updates\n * - Error handling and loading states\n */\nconst usePlayerProfile = () => {\n  _s();\n  var _profileStatistics$se;\n  const [selectedProfile, setSelectedProfile] = useState(null);\n  const [profiles, setProfiles] = useState([]);\n  const [profileStatistics, setProfileStatistics] = useState({});\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [syncStatus, setSyncStatus] = useState('idle'); // 'idle', 'syncing', 'success', 'error'\n\n  // Storage keys\n  const STORAGE_KEYS = {\n    SELECTED_PROFILE: 'wgp_selected_profile',\n    PROFILES_CACHE: 'wgp_profiles_cache',\n    STATISTICS_CACHE: 'wgp_statistics_cache',\n    LAST_SYNC: 'wgp_last_sync'\n  };\n\n  // Load initial data on mount\n  useEffect(() => {\n    loadInitialData();\n  }, [loadInitialData]);\n\n  // Sync with server periodically\n  useEffect(() => {\n    const interval = setInterval(() => {\n      const lastSync = localStorage.getItem(STORAGE_KEYS.LAST_SYNC);\n      const now = Date.now();\n      const fiveMinutes = 5 * 60 * 1000;\n\n      // Sync if more than 5 minutes since last sync\n      if (!lastSync || now - parseInt(lastSync) > fiveMinutes) {\n        syncWithServer();\n      }\n    }, 60000); // Check every minute\n\n    return () => clearInterval(interval);\n  }, [STORAGE_KEYS.LAST_SYNC, syncWithServer]);\n  const loadInitialData = async () => {\n    try {\n      setLoading(true);\n\n      // Load from localStorage first for immediate UI\n      loadFromLocalStorage();\n\n      // Then sync with server\n      await syncWithServer();\n    } catch (err) {\n      console.error('Error loading initial data:', err);\n      setError('Failed to load player profiles');\n    } finally {\n      setLoading(false);\n    }\n  };\n  const loadFromLocalStorage = () => {\n    try {\n      // Load selected profile\n      const savedProfile = localStorage.getItem(STORAGE_KEYS.SELECTED_PROFILE);\n      if (savedProfile) {\n        setSelectedProfile(JSON.parse(savedProfile));\n      }\n\n      // Load profiles cache\n      const cachedProfiles = localStorage.getItem(STORAGE_KEYS.PROFILES_CACHE);\n      if (cachedProfiles) {\n        setProfiles(JSON.parse(cachedProfiles));\n      }\n\n      // Load statistics cache\n      const cachedStats = localStorage.getItem(STORAGE_KEYS.STATISTICS_CACHE);\n      if (cachedStats) {\n        setProfileStatistics(JSON.parse(cachedStats));\n      }\n    } catch (err) {\n      console.error('Error loading from localStorage:', err);\n      // Clear corrupted data\n      Object.values(STORAGE_KEYS).forEach(key => {\n        localStorage.removeItem(key);\n      });\n    }\n  };\n  const saveToLocalStorage = (key, data) => {\n    try {\n      localStorage.setItem(key, JSON.stringify(data));\n    } catch (err) {\n      console.error('Error saving to localStorage:', err);\n    }\n  };\n  const syncWithServer = useCallback(async () => {\n    try {\n      setSyncStatus('syncing');\n\n      // Fetch latest profiles from server\n      const response = await fetch('/api/players');\n      if (!response.ok) {\n        throw new Error('Failed to fetch profiles from server');\n      }\n      const serverProfiles = await response.json();\n      setProfiles(serverProfiles);\n      saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, serverProfiles);\n\n      // Update selected profile if it exists on server\n      if (selectedProfile) {\n        const updatedProfile = serverProfiles.find(p => p.id === selectedProfile.id);\n        if (updatedProfile) {\n          setSelectedProfile(updatedProfile);\n          saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n        }\n      }\n\n      // Mark last sync time\n      localStorage.setItem(STORAGE_KEYS.LAST_SYNC, Date.now().toString());\n      setSyncStatus('success');\n\n      // Clear sync status after 2 seconds\n      setTimeout(() => setSyncStatus('idle'), 2000);\n    } catch (err) {\n      console.error('Error syncing with server:', err);\n      setSyncStatus('error');\n\n      // Clear error status after 5 seconds\n      setTimeout(() => setSyncStatus('idle'), 5000);\n    }\n  }, [selectedProfile]);\n  const selectProfile = useCallback(async profile => {\n    try {\n      setSelectedProfile(profile);\n      saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, profile);\n\n      // Load statistics for the selected profile\n      await loadProfileStatistics(profile.id);\n\n      // Update last played on server\n      await updateLastPlayed(profile.id);\n    } catch (err) {\n      console.error('Error selecting profile:', err);\n      setError('Failed to select profile');\n    }\n  }, [loadProfileStatistics, updateLastPlayed, STORAGE_KEYS.SELECTED_PROFILE]);\n  const createProfile = useCallback(async profileData => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await fetch('/api/players', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(profileData)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to create profile');\n      }\n      const newProfile = await response.json();\n\n      // Update local state\n      const updatedProfiles = [...profiles, newProfile];\n      setProfiles(updatedProfiles);\n      saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n\n      // Auto-select the new profile\n      await selectProfile(newProfile);\n      return newProfile;\n    } catch (err) {\n      console.error('Error creating profile:', err);\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [profiles, selectProfile, STORAGE_KEYS.PROFILES_CACHE]);\n  const updateProfile = useCallback(async (profileId, updateData) => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await fetch(`/api/players/${profileId}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(updateData)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to update profile');\n      }\n      const updatedProfile = await response.json();\n\n      // Update local state\n      const updatedProfiles = profiles.map(p => p.id === profileId ? updatedProfile : p);\n      setProfiles(updatedProfiles);\n      saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n\n      // Update selected profile if it's the one being updated\n      if (selectedProfile && selectedProfile.id === profileId) {\n        setSelectedProfile(updatedProfile);\n        saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n      }\n      return updatedProfile;\n    } catch (err) {\n      console.error('Error updating profile:', err);\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [profiles, selectedProfile, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE]);\n  const deleteProfile = useCallback(async profileId => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await fetch(`/api/players/${profileId}`, {\n        method: 'DELETE'\n      });\n      if (!response.ok) {\n        throw new Error('Failed to delete profile');\n      }\n\n      // Update local state\n      const updatedProfiles = profiles.filter(p => p.id !== profileId);\n      setProfiles(updatedProfiles);\n      saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n\n      // Clear selected profile if it was deleted\n      if (selectedProfile && selectedProfile.id === profileId) {\n        setSelectedProfile(null);\n        localStorage.removeItem(STORAGE_KEYS.SELECTED_PROFILE);\n      }\n\n      // Remove from statistics cache\n      const updatedStats = {\n        ...profileStatistics\n      };\n      delete updatedStats[profileId];\n      setProfileStatistics(updatedStats);\n      saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n    } catch (err) {\n      console.error('Error deleting profile:', err);\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [profiles, selectedProfile, profileStatistics, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE, STORAGE_KEYS.STATISTICS_CACHE]);\n  const loadProfileStatistics = useCallback(async profileId => {\n    try {\n      // Return cached statistics if available and recent\n      const cached = profileStatistics[profileId];\n      if (cached && Date.now() - cached.loadedAt < 300000) {\n        // 5 minutes\n        return cached.data;\n      }\n      const response = await fetch(`/api/players/${profileId}/statistics`);\n      if (!response.ok) {\n        // Statistics might not exist for new profiles\n        return null;\n      }\n      const stats = await response.json();\n\n      // Cache the statistics\n      const updatedStats = {\n        ...profileStatistics,\n        [profileId]: {\n          data: stats,\n          loadedAt: Date.now()\n        }\n      };\n      setProfileStatistics(updatedStats);\n      saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n      return stats;\n    } catch (err) {\n      console.error('Error loading profile statistics:', err);\n      return null;\n    }\n  }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n  const updateLastPlayed = useCallback(async profileId => {\n    try {\n      await fetch(`/api/players/${profileId}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          last_played: new Date().toISOString()\n        })\n      });\n    } catch (err) {\n      console.error('Error updating last played:', err);\n      // Don't throw - this is not critical\n    }\n  }, [STORAGE_KEYS.LAST_SYNC]);\n  const recordGameResult = useCallback(async gameResult => {\n    try {\n      const response = await fetch('/api/game-results', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(gameResult)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.detail || 'Failed to record game result');\n      }\n      const result = await response.json();\n\n      // Invalidate cached statistics for the player\n      const updatedStats = {\n        ...profileStatistics\n      };\n      delete updatedStats[gameResult.player_profile_id];\n      setProfileStatistics(updatedStats);\n      saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n      return result;\n    } catch (err) {\n      console.error('Error recording game result:', err);\n      setError(err.message);\n      throw err;\n    }\n  }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n  const getProfileById = useCallback(profileId => {\n    return profiles.find(p => p.id === profileId);\n  }, [profiles]);\n  const getProfileByName = useCallback(name => {\n    return profiles.find(p => p.name.toLowerCase() === name.toLowerCase());\n  }, [profiles]);\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n  const refreshProfiles = useCallback(async () => {\n    await syncWithServer();\n  }, [syncWithServer]);\n\n  // Export/Import functionality\n  const exportProfileData = useCallback(async profileId => {\n    try {\n      const profile = getProfileById(profileId);\n      const statistics = await loadProfileStatistics(profileId);\n      const exportData = {\n        profile,\n        statistics,\n        exportedAt: new Date().toISOString(),\n        version: '1.0'\n      };\n\n      // Create and download file\n      const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n        type: 'application/json'\n      });\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `wgp-profile-${profile.name}-${new Date().toISOString().split('T')[0]}.json`;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      console.error('Error exporting profile data:', err);\n      setError('Failed to export profile data');\n    }\n  }, [getProfileById, loadProfileStatistics, selectedProfile]);\n\n  // Check if profile exists locally\n  const hasProfiles = profiles.length > 0;\n  const hasSelectedProfile = selectedProfile !== null;\n\n  // Get current profile statistics\n  const currentProfileStats = selectedProfile ? (_profileStatistics$se = profileStatistics[selectedProfile.id]) === null || _profileStatistics$se === void 0 ? void 0 : _profileStatistics$se.data : null;\n  return {\n    // State\n    selectedProfile,\n    profiles,\n    profileStatistics: currentProfileStats,\n    loading,\n    error,\n    syncStatus,\n    hasProfiles,\n    hasSelectedProfile,\n    // Actions\n    selectProfile,\n    createProfile,\n    updateProfile,\n    deleteProfile,\n    loadProfileStatistics,\n    recordGameResult,\n    refreshProfiles,\n    exportProfileData,\n    clearError,\n    // Utilities\n    getProfileById,\n    getProfileByName,\n    syncWithServer\n  };\n};\n_s(usePlayerProfile, \"7OJ09n7hXsela0dRo2D6y8Of+sI=\");\nexport default usePlayerProfile;","map":{"version":3,"names":["useState","useEffect","useCallback","usePlayerProfile","_s","_profileStatistics$se","selectedProfile","setSelectedProfile","profiles","setProfiles","profileStatistics","setProfileStatistics","loading","setLoading","error","setError","syncStatus","setSyncStatus","STORAGE_KEYS","SELECTED_PROFILE","PROFILES_CACHE","STATISTICS_CACHE","LAST_SYNC","loadInitialData","interval","setInterval","lastSync","localStorage","getItem","now","Date","fiveMinutes","parseInt","syncWithServer","clearInterval","loadFromLocalStorage","err","console","savedProfile","JSON","parse","cachedProfiles","cachedStats","Object","values","forEach","key","removeItem","saveToLocalStorage","data","setItem","stringify","response","fetch","ok","Error","serverProfiles","json","updatedProfile","find","p","id","toString","setTimeout","selectProfile","profile","loadProfileStatistics","updateLastPlayed","createProfile","profileData","method","headers","body","errorData","detail","newProfile","updatedProfiles","message","updateProfile","profileId","updateData","map","deleteProfile","filter","updatedStats","cached","loadedAt","stats","last_played","toISOString","recordGameResult","gameResult","result","player_profile_id","getProfileById","getProfileByName","name","toLowerCase","clearError","refreshProfiles","exportProfileData","statistics","exportData","exportedAt","version","blob","Blob","type","url","URL","createObjectURL","link","document","createElement","href","download","split","appendChild","click","removeChild","revokeObjectURL","hasProfiles","length","hasSelectedProfile","currentProfileStats"],"sources":["/Users/stuartgano/Documents/wolf-goat-pig/frontend/src/hooks/usePlayerProfile.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\n\n/**\n * usePlayerProfile - Custom hook for player profile management\n * \n * Features:\n * - Profile selection and persistence\n * - Local storage integration\n * - Profile statistics caching\n * - Real-time profile updates\n * - Error handling and loading states\n */\nconst usePlayerProfile = () => {\n    const [selectedProfile, setSelectedProfile] = useState(null);\n    const [profiles, setProfiles] = useState([]);\n    const [profileStatistics, setProfileStatistics] = useState({});\n    const [loading, setLoading] = useState(false);\n    const [error, setError] = useState(null);\n    const [syncStatus, setSyncStatus] = useState('idle'); // 'idle', 'syncing', 'success', 'error'\n\n    // Storage keys\n    const STORAGE_KEYS = {\n        SELECTED_PROFILE: 'wgp_selected_profile',\n        PROFILES_CACHE: 'wgp_profiles_cache',\n        STATISTICS_CACHE: 'wgp_statistics_cache',\n        LAST_SYNC: 'wgp_last_sync'\n    };\n\n    // Load initial data on mount\n    useEffect(() => {\n        loadInitialData();\n    }, [loadInitialData]);\n\n    // Sync with server periodically\n    useEffect(() => {\n        const interval = setInterval(() => {\n            const lastSync = localStorage.getItem(STORAGE_KEYS.LAST_SYNC);\n            const now = Date.now();\n            const fiveMinutes = 5 * 60 * 1000;\n\n            // Sync if more than 5 minutes since last sync\n            if (!lastSync || (now - parseInt(lastSync)) > fiveMinutes) {\n                syncWithServer();\n            }\n        }, 60000); // Check every minute\n\n        return () => clearInterval(interval);\n    }, [STORAGE_KEYS.LAST_SYNC, syncWithServer]);\n\n    const loadInitialData = async () => {\n        try {\n            setLoading(true);\n            \n            // Load from localStorage first for immediate UI\n            loadFromLocalStorage();\n            \n            // Then sync with server\n            await syncWithServer();\n        } catch (err) {\n            console.error('Error loading initial data:', err);\n            setError('Failed to load player profiles');\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    const loadFromLocalStorage = () => {\n        try {\n            // Load selected profile\n            const savedProfile = localStorage.getItem(STORAGE_KEYS.SELECTED_PROFILE);\n            if (savedProfile) {\n                setSelectedProfile(JSON.parse(savedProfile));\n            }\n\n            // Load profiles cache\n            const cachedProfiles = localStorage.getItem(STORAGE_KEYS.PROFILES_CACHE);\n            if (cachedProfiles) {\n                setProfiles(JSON.parse(cachedProfiles));\n            }\n\n            // Load statistics cache\n            const cachedStats = localStorage.getItem(STORAGE_KEYS.STATISTICS_CACHE);\n            if (cachedStats) {\n                setProfileStatistics(JSON.parse(cachedStats));\n            }\n        } catch (err) {\n            console.error('Error loading from localStorage:', err);\n            // Clear corrupted data\n            Object.values(STORAGE_KEYS).forEach(key => {\n                localStorage.removeItem(key);\n            });\n        }\n    };\n\n    const saveToLocalStorage = (key, data) => {\n        try {\n            localStorage.setItem(key, JSON.stringify(data));\n        } catch (err) {\n            console.error('Error saving to localStorage:', err);\n        }\n    };\n\n    const syncWithServer = useCallback(async () => {\n        try {\n            setSyncStatus('syncing');\n            \n            // Fetch latest profiles from server\n            const response = await fetch('/api/players');\n            if (!response.ok) {\n                throw new Error('Failed to fetch profiles from server');\n            }\n            \n            const serverProfiles = await response.json();\n            setProfiles(serverProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, serverProfiles);\n\n            // Update selected profile if it exists on server\n            if (selectedProfile) {\n                const updatedProfile = serverProfiles.find(p => p.id === selectedProfile.id);\n                if (updatedProfile) {\n                    setSelectedProfile(updatedProfile);\n                    saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n                }\n            }\n\n            // Mark last sync time\n            localStorage.setItem(STORAGE_KEYS.LAST_SYNC, Date.now().toString());\n            setSyncStatus('success');\n            \n            // Clear sync status after 2 seconds\n            setTimeout(() => setSyncStatus('idle'), 2000);\n            \n        } catch (err) {\n            console.error('Error syncing with server:', err);\n            setSyncStatus('error');\n            \n            // Clear error status after 5 seconds\n            setTimeout(() => setSyncStatus('idle'), 5000);\n        }\n    }, [selectedProfile]);\n\n    const selectProfile = useCallback(async (profile) => {\n        try {\n            setSelectedProfile(profile);\n            saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, profile);\n            \n            // Load statistics for the selected profile\n            await loadProfileStatistics(profile.id);\n            \n            // Update last played on server\n            await updateLastPlayed(profile.id);\n            \n        } catch (err) {\n            console.error('Error selecting profile:', err);\n            setError('Failed to select profile');\n        }\n    }, [loadProfileStatistics, updateLastPlayed, STORAGE_KEYS.SELECTED_PROFILE]);\n\n    const createProfile = useCallback(async (profileData) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch('/api/players', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(profileData)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to create profile');\n            }\n\n            const newProfile = await response.json();\n            \n            // Update local state\n            const updatedProfiles = [...profiles, newProfile];\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Auto-select the new profile\n            await selectProfile(newProfile);\n            \n            return newProfile;\n            \n        } catch (err) {\n            console.error('Error creating profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectProfile, STORAGE_KEYS.PROFILES_CACHE]);\n\n    const updateProfile = useCallback(async (profileId, updateData) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch(`/api/players/${profileId}`, {\n                method: 'PUT',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(updateData)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to update profile');\n            }\n\n            const updatedProfile = await response.json();\n            \n            // Update local state\n            const updatedProfiles = profiles.map(p => \n                p.id === profileId ? updatedProfile : p\n            );\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Update selected profile if it's the one being updated\n            if (selectedProfile && selectedProfile.id === profileId) {\n                setSelectedProfile(updatedProfile);\n                saveToLocalStorage(STORAGE_KEYS.SELECTED_PROFILE, updatedProfile);\n            }\n            \n            return updatedProfile;\n            \n        } catch (err) {\n            console.error('Error updating profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectedProfile, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE]);\n\n    const deleteProfile = useCallback(async (profileId) => {\n        try {\n            setLoading(true);\n            setError(null);\n            \n            const response = await fetch(`/api/players/${profileId}`, {\n                method: 'DELETE'\n            });\n\n            if (!response.ok) {\n                throw new Error('Failed to delete profile');\n            }\n\n            // Update local state\n            const updatedProfiles = profiles.filter(p => p.id !== profileId);\n            setProfiles(updatedProfiles);\n            saveToLocalStorage(STORAGE_KEYS.PROFILES_CACHE, updatedProfiles);\n            \n            // Clear selected profile if it was deleted\n            if (selectedProfile && selectedProfile.id === profileId) {\n                setSelectedProfile(null);\n                localStorage.removeItem(STORAGE_KEYS.SELECTED_PROFILE);\n            }\n            \n            // Remove from statistics cache\n            const updatedStats = { ...profileStatistics };\n            delete updatedStats[profileId];\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n        } catch (err) {\n            console.error('Error deleting profile:', err);\n            setError(err.message);\n            throw err;\n        } finally {\n            setLoading(false);\n        }\n    }, [profiles, selectedProfile, profileStatistics, STORAGE_KEYS.PROFILES_CACHE, STORAGE_KEYS.SELECTED_PROFILE, STORAGE_KEYS.STATISTICS_CACHE]);\n\n    const loadProfileStatistics = useCallback(async (profileId) => {\n        try {\n            // Return cached statistics if available and recent\n            const cached = profileStatistics[profileId];\n            if (cached && (Date.now() - cached.loadedAt) < 300000) { // 5 minutes\n                return cached.data;\n            }\n            \n            const response = await fetch(`/api/players/${profileId}/statistics`);\n            if (!response.ok) {\n                // Statistics might not exist for new profiles\n                return null;\n            }\n            \n            const stats = await response.json();\n            \n            // Cache the statistics\n            const updatedStats = {\n                ...profileStatistics,\n                [profileId]: {\n                    data: stats,\n                    loadedAt: Date.now()\n                }\n            };\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n            return stats;\n            \n        } catch (err) {\n            console.error('Error loading profile statistics:', err);\n            return null;\n        }\n    }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n\n    const updateLastPlayed = useCallback(async (profileId) => {\n        try {\n            await fetch(`/api/players/${profileId}`, {\n                method: 'PUT',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    last_played: new Date().toISOString()\n                })\n            });\n        } catch (err) {\n            console.error('Error updating last played:', err);\n            // Don't throw - this is not critical\n        }\n    }, [STORAGE_KEYS.LAST_SYNC]);\n\n    const recordGameResult = useCallback(async (gameResult) => {\n        try {\n            const response = await fetch('/api/game-results', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(gameResult)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to record game result');\n            }\n\n            const result = await response.json();\n            \n            // Invalidate cached statistics for the player\n            const updatedStats = { ...profileStatistics };\n            delete updatedStats[gameResult.player_profile_id];\n            setProfileStatistics(updatedStats);\n            saveToLocalStorage(STORAGE_KEYS.STATISTICS_CACHE, updatedStats);\n            \n            return result;\n            \n        } catch (err) {\n            console.error('Error recording game result:', err);\n            setError(err.message);\n            throw err;\n        }\n    }, [profileStatistics, STORAGE_KEYS.STATISTICS_CACHE]);\n\n    const getProfileById = useCallback((profileId) => {\n        return profiles.find(p => p.id === profileId);\n    }, [profiles]);\n\n    const getProfileByName = useCallback((name) => {\n        return profiles.find(p => p.name.toLowerCase() === name.toLowerCase());\n    }, [profiles]);\n\n    const clearError = useCallback(() => {\n        setError(null);\n    }, []);\n\n    const refreshProfiles = useCallback(async () => {\n        await syncWithServer();\n    }, [syncWithServer]);\n\n    // Export/Import functionality\n    const exportProfileData = useCallback(async (profileId) => {\n        try {\n            const profile = getProfileById(profileId);\n            const statistics = await loadProfileStatistics(profileId);\n            \n            const exportData = {\n                profile,\n                statistics,\n                exportedAt: new Date().toISOString(),\n                version: '1.0'\n            };\n            \n            // Create and download file\n            const blob = new Blob([JSON.stringify(exportData, null, 2)], {\n                type: 'application/json'\n            });\n            const url = URL.createObjectURL(blob);\n            const link = document.createElement('a');\n            link.href = url;\n            link.download = `wgp-profile-${profile.name}-${new Date().toISOString().split('T')[0]}.json`;\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n            URL.revokeObjectURL(url);\n            \n        } catch (err) {\n            console.error('Error exporting profile data:', err);\n            setError('Failed to export profile data');\n        }\n    }, [getProfileById, loadProfileStatistics, selectedProfile]);\n\n    // Check if profile exists locally\n    const hasProfiles = profiles.length > 0;\n    const hasSelectedProfile = selectedProfile !== null;\n    \n    // Get current profile statistics\n    const currentProfileStats = selectedProfile ? \n        profileStatistics[selectedProfile.id]?.data : null;\n\n    return {\n        // State\n        selectedProfile,\n        profiles,\n        profileStatistics: currentProfileStats,\n        loading,\n        error,\n        syncStatus,\n        hasProfiles,\n        hasSelectedProfile,\n        \n        // Actions\n        selectProfile,\n        createProfile,\n        updateProfile,\n        deleteProfile,\n        loadProfileStatistics,\n        recordGameResult,\n        refreshProfiles,\n        exportProfileData,\n        clearError,\n        \n        // Utilities\n        getProfileById,\n        getProfileByName,\n        syncWithServer\n    };\n};\n\nexport default usePlayerProfile;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
./coverage/lcov-report/src/hooks/usePlayerProfile.js.html:1228:            const response = <span class="cstat-no" title="statement not covered" >await fetch('/api/game-results', {</span>
./src/context/__tests__/GameProvider.test.js:224:      expect(fetch).toHaveBeenCalledWith(`${process.env.REACT_APP_API_URL}/api/game/state`);
./src/context/__tests__/GameProvider.test.js:265:        `${process.env.REACT_APP_API_URL}/api/game/action`,
./src/hooks/usePlayerProfile.js:313:            const response = await fetch('/api/game-results', {
./src/pages/__tests__/GamePage.test.js:106:        expect.stringContaining('/api/game/setup'),
